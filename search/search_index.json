{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Exercices pratiques en NSI \u2693\ufe0e Des exercices \u00e0 r\u00e9soudre en ligne. des exercices faciles \u00e0 coder enti\u00e8rement, des codes \u00e0 trous \u00e0 compl\u00e9ter, dans les entr\u00e9es pr\u00e9pond\u00e9rantes, d'autres exercices plus difficiles. Les auteurs sont cit\u00e9s dans le fichier source sujet.md de chaque exercice. Les enseignants qui souhaitent contribuer peuvent rejoindre le forum des enseignants de NSI. Comment est construit ce site \u2693\ufe0e Ce site est r\u00e9dig\u00e9 en Markdown , construit de fa\u00e7on statique avec MkDocs et le th\u00e8me Material . Cette construction se fait \u00e0 partir des fichiers h\u00e9berg\u00e9s sur la plateforme de d\u00e9veloppement GitLab (lien vers le d\u00e9p\u00f4t en bas de page). Les logiciels qui servent \u00e0 construire et publier ce site sont des logiciels libres et respectent les 4 libert\u00e9s : Utiliser le logiciel pour tous les usages \u00c9tudier le code source du logiciel Distribuer le logiciel de fa\u00e7on libre Am\u00e9liorer le logiciel et distribuer les am\u00e9liorations. Le site fonctionne donc sans tracker de suivi ni cookies (aucune mesure d'audience). Le code JavaScript ex\u00e9cut\u00e9 sert pour la console de d\u00e9veloppement int\u00e9gr\u00e9 sur les pages et nous l'h\u00e9bergeons \u00e9galement. Seul MathJax (utilis\u00e9 pour le rendu des formules math\u00e9matiques) est servi depuis un cdn (cdn.jsdeliver.net)","title":"\ud83c\udfe1 Accueil"},{"location":"#exercices-pratiques-en-nsi","text":"Des exercices \u00e0 r\u00e9soudre en ligne. des exercices faciles \u00e0 coder enti\u00e8rement, des codes \u00e0 trous \u00e0 compl\u00e9ter, dans les entr\u00e9es pr\u00e9pond\u00e9rantes, d'autres exercices plus difficiles. Les auteurs sont cit\u00e9s dans le fichier source sujet.md de chaque exercice. Les enseignants qui souhaitent contribuer peuvent rejoindre le forum des enseignants de NSI.","title":"Exercices pratiques en NSI"},{"location":"#comment-est-construit-ce-site","text":"Ce site est r\u00e9dig\u00e9 en Markdown , construit de fa\u00e7on statique avec MkDocs et le th\u00e8me Material . Cette construction se fait \u00e0 partir des fichiers h\u00e9berg\u00e9s sur la plateforme de d\u00e9veloppement GitLab (lien vers le d\u00e9p\u00f4t en bas de page). Les logiciels qui servent \u00e0 construire et publier ce site sont des logiciels libres et respectent les 4 libert\u00e9s : Utiliser le logiciel pour tous les usages \u00c9tudier le code source du logiciel Distribuer le logiciel de fa\u00e7on libre Am\u00e9liorer le logiciel et distribuer les am\u00e9liorations. Le site fonctionne donc sans tracker de suivi ni cookies (aucune mesure d'audience). Le code JavaScript ex\u00e9cut\u00e9 sert pour la console de d\u00e9veloppement int\u00e9gr\u00e9 sur les pages et nous l'h\u00e9bergeons \u00e9galement. Seul MathJax (utilis\u00e9 pour le rendu des formules math\u00e9matiques) est servi depuis un cdn (cdn.jsdeliver.net)","title":"Comment est construit ce site"},{"location":"tags/","text":"Tags \u2693\ufe0e Pour une recherche d'exercices par tag POO \u2693\ufe0e Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e a_trou \u2693\ufe0e Collage Code de C\u00e9sar Suite de Conway texte inclus Nombre est-il palindrome Un mot est-il parfait ? Expression parenth\u00e9s\u00e9e Formes g\u00e9om\u00e9triques ASCII Fusion de listes tri\u00e9es Ins\u00e8re dans liste tri\u00e9e Sortie de labyrinthe Nombres de Catalan I Nombre Factoriel Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Tableau de 0 et 1 Transposition Tri \u00e0 bulles Triangle de Pascal Nombres de chemins dans une grille Nombres de Delannoy Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Nombres de chemins dans une grille (2) adhoc \u2693\ufe0e Soleil couchant Suite de Conway arbre \u2693\ufe0e Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e Nombres de Catalan II Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) boucle \u2693\ufe0e Maximum Compte d'occurrences Derni\u00e8re occurrence Est tri\u00e9 ? Indice premi\u00e8re occurrence Dentiste Liste des diff\u00e9rences Soleil couchant Exclamations Gel\u00e9es Multiplier sans * Recherche d'indices Remplacer une valeur Valeur et indice du max Collage Moyenne pond\u00e9r\u00e9e Nombres puis double Codage par diff\u00e9rence Moyenne simple \u00c9cr\u00eatage Palindrome D\u00e9coupe arange linspace Nombre de z\u00e9ros \u00e0 la fin d'un entier Top-Likes ! Occurrences du minimum Tous diff\u00e9rents Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents Suite de Syracuse Tri par s\u00e9lection Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Code de C\u00e9sar Suite de Conway Crible d'\u00c9ratosth\u00e8ne Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII Ins\u00e8re dans liste tri\u00e9e Nombre Factoriel Indice dans un tableau tri\u00e9 Tableau de 0 et 1 Triangle de Pascal Carr\u00e9s magiques normaux d'ordre n Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) chemin \u2693\ufe0e Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) compr\u00e9hension \u2693\ufe0e Transposition dictionnaire \u2693\ufe0e Anniversaires Top-Likes ! Couleurs Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents T\u00eate de s\u00e9rie Nombres de chemins dans une grille Nombres de Delannoy diviser pour r\u00e9gner \u2693\ufe0e Sommet d'un tableau unimodal float \u2693\ufe0e arange linspace glouton \u2693\ufe0e Rendu de monnaie graphe \u2693\ufe0e Sortie de labyrinthe grille \u2693\ufe0e Aplatir Sortie de labyrinthe Percolation Propagation sur image Redimensionner Transposition Carr\u00e9s magiques normaux d'ordre n maths \u2693\ufe0e Moyenne pond\u00e9r\u00e9e Rendu de monnaie Nombre de z\u00e9ros \u00e0 la fin d'un entier Suite de Syracuse Crible d'\u00c9ratosth\u00e8ne Un mot est-il parfait ? Nombres de Catalan I Nombre Factoriel Triangle de Pascal Nombre de z\u00e9ros de n! (1) Nombres de Catalan II Nombres de chemins dans une grille Nombres de Motzkin Nombres de Schr\u00f6der maths+ \u2693\ufe0e Carr\u00e9s magiques normaux d'ordre n Nombres de Delannoy Nombres d'Hipparque Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) Nombre de partitions m\u00e9mo \u2693\ufe0e Nombres de Catalan I Nombre Factoriel Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Nombre de partitions prog.dynamique \u2693\ufe0e communication des acacias Nombre de z\u00e9ros de n! (1) Nombre serpent r\u00e9cursivit\u00e9 \u2693\ufe0e Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Percolation Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Nombres de Catalan II Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) Nombre de partitions string \u2693\ufe0e Compte d'occurrences Dentiste Exclamations Collage Palindrome D\u00e9coupe Couleurs Dictionnaire d'occurrences Code de C\u00e9sar Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII tri \u2693\ufe0e Tri par s\u00e9lection Fusion de listes tri\u00e9es Tableau de 0 et 1 Tri \u00e0 bulles tuple \u2693\ufe0e Valeur et indice du max Moyenne pond\u00e9r\u00e9e Codage par diff\u00e9rence","title":"Tags"},{"location":"tags/#tags","text":"Pour une recherche d'exercices par tag","title":"Tags"},{"location":"tags/#poo","text":"Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e","title":"POO"},{"location":"tags/#a_trou","text":"Collage Code de C\u00e9sar Suite de Conway texte inclus Nombre est-il palindrome Un mot est-il parfait ? Expression parenth\u00e9s\u00e9e Formes g\u00e9om\u00e9triques ASCII Fusion de listes tri\u00e9es Ins\u00e8re dans liste tri\u00e9e Sortie de labyrinthe Nombres de Catalan I Nombre Factoriel Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Tableau de 0 et 1 Transposition Tri \u00e0 bulles Triangle de Pascal Nombres de chemins dans une grille Nombres de Delannoy Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Nombres de chemins dans une grille (2)","title":"a_trou"},{"location":"tags/#adhoc","text":"Soleil couchant Suite de Conway","title":"adhoc"},{"location":"tags/#arbre","text":"Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e Nombres de Catalan II Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2)","title":"arbre"},{"location":"tags/#boucle","text":"Maximum Compte d'occurrences Derni\u00e8re occurrence Est tri\u00e9 ? Indice premi\u00e8re occurrence Dentiste Liste des diff\u00e9rences Soleil couchant Exclamations Gel\u00e9es Multiplier sans * Recherche d'indices Remplacer une valeur Valeur et indice du max Collage Moyenne pond\u00e9r\u00e9e Nombres puis double Codage par diff\u00e9rence Moyenne simple \u00c9cr\u00eatage Palindrome D\u00e9coupe arange linspace Nombre de z\u00e9ros \u00e0 la fin d'un entier Top-Likes ! Occurrences du minimum Tous diff\u00e9rents Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents Suite de Syracuse Tri par s\u00e9lection Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Code de C\u00e9sar Suite de Conway Crible d'\u00c9ratosth\u00e8ne Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII Ins\u00e8re dans liste tri\u00e9e Nombre Factoriel Indice dans un tableau tri\u00e9 Tableau de 0 et 1 Triangle de Pascal Carr\u00e9s magiques normaux d'ordre n Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2)","title":"boucle"},{"location":"tags/#chemin","text":"Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2)","title":"chemin"},{"location":"tags/#comprehension","text":"Transposition","title":"compr\u00e9hension"},{"location":"tags/#dictionnaire","text":"Anniversaires Top-Likes ! Couleurs Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents T\u00eate de s\u00e9rie Nombres de chemins dans une grille Nombres de Delannoy","title":"dictionnaire"},{"location":"tags/#diviser-pour-regner","text":"Sommet d'un tableau unimodal","title":"diviser pour r\u00e9gner"},{"location":"tags/#float","text":"arange linspace","title":"float"},{"location":"tags/#glouton","text":"Rendu de monnaie","title":"glouton"},{"location":"tags/#graphe","text":"Sortie de labyrinthe","title":"graphe"},{"location":"tags/#grille","text":"Aplatir Sortie de labyrinthe Percolation Propagation sur image Redimensionner Transposition Carr\u00e9s magiques normaux d'ordre n","title":"grille"},{"location":"tags/#maths","text":"Moyenne pond\u00e9r\u00e9e Rendu de monnaie Nombre de z\u00e9ros \u00e0 la fin d'un entier Suite de Syracuse Crible d'\u00c9ratosth\u00e8ne Un mot est-il parfait ? Nombres de Catalan I Nombre Factoriel Triangle de Pascal Nombre de z\u00e9ros de n! (1) Nombres de Catalan II Nombres de chemins dans une grille Nombres de Motzkin Nombres de Schr\u00f6der","title":"maths"},{"location":"tags/#maths_1","text":"Carr\u00e9s magiques normaux d'ordre n Nombres de Delannoy Nombres d'Hipparque Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) Nombre de partitions","title":"maths+"},{"location":"tags/#memo","text":"Nombres de Catalan I Nombre Factoriel Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Nombre de partitions","title":"m\u00e9mo"},{"location":"tags/#progdynamique","text":"communication des acacias Nombre de z\u00e9ros de n! (1) Nombre serpent","title":"prog.dynamique"},{"location":"tags/#recursivite","text":"Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Percolation Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Nombres de Catalan II Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) Nombre de partitions","title":"r\u00e9cursivit\u00e9"},{"location":"tags/#string","text":"Compte d'occurrences Dentiste Exclamations Collage Palindrome D\u00e9coupe Couleurs Dictionnaire d'occurrences Code de C\u00e9sar Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII","title":"string"},{"location":"tags/#tri","text":"Tri par s\u00e9lection Fusion de listes tri\u00e9es Tableau de 0 et 1 Tri \u00e0 bulles","title":"tri"},{"location":"tags/#tuple","text":"Valeur et indice du max Moyenne pond\u00e9r\u00e9e Codage par diff\u00e9rence","title":"tuple"},{"location":"1-facile/1050-maximum_nombres/exo_REM/","text":"Commentaires \u2693\ufe0e Il s'agit d'une recherche de maximum classique. La liste \u00e9tant non-vide, on initialise la maxi avec la premi\u00e8re valeur. \ud83d\udc0d Script Python def maximum ( nombres ): maxi = nombres [ 0 ] for nb in nombres : if nb > maxi : maxi = nb return maxi","title":"Commentaires"},{"location":"1-facile/1050-maximum_nombres/exo_REM/#commentaires","text":"Il s'agit d'une recherche de maximum classique. La liste \u00e9tant non-vide, on initialise la maxi avec la premi\u00e8re valeur. \ud83d\udc0d Script Python def maximum ( nombres ): maxi = nombres [ 0 ] for nb in nombres : if nb > maxi : maxi = nb return maxi","title":"Commentaires"},{"location":"1-facile/1050-maximum_nombres/sujet/","tags":["boucle"],"text":"Maximum \u2693\ufe0e \u00c9crire la fonction maximum : prenant en param\u00e8tre une liste non vide de nombres : nombres renvoyant le plus grand \u00e9l\u00e9ment de cette liste. Contrainte On interdit d'utiliser max Exemples : \ud83d\udc0d Script Python >>> maximum ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maximum ([ - 27 , 24 , - 3 , 15 ]) 24 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert maximum([1, 2, 3, 4, 5]) == 5backslash-newlineassert maximum([5, 4, 3, 2, 1]) == 5backslash-newlineassert maximum([5, 5, 5]) == 5backslash-newlineassert maximum([5.01, 5.02, 5.0]) == 5.02backslash-newlineassert maximum([-5, -4, -3, -8, -6]) == -3backslash-newlinebackslash-newline Valider 5/5 def maximum(nombres):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newlinebackslash-newline def maximum(nombres):backslash-newline maxi = nombres[0]backslash-newline for nb in nombres:backslash-newline if nb > maxi:backslash-newline maxi = nbbackslash-newline return maxibackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Il s'agit d'une recherche de maximum classique. La liste \u00e9tant non-vide, on initialise la maxi avec la premi\u00e8re valeur. {{ py('exo_corr', 0, '# TESTS') }} Z","title":"Maximum"},{"location":"1-facile/1050-maximum_nombres/sujet/#maximum","text":"\u00c9crire la fonction maximum : prenant en param\u00e8tre une liste non vide de nombres : nombres renvoyant le plus grand \u00e9l\u00e9ment de cette liste. Contrainte On interdit d'utiliser max Exemples : \ud83d\udc0d Script Python >>> maximum ([ 98 , 12 , 104 , 23 , 131 , 9 ]) 131 >>> maximum ([ - 27 , 24 , - 3 , 15 ]) 24 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert maximum([1, 2, 3, 4, 5]) == 5backslash-newlineassert maximum([5, 4, 3, 2, 1]) == 5backslash-newlineassert maximum([5, 5, 5]) == 5backslash-newlineassert maximum([5.01, 5.02, 5.0]) == 5.02backslash-newlineassert maximum([-5, -4, -3, -8, -6]) == -3backslash-newlinebackslash-newline Valider 5/5 def maximum(nombres):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newlinebackslash-newline def maximum(nombres):backslash-newline maxi = nombres[0]backslash-newline for nb in nombres:backslash-newline if nb > maxi:backslash-newline maxi = nbbackslash-newline return maxibackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert maximum([98, 12, 104, 23, 131, 9]) == 131backslash-newlineassert maximum([-27, 24, -3, 15]) == 24backslash-newlinebackslash-newlinebackslash-newline A","title":"Maximum"},{"location":"1-facile/1050-maximum_nombres/sujet/#commentaires","text":"Il s'agit d'une recherche de maximum classique. La liste \u00e9tant non-vide, on initialise la maxi avec la premi\u00e8re valeur. {{ py('exo_corr', 0, '# TESTS') }} Z","title":"Commentaires"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/","text":"Commentaires \u2693\ufe0e It\u00e9ration sans indice \u2693\ufe0e Version recommand\u00e9e \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for lettre in mot : if lettre == caractere : nb_occurrences += 1 return nb_occurrences It\u00e9ration avec indice \u2693\ufe0e Version possible \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occurrences += 1 return nb_occurrences Version fonctionnelle \u2693\ufe0e Pour les bons \u00e9l\u00e8ves ; n'est pas hors programme. \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return sum ( 1 for lettre in mot if lettre == caractere ) Version non autoris\u00e9e \u2693\ufe0e Avec la facilit\u00e9 du langage Python ( count ). \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return mot . count ( caractere )","title":"Commentaires"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/#iteration-sans-indice","text":"Version recommand\u00e9e \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for lettre in mot : if lettre == caractere : nb_occurrences += 1 return nb_occurrences","title":"It\u00e9ration sans indice"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/#iteration-avec-indice","text":"Version possible \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occurrences += 1 return nb_occurrences","title":"It\u00e9ration avec indice"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/#version-fonctionnelle","text":"Pour les bons \u00e9l\u00e8ves ; n'est pas hors programme. \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return sum ( 1 for lettre in mot if lettre == caractere )","title":"Version fonctionnelle"},{"location":"1-facile/1100-cpt_occurrences/exo_REM/#version-non-autorisee","text":"Avec la facilit\u00e9 du langage Python ( count ). \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return mot . count ( caractere )","title":"Version non autoris\u00e9e"},{"location":"1-facile/1100-cpt_occurrences/sujet/","tags":["boucle","string"],"text":"Occurrences d'un caract\u00e8re dans un mot \u2693\ufe0e \u00c9crire une fonction compte_occurrences qui prend en param\u00e8tres caractere , un caract\u00e8re (une chaine de caract\u00e8res de longueur 1), et mot , une chaine de caract\u00e8res, et qui renvoie le nombre d'occurrences de caractere dans mot , c'est-\u00e0-dire le nombre de fois o\u00f9 caractere apparait dans mot . On n'utilisera pas la m\u00e9thode count . Exemples \ud83d\udc0d Console Python >>> compte_occurrences ( \"e\" , \"sciences\" ) 2 >>> compte_occurrences ( \"i\" , \"mississippi\" ) 4 >>> compte_occurrences ( \"a\" , \"mississippi\" ) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0, 'Erreur sur ce test'backslash-newlinebackslash-newline# autres testsbackslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"\") == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"a\") == 1backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"b\") == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"b\"python-star1000) == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"a\"python-star1000) == 1000backslash-newlinebackslash-newline Valider 5/5 def comptepython-underscoreoccurrences(caractere, mot):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0backslash-newlinebackslash-newline def comptepython-underscoreoccurrences(caractere, mot):backslash-newline nbpython-underscoreoccurrences = 0backslash-newline for lettre in mot:backslash-newline if lettre == caractere:backslash-newline nbpython-underscoreoccurrences += 1backslash-newline return nbpython-underscoreoccurrencesbackslash-newlinebackslash-newline# testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0, 'Erreur sur ce test'backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e It\u00e9ration sans indice \u2693\ufe0e Version recommand\u00e9e {{ py('exo_corr') }} It\u00e9ration avec indice \u2693\ufe0e Version possible \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occurrences += 1 return nb_occurrences Version fonctionnelle \u2693\ufe0e Pour les bons \u00e9l\u00e8ves ; n'est pas hors programme. \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return sum ( 1 for lettre in mot if lettre == caractere ) Version non autoris\u00e9e \u2693\ufe0e Avec la facilit\u00e9 du langage Python ( count ). \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return mot . count ( caractere ) Z","title":"Compte d'occurrences"},{"location":"1-facile/1100-cpt_occurrences/sujet/#occurrences-dun-caractere-dans-un-mot","text":"\u00c9crire une fonction compte_occurrences qui prend en param\u00e8tres caractere , un caract\u00e8re (une chaine de caract\u00e8res de longueur 1), et mot , une chaine de caract\u00e8res, et qui renvoie le nombre d'occurrences de caractere dans mot , c'est-\u00e0-dire le nombre de fois o\u00f9 caractere apparait dans mot . On n'utilisera pas la m\u00e9thode count . Exemples \ud83d\udc0d Console Python >>> compte_occurrences ( \"e\" , \"sciences\" ) 2 >>> compte_occurrences ( \"i\" , \"mississippi\" ) 4 >>> compte_occurrences ( \"a\" , \"mississippi\" ) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0, 'Erreur sur ce test'backslash-newlinebackslash-newline# autres testsbackslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"\") == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"a\") == 1backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"b\") == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"b\"python-star1000) == 0backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"a\"python-star1000) == 1000backslash-newlinebackslash-newline Valider 5/5 def comptepython-underscoreoccurrences(caractere, mot):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0backslash-newlinebackslash-newline def comptepython-underscoreoccurrences(caractere, mot):backslash-newline nbpython-underscoreoccurrences = 0backslash-newline for lettre in mot:backslash-newline if lettre == caractere:backslash-newline nbpython-underscoreoccurrences += 1backslash-newline return nbpython-underscoreoccurrencesbackslash-newlinebackslash-newline# testsbackslash-newlineassert comptepython-underscoreoccurrences(\"e\", \"sciences\") == 2, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"i\", \"mississippi\") == 4, 'Erreur sur ce test'backslash-newlineassert comptepython-underscoreoccurrences(\"a\", \"mississippi\") == 0, 'Erreur sur ce test'backslash-newlinebackslash-newline A","title":"Occurrences d'un caract\u00e8re dans un mot"},{"location":"1-facile/1100-cpt_occurrences/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1100-cpt_occurrences/sujet/#iteration-sans-indice","text":"Version recommand\u00e9e {{ py('exo_corr') }}","title":"It\u00e9ration sans indice"},{"location":"1-facile/1100-cpt_occurrences/sujet/#iteration-avec-indice","text":"Version possible \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): nb_occurrences = 0 for i in range ( len ( mot )): if mot [ i ] == caractere : nb_occurrences += 1 return nb_occurrences","title":"It\u00e9ration avec indice"},{"location":"1-facile/1100-cpt_occurrences/sujet/#version-fonctionnelle","text":"Pour les bons \u00e9l\u00e8ves ; n'est pas hors programme. \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return sum ( 1 for lettre in mot if lettre == caractere )","title":"Version fonctionnelle"},{"location":"1-facile/1100-cpt_occurrences/sujet/#version-non-autorisee","text":"Avec la facilit\u00e9 du langage Python ( count ). \ud83d\udc0d Script Python def compte_occurrences ( caractere , mot ): return mot . count ( caractere ) Z","title":"Version non autoris\u00e9e"},{"location":"1-facile/1100-derniere_occurence/exo_REM/","text":"En commen\u00e7ant par la fin, on s'arr\u00eate d\u00e8s qu'on trouve la cible : \ud83d\udc0d Script Python def derniere_occurrence ( tableau , cible ): for i in range ( len ( tableau ) - 1 , - 1 , - 1 ): if tableau [ i ] == cible : return i return len ( tableau )","title":"exo REM"},{"location":"1-facile/1100-derniere_occurence/sujet/","tags":["boucle"],"text":"Programmer la fonction derniere_occurrence , prenant en param\u00e8tre un tableau non vide d'entiers et un entier cible , et qui renvoie l'indice de la derni\u00e8re occurrence de cible . Si l'\u00e9l\u00e9ment n'est pas pr\u00e9sent, la fonction renvoie la longueur du tableau. On n'utilisera pas la fonction index Exemples \ud83d\udc0d Script Python >>> derniere_occurrence ([ 5 , 3 ], 1 ) 2 >>> derniere_occurrence ([ 2 , 4 ], 2 ) 0 >>> derniere_occurrence ([ 2 , 3 , 5 , 2 , 4 ], 2 ) 3 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert dernierepython-underscoreoccurrence([5, 3], 1) == 2backslash-newlineassert dernierepython-underscoreoccurrence([2, 4], 2) == 0backslash-newlineassert dernierepython-underscoreoccurrence([2, 3, 5, 2, 4], 2) == 3backslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlineassert dernierepython-underscoreoccurrence([1, 2, 1, 2, 1], 1) == 4backslash-newlineassert dernierepython-underscoreoccurrence([1, 2, 3, 4, 5], 0) == 5backslash-newlineassert dernierepython-underscoreoccurrence([1, 2, 3], 1) == 0backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 # Votre fonction icibackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert dernierepython-underscoreoccurrence([5, 3], 1) == 2backslash-newlineassert dernierepython-underscoreoccurrence([2, 4], 2) == 0backslash-newlineassert dernierepython-underscoreoccurrence([2, 3, 5, 2, 4], 2) == 3backslash-newlinebackslash-newline def dernierepython-underscoreoccurrence(tableau, cible):backslash-newline indicepython-underscoredernier = len(tableau)backslash-newline for i in range(len(tableau)):backslash-newline if tableau[i] == cible:backslash-newline indicepython-underscoredernier = ibackslash-newline return indicepython-underscoredernierbackslash-newlinebackslash-newline A En commen\u00e7ant par la fin, on s'arr\u00eate d\u00e8s qu'on trouve la cible : \ud83d\udc0d Script Python def derniere_occurrence ( tableau , cible ): for i in range ( len ( tableau ) - 1 , - 1 , - 1 ): if tableau [ i ] == cible : return i return len ( tableau ) Z","title":"Derni\u00e8re occurrence"},{"location":"1-facile/1150-denivele_positif/sujet/","text":"Calcul du d\u00e9nivel\u00e9 cumul\u00e9 positif d'une course de montagne \u2693\ufe0e Le d\u00e9nivel\u00e9 cumul\u00e9 positif d'une course de montagne est le d\u00e9nivel\u00e9 total de l'ensemble des ascensions durant la course. Sur l'exemple ci-dessus : la course commence par une ascension de d\u00e9nivel\u00e9 positif \\(160\\) ( \\(490-330\\) ) entre l'\u00e9tape 2 et l'\u00e9tape 3, le d\u00e9nivel\u00e9 positif est de \\(230\\) ( \\(610-380\\) ) entre l'\u00e9tape 3 et l'\u00e9tape 4, le d\u00e9nivel\u00e9 positif est de \\(170\\) ( \\(780-610\\) ) les autres parties de la course sont des descentes Le d\u00e9nivel\u00e9 cumul\u00e9 positif total de cette course est donc \\(160+230+170=560\\) \u00c9crire une fonction denivele_positif qui prend en argument la liste non vide des altitudes atteintes \u00e0 la fin de chaque ascension et de chaque descente pendant la course et qui renvoie le d\u00e9nivel\u00e9 cumul\u00e9 positif de cette course. Exemples \ud83d\udc0d Console Python >>> denivele_positif ([ 330 , 490 , 380 , 610 , 780 , 550 ]) 560 >>> denivele_positif ([ 200 , 300 , 100 ]) 100 >>> denivele_positif ([ 150 ]) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([200]) == 0backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline Valider 5/5 def denivelepython-underscorepositif(altitudes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline def denivelepython-underscorepositif(altitudes):backslash-newline denivele = 0backslash-newline for i in range(len(altitudes) - 1):backslash-newline if altitudes[i + 1] > altitudes[i]:backslash-newline denivele += altitudes[i + 1] - altitudes[i]backslash-newline return denivelebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline A Z","title":"D\u00e9nivel\u00e9 positif"},{"location":"1-facile/1150-denivele_positif/sujet/#calcul-du-denivele-cumule-positif-dune-course-de-montagne","text":"Le d\u00e9nivel\u00e9 cumul\u00e9 positif d'une course de montagne est le d\u00e9nivel\u00e9 total de l'ensemble des ascensions durant la course. Sur l'exemple ci-dessus : la course commence par une ascension de d\u00e9nivel\u00e9 positif \\(160\\) ( \\(490-330\\) ) entre l'\u00e9tape 2 et l'\u00e9tape 3, le d\u00e9nivel\u00e9 positif est de \\(230\\) ( \\(610-380\\) ) entre l'\u00e9tape 3 et l'\u00e9tape 4, le d\u00e9nivel\u00e9 positif est de \\(170\\) ( \\(780-610\\) ) les autres parties de la course sont des descentes Le d\u00e9nivel\u00e9 cumul\u00e9 positif total de cette course est donc \\(160+230+170=560\\) \u00c9crire une fonction denivele_positif qui prend en argument la liste non vide des altitudes atteintes \u00e0 la fin de chaque ascension et de chaque descente pendant la course et qui renvoie le d\u00e9nivel\u00e9 cumul\u00e9 positif de cette course. Exemples \ud83d\udc0d Console Python >>> denivele_positif ([ 330 , 490 , 380 , 610 , 780 , 550 ]) 560 >>> denivele_positif ([ 200 , 300 , 100 ]) 100 >>> denivele_positif ([ 150 ]) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([200]) == 0backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline Valider 5/5 def denivelepython-underscorepositif(altitudes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline def denivelepython-underscorepositif(altitudes):backslash-newline denivele = 0backslash-newline for i in range(len(altitudes) - 1):backslash-newline if altitudes[i + 1] > altitudes[i]:backslash-newline denivele += altitudes[i + 1] - altitudes[i]backslash-newline return denivelebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert denivelepython-underscorepositif([330, 490, 380, 610, 780, 550]) == 560backslash-newlineassert denivelepython-underscorepositif([200, 300, 100]) == 100backslash-newlinebackslash-newline A Z","title":"Calcul du d\u00e9nivel\u00e9 cumul\u00e9 positif d'une course de montagne"},{"location":"1-facile/1150-est_trie/exo_REM/","text":"On peut coder cette phrase logique : Le tableau est tri\u00e9 s'il a moins de 2 \u00e9l\u00e9ments ou alors si chacun des \u00e9l\u00e9ments \u00e0 partir du 2e est sup\u00e9rieur ou \u00e9gal \u00e0 son pr\u00e9d\u00e9cesseur. \ud83d\udc0d Script Python def est_trie ( tab ): return all ( tab [ i ] >= tab [ i - 1 ] for i in range ( 1 , len ( tab ))) Notons, que pour la version du corrig\u00e9 et la version ci-dessus, on tire parti du fait que la boucle dans les cas o\u00f9 le tableau \u00e0 strictement moins de 2 \u00e9l\u00e9ments sera vide et all([]) renvoie True .","title":"exo REM"},{"location":"1-facile/1150-est_trie/sujet/","tags":["boucle"],"text":"Programmer la fonction est_trie qui prend en param\u00e8tre un tableau de valeurs num\u00e9riques et qui renvoie True si ce tableau est tri\u00e9 dans l'ordre croissant, False sinon. Exemples \ud83d\udc0d Console Python >>> est_trie ([ 0 , 5 , 8 , 8 , 9 ]) True >>> est_trie ([ 8 , 12 , 4 ]) False >>> est_trie ([ - 1 , 4 ]) True >>> est_trie ([ 5 ]) True >>> est_trie ([]) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert estpython-underscoretrie([0, 5, 8, 8, 9])backslash-newlineassert not estpython-underscoretrie([8, 12, 4])backslash-newlineassert estpython-underscoretrie([-1, 4])backslash-newlineassert estpython-underscoretrie([5])backslash-newlineassert estpython-underscoretrie([])backslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlineassert not estpython-underscoretrie([5, 4, 3, 2, 1, 0])backslash-newlineassert not estpython-underscoretrie([1, 2, 3, 4, 0])backslash-newlineassert estpython-underscoretrie([10, 10, 10, 10])backslash-newlineassert estpython-underscoretrie([-9, -9, -8, -6, -3, -2, 0, 4, 6, 7, 7, 7])backslash-newlinebackslash-newline Valider 5/5 # Votre fonction icibackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert estpython-underscoretrie([0, 5, 8, 8, 9])backslash-newlineassert not estpython-underscoretrie([8, 12, 4])backslash-newlineassert estpython-underscoretrie([-1, 4])backslash-newlineassert estpython-underscoretrie([5])backslash-newlineassert estpython-underscoretrie([])backslash-newlinebackslash-newline def estpython-underscoretrie(tableau):backslash-newline for i in range(1, len(tableau)):backslash-newline if tableau[i-1] > tableau[i]:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newline A On peut coder cette phrase logique : Le tableau est tri\u00e9 s'il a moins de 2 \u00e9l\u00e9ments ou alors si chacun des \u00e9l\u00e9ments \u00e0 partir du 2e est sup\u00e9rieur ou \u00e9gal \u00e0 son pr\u00e9d\u00e9cesseur. \ud83d\udc0d Script Python def est_trie ( tab ): return all ( tab [ i ] >= tab [ i - 1 ] for i in range ( 1 , len ( tab ))) Notons, que pour la version du corrig\u00e9 et la version ci-dessus, on tire parti du fait que la boucle dans les cas o\u00f9 le tableau \u00e0 strictement moins de 2 \u00e9l\u00e9ments sera vide et all([]) renvoie True . Z","title":"Est tri\u00e9 ?"},{"location":"1-facile/1150-ind_prem_occ/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def indice ( element , tableau ): for i in range ( len ( tableau )): if tableau [ i ] == element : return i La fonction fait un arr\u00eat pr\u00e9matur\u00e9 et renvoie l'indice d\u00e8s que la valeur est d\u00e9couverte. Si la valeur n'est pas trouv\u00e9e, la fonction renvoie None comme toute fonction Python qui termine sans rencontrer de return .","title":"Commentaires"},{"location":"1-facile/1150-ind_prem_occ/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def indice ( element , tableau ): for i in range ( len ( tableau )): if tableau [ i ] == element : return i La fonction fait un arr\u00eat pr\u00e9matur\u00e9 et renvoie l'indice d\u00e8s que la valeur est d\u00e9couverte. Si la valeur n'est pas trouv\u00e9e, la fonction renvoie None comme toute fonction Python qui termine sans rencontrer de return .","title":"Commentaires"},{"location":"1-facile/1150-ind_prem_occ/sujet/","tags":["boucle"],"text":"Indice de la premi\u00e8re occurrence \u2693\ufe0e \u00c9crire une fonction indice qui prend en param\u00e8tres element un nombre entier, tableau un tableau de nombres entiers, et qui renvoie l'indice de la premi\u00e8re occurrence de element dans tableau . La fonction devra renvoyer None si element est absent de tableau . On n'utilisera pas ni la fonction index , ni la fonction find . Exemples \ud83d\udc0d Console Python >>> indice ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> indice ( 1 , [ 1 , 50 , 1 ]) 0 >>> indice ( 15 , [ 8 , 9 , 10 , 15 ]) 3 >>> indice ( 1 , [ 2 , 3 , 4 ]) is None True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newlinebackslash-newline# autre testsbackslash-newlinebackslash-newlineassert indice(1, [10, 11, 12, 13]) is Nonebackslash-newlineassert indice(10, [10, 11, 12, 13]) == 0backslash-newlineassert indice(11, [10, 11, 12, 13]) == 1backslash-newlineassert indice(12, [10, 11, 12, 13]) == 2backslash-newlineassert indice(13, [10, 11, 12, 13]) == 3backslash-newlineassert indice(14, [10, 11, 12, 13]) is Nonebackslash-newlinebackslash-newlineassert indice(1, [13, 12, 11, 10]) is Nonebackslash-newlineassert indice(10, [13, 12, 11, 10]) == 3backslash-newlineassert indice(11, [13, 12, 11, 10]) == 2backslash-newlineassert indice(12, [13, 12, 11, 10]) == 1backslash-newlineassert indice(13, [13, 12, 11, 10]) == 0backslash-newlineassert indice(14, [13, 12, 11, 10]) is Nonebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def indice(element, tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newline def indice(element, tableau):backslash-newline for i in range(len(tableau)):backslash-newline if tableau[i] == element:backslash-newline return ibackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} La fonction fait un arr\u00eat pr\u00e9matur\u00e9 et renvoie l'indice d\u00e8s que la valeur est d\u00e9couverte. Si la valeur n'est pas trouv\u00e9e, la fonction renvoie None comme toute fonction Python qui termine sans rencontrer de return . Z","title":"Indice premi\u00e8re occurrence"},{"location":"1-facile/1150-ind_prem_occ/sujet/#indice-de-la-premiere-occurrence","text":"\u00c9crire une fonction indice qui prend en param\u00e8tres element un nombre entier, tableau un tableau de nombres entiers, et qui renvoie l'indice de la premi\u00e8re occurrence de element dans tableau . La fonction devra renvoyer None si element est absent de tableau . On n'utilisera pas ni la fonction index , ni la fonction find . Exemples \ud83d\udc0d Console Python >>> indice ( 1 , [ 10 , 12 , 1 , 56 ]) 2 >>> indice ( 1 , [ 1 , 50 , 1 ]) 0 >>> indice ( 15 , [ 8 , 9 , 10 , 15 ]) 3 >>> indice ( 1 , [ 2 , 3 , 4 ]) is None True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newlinebackslash-newline# autre testsbackslash-newlinebackslash-newlineassert indice(1, [10, 11, 12, 13]) is Nonebackslash-newlineassert indice(10, [10, 11, 12, 13]) == 0backslash-newlineassert indice(11, [10, 11, 12, 13]) == 1backslash-newlineassert indice(12, [10, 11, 12, 13]) == 2backslash-newlineassert indice(13, [10, 11, 12, 13]) == 3backslash-newlineassert indice(14, [10, 11, 12, 13]) is Nonebackslash-newlinebackslash-newlineassert indice(1, [13, 12, 11, 10]) is Nonebackslash-newlineassert indice(10, [13, 12, 11, 10]) == 3backslash-newlineassert indice(11, [13, 12, 11, 10]) == 2backslash-newlineassert indice(12, [13, 12, 11, 10]) == 1backslash-newlineassert indice(13, [13, 12, 11, 10]) == 0backslash-newlineassert indice(14, [13, 12, 11, 10]) is Nonebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def indice(element, tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newline def indice(element, tableau):backslash-newline for i in range(len(tableau)):backslash-newline if tableau[i] == element:backslash-newline return ibackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert indice(1, [10, 12, 1, 56]) == 2backslash-newlineassert indice(1, [1, 50, 1]) == 0backslash-newlineassert indice(15, [8, 9, 10, 15]) == 3backslash-newlineassert indice(1, [2, 3, 4]) is Nonebackslash-newlinebackslash-newline A","title":"Indice de la premi\u00e8re occurrence"},{"location":"1-facile/1150-ind_prem_occ/sujet/#commentaires","text":"{{ py('exo_corr') }} La fonction fait un arr\u00eat pr\u00e9matur\u00e9 et renvoie l'indice d\u00e8s que la valeur est d\u00e9couverte. Si la valeur n'est pas trouv\u00e9e, la fonction renvoie None comme toute fonction Python qui termine sans rencontrer de return . Z","title":"Commentaires"},{"location":"1-facile/1200-dentiste/sujet/","tags":["string","boucle"],"text":"\u00c9locution chez le dentiste \u2693\ufe0e Chez le dentiste, la bouche grande ouverte, lorsqu'on essaie de parler, il ne reste que les voyelles. M\u00eame les ponctuations sont supprim\u00e9es. Vous devez \u00e9crire une fonction dentiste(texte) qui renvoie un texte ne contenant que les voyelles de texte , dans l'ordre. Les voyelles sont donn\u00e9es par : \ud83d\udc0d Script Python VOYELLES = [ 'a' , 'e' , 'i' , 'o' , 'u' , 'y' ] On ne consid\u00e8rera que des textes \u00e9crits en minuscules, sans accents. Exemples \ud83d\udc0d Console Python >>> dentiste ( \"j'ai mal\" ) 'aia' >>> dentiste ( \"il fait chaud\" ) 'iaiau' >>> dentiste ( \"\" ) '' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newlinebackslash-newline# pas d'autres testsbackslash-newlinebackslash-newlineassert dentiste(\"a\"python-star20 + \"b\"python-star10 + \"e\") == 'a'python-star20 + 'e'backslash-newlineassert dentiste(\"b\"python-star10 + \"e\" + \"a\"python-star20) == 'e' + 'a'python-star20 backslash-newlineassert dentiste(\"ab\"python-star10) == 'a'python-star10backslash-newlineassert dentiste(\"aeiouy\"python-star10) == 'aeiouy'python-star10backslash-newlineassert dentiste(\"z\"python-star100 + 'y') == 'y'backslash-newlinebackslash-newline Valider 5/5 VOYELLES = ['a', 'e', 'i', 'o', 'u', 'y']backslash-newlinebackslash-newlinedef dentiste(texte):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newline VOYELLES = ['a', 'e', 'i', 'o', 'u', 'y']backslash-newlinebackslash-newlinedef dentiste(texte):backslash-newline resultat = ''backslash-newline for lettre in texte:backslash-newline if lettre in VOYELLES:backslash-newline resultat = resultat + lettrebackslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newline A Z","title":"Dentiste"},{"location":"1-facile/1200-dentiste/sujet/#elocution-chez-le-dentiste","text":"Chez le dentiste, la bouche grande ouverte, lorsqu'on essaie de parler, il ne reste que les voyelles. M\u00eame les ponctuations sont supprim\u00e9es. Vous devez \u00e9crire une fonction dentiste(texte) qui renvoie un texte ne contenant que les voyelles de texte , dans l'ordre. Les voyelles sont donn\u00e9es par : \ud83d\udc0d Script Python VOYELLES = [ 'a' , 'e' , 'i' , 'o' , 'u' , 'y' ] On ne consid\u00e8rera que des textes \u00e9crits en minuscules, sans accents. Exemples \ud83d\udc0d Console Python >>> dentiste ( \"j'ai mal\" ) 'aia' >>> dentiste ( \"il fait chaud\" ) 'iaiau' >>> dentiste ( \"\" ) '' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newlinebackslash-newline# pas d'autres testsbackslash-newlinebackslash-newlineassert dentiste(\"a\"python-star20 + \"b\"python-star10 + \"e\") == 'a'python-star20 + 'e'backslash-newlineassert dentiste(\"b\"python-star10 + \"e\" + \"a\"python-star20) == 'e' + 'a'python-star20 backslash-newlineassert dentiste(\"ab\"python-star10) == 'a'python-star10backslash-newlineassert dentiste(\"aeiouy\"python-star10) == 'aeiouy'python-star10backslash-newlineassert dentiste(\"z\"python-star100 + 'y') == 'y'backslash-newlinebackslash-newline Valider 5/5 VOYELLES = ['a', 'e', 'i', 'o', 'u', 'y']backslash-newlinebackslash-newlinedef dentiste(texte):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newline VOYELLES = ['a', 'e', 'i', 'o', 'u', 'y']backslash-newlinebackslash-newlinedef dentiste(texte):backslash-newline resultat = ''backslash-newline for lettre in texte:backslash-newline if lettre in VOYELLES:backslash-newline resultat = resultat + lettrebackslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert dentiste(\"j'ai mal\") == 'aia'backslash-newlineassert dentiste(\"il fait chaud\") == 'iaiau'backslash-newlineassert dentiste(\"\") == ''backslash-newlinebackslash-newline A Z","title":"\u00c9locution chez le dentiste"},{"location":"1-facile/1200-liste_differences/exo_REM/","text":"Commentaires \u2693\ufe0e Version simple \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ False ] * n for i in range ( n ): if source_1 [ i ] != source_2 [ i ]: resultat [ i ] = True return resultat Version simple (2) \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [] for i in range ( n ): resultat . append ( source_1 [ i ] != source_2 [ i ]) return resultat Avec liste en compr\u00e9hension \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ source_1 [ i ] != source_2 [ i ] for i in range ( n )] return resultat Version style fonctionnel \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): return [ a != b for a , b in zip ( source_1 , source_2 )]","title":"Commentaires"},{"location":"1-facile/1200-liste_differences/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1200-liste_differences/exo_REM/#version-simple","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ False ] * n for i in range ( n ): if source_1 [ i ] != source_2 [ i ]: resultat [ i ] = True return resultat","title":"Version simple"},{"location":"1-facile/1200-liste_differences/exo_REM/#version-simple-2","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [] for i in range ( n ): resultat . append ( source_1 [ i ] != source_2 [ i ]) return resultat","title":"Version simple (2)"},{"location":"1-facile/1200-liste_differences/exo_REM/#avec-liste-en-comprehension","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ source_1 [ i ] != source_2 [ i ] for i in range ( n )] return resultat","title":"Avec liste en compr\u00e9hension"},{"location":"1-facile/1200-liste_differences/exo_REM/#version-style-fonctionnel","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): return [ a != b for a , b in zip ( source_1 , source_2 )]","title":"Version style fonctionnel"},{"location":"1-facile/1200-liste_differences/sujet/","tags":["boucle"],"text":"Tester si deux listes contiennent des valeurs diff\u00e9rentes \u2693\ufe0e Un laboratoire re\u00e7oit des r\u00e9sultats depuis deux sources diff\u00e9rentes. Les r\u00e9sultats sont deux tableaux d'entiers source_1 et source_2 de m\u00eame longueur. Quand deux r\u00e9sultats concordent, on consid\u00e8re qu'il n'y aura pas \u00e0 refaire l'exp\u00e9rience, on le codera par False , mais si les r\u00e9sultats sont diff\u00e9rents, on consid\u00e8re qu'il faudra refaire cette exp\u00e9rience, on le codera par True . \u00c9crire une fonction telle que differences(source_1, source_2) renvoie un tableau de la longueur commune \u00e0 source_1 et source_2 rempli de bool\u00e9ens. Exemples \ud83d\udc0d Console Python >>> differences ([ 14 , 87 , 22 , 5 , 65 ], [ 14 , 86 , 27 , 5 , 65 ]) [False, True, True, False, False] >>> differences ([ - 54 ], [ - 54 ]) [False] >>> differences ([ 7 , 8 ], [ 7 , 11 ]) [False, True] >>> differences ([], []) [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(20))backslash-newlinesourcepython-underscore2 = list(range(20))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [False] python-star 20backslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(20))backslash-newlinesourcepython-underscore2 = list(range(1, 21))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [True] python-star 20backslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(21))backslash-newlinesourcepython-underscore2 = list(range(20, -1, -1))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [True] python-star 10 + [False] + [True] python-star 10backslash-newlinebackslash-newlinefor i in range(20):backslash-newline sourcepython-underscore1 = list(range(20))backslash-newline sourcepython-underscore2 = list(range(20))backslash-newline sourcepython-underscore2[i] = -1backslash-newline attendu = [False] python-star 20backslash-newline attendu[i] = Truebackslash-newline assert differences(sourcepython-underscore1, sourcepython-underscore2) == attendubackslash-newlinebackslash-newline Valider 5/5 def differences(sourcepython-underscore1, sourcepython-underscore2):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newlinebackslash-newline def differences(sourcepython-underscore1, sourcepython-underscore2):backslash-newline return [a != b for a, b in zip(sourcepython-underscore1, sourcepython-underscore2)]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version simple \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ False ] * n for i in range ( n ): if source_1 [ i ] != source_2 [ i ]: resultat [ i ] = True return resultat Version simple (2) \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [] for i in range ( n ): resultat . append ( source_1 [ i ] != source_2 [ i ]) return resultat Avec liste en compr\u00e9hension \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ source_1 [ i ] != source_2 [ i ] for i in range ( n )] return resultat Version style fonctionnel \u2693\ufe0e \ud83d\udc0d Script Python def differences ( source_1 , source_2 ): return [ a != b for a , b in zip ( source_1 , source_2 )] Z","title":"Liste des diff\u00e9rences"},{"location":"1-facile/1200-liste_differences/sujet/#tester-si-deux-listes-contiennent-des-valeurs-differentes","text":"Un laboratoire re\u00e7oit des r\u00e9sultats depuis deux sources diff\u00e9rentes. Les r\u00e9sultats sont deux tableaux d'entiers source_1 et source_2 de m\u00eame longueur. Quand deux r\u00e9sultats concordent, on consid\u00e8re qu'il n'y aura pas \u00e0 refaire l'exp\u00e9rience, on le codera par False , mais si les r\u00e9sultats sont diff\u00e9rents, on consid\u00e8re qu'il faudra refaire cette exp\u00e9rience, on le codera par True . \u00c9crire une fonction telle que differences(source_1, source_2) renvoie un tableau de la longueur commune \u00e0 source_1 et source_2 rempli de bool\u00e9ens. Exemples \ud83d\udc0d Console Python >>> differences ([ 14 , 87 , 22 , 5 , 65 ], [ 14 , 86 , 27 , 5 , 65 ]) [False, True, True, False, False] >>> differences ([ - 54 ], [ - 54 ]) [False] >>> differences ([ 7 , 8 ], [ 7 , 11 ]) [False, True] >>> differences ([], []) [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(20))backslash-newlinesourcepython-underscore2 = list(range(20))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [False] python-star 20backslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(20))backslash-newlinesourcepython-underscore2 = list(range(1, 21))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [True] python-star 20backslash-newlinebackslash-newlinesourcepython-underscore1 = list(range(21))backslash-newlinesourcepython-underscore2 = list(range(20, -1, -1))backslash-newlineassert differences(sourcepython-underscore1, sourcepython-underscore2) == [True] python-star 10 + [False] + [True] python-star 10backslash-newlinebackslash-newlinefor i in range(20):backslash-newline sourcepython-underscore1 = list(range(20))backslash-newline sourcepython-underscore2 = list(range(20))backslash-newline sourcepython-underscore2[i] = -1backslash-newline attendu = [False] python-star 20backslash-newline attendu[i] = Truebackslash-newline assert differences(sourcepython-underscore1, sourcepython-underscore2) == attendubackslash-newlinebackslash-newline Valider 5/5 def differences(sourcepython-underscore1, sourcepython-underscore2):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newlinebackslash-newline def differences(sourcepython-underscore1, sourcepython-underscore2):backslash-newline return [a != b for a, b in zip(sourcepython-underscore1, sourcepython-underscore2)]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert differences([14, 87, 22, 5, 65],backslash-newline [14, 86, 27, 5, 65]) == [False, True, True, False, False]backslash-newlinebackslash-newlineassert differences([-54], [-54]) == [False]backslash-newlineassert differences([7, 8], [7, 11]) == [False, True]backslash-newlineassert differences([], []) == []backslash-newlinebackslash-newlinebackslash-newline A","title":"Tester si deux listes contiennent des valeurs diff\u00e9rentes"},{"location":"1-facile/1200-liste_differences/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1200-liste_differences/sujet/#version-simple","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ False ] * n for i in range ( n ): if source_1 [ i ] != source_2 [ i ]: resultat [ i ] = True return resultat","title":"Version simple"},{"location":"1-facile/1200-liste_differences/sujet/#version-simple-2","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [] for i in range ( n ): resultat . append ( source_1 [ i ] != source_2 [ i ]) return resultat","title":"Version simple (2)"},{"location":"1-facile/1200-liste_differences/sujet/#avec-liste-en-comprehension","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): n = len ( source_1 ) resultat = [ source_1 [ i ] != source_2 [ i ] for i in range ( n )] return resultat","title":"Avec liste en compr\u00e9hension"},{"location":"1-facile/1200-liste_differences/sujet/#version-style-fonctionnel","text":"\ud83d\udc0d Script Python def differences ( source_1 , source_2 ): return [ a != b for a , b in zip ( source_1 , source_2 )] Z","title":"Version style fonctionnel"},{"location":"1-facile/1200-soleil_couchant/sujet/","tags":["boucle","adhoc"],"text":"Soleil couchant sur les b\u00e2timents \u2693\ufe0e Lorsque des b\u00e2timents sont align\u00e9s, ils se font de l'ombre les uns les autres. Dans cet exercice, nous sommes au soleil couchant, les rayons du soleil sont donc suppos\u00e9s horizontaux. Le sch\u00e9ma ci-dessus illustre un soleil couchant qui \u00e9claire 9 b\u00e2timents, les rayons du soleil sont repr\u00e9sent\u00e9s par des fl\u00e8ches horizontales. Les b\u00e2timents aux indices 0 et 3 re\u00e7oivent des rayons de soleil alors que les b\u00e2timents aux indices 1 et 2 sont masqu\u00e9s. Les 4 b\u00e2timents aux indices [0, 3, 6, 9] re\u00e7oivent des rayons de soleil sur au moins un \u00e9tage et sont donc \u00e9clair\u00e9s, alors que les autres ne le sont pas. Il n'y a pas de b\u00e2timent \u00e0 l'indice 4 . \u00c9crire une fonction nb_batiments_eclaires qui prend en argument la liste hauteurs des b\u00e2timents et qui renvoie le nombre de b\u00e2timents \u00e9clair\u00e9s. La hauteur des b\u00e2timents (en nombre d'\u00e9tages) est donn\u00e9e par une liste d'entiers positifs. Une hauteur de z\u00e9ro \u00e9tage signifie l'absence de b\u00e2timent \u00e0 l'endroit d\u00e9sign\u00e9. Pour l'exemple ci-dessus, cette liste est [2, 1, 2, 4, 0, 4, 5, 3, 5, 6] . Exemples \ud83d\udc0d Console Python >>> nb_batiments_eclaires ([ 2 , 1 , 2 , 4 , 0 , 4 , 5 , 3 , 5 , 6 ]) 4 >>> nb_batiments_eclaires ([ 0 , 3 , 1 , 2 ]) 1 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([])backslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([0])backslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([0]python-star10)backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([1])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([10, 5])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([5, 10])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 10, 5, 0])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([0, 5, 10, 0])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([1, 10, 5, 1])backslash-newlineassert 3 == nbpython-underscorebatimentspython-underscoreeclaires([1, 5, 10, 1])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([10]python-star5)backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 10, 10, 10, 0])backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorebatimentspython-underscoreeclaires(hauteurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline def nbpython-underscorebatimentspython-underscoreeclaires(hauteurs):backslash-newline resultat = 0backslash-newline plafond = 0backslash-newline for h in hauteurs:backslash-newline if h > plafond:backslash-newline plafond = hbackslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline A Z","title":"Soleil couchant"},{"location":"1-facile/1200-soleil_couchant/sujet/#soleil-couchant-sur-les-batiments","text":"Lorsque des b\u00e2timents sont align\u00e9s, ils se font de l'ombre les uns les autres. Dans cet exercice, nous sommes au soleil couchant, les rayons du soleil sont donc suppos\u00e9s horizontaux. Le sch\u00e9ma ci-dessus illustre un soleil couchant qui \u00e9claire 9 b\u00e2timents, les rayons du soleil sont repr\u00e9sent\u00e9s par des fl\u00e8ches horizontales. Les b\u00e2timents aux indices 0 et 3 re\u00e7oivent des rayons de soleil alors que les b\u00e2timents aux indices 1 et 2 sont masqu\u00e9s. Les 4 b\u00e2timents aux indices [0, 3, 6, 9] re\u00e7oivent des rayons de soleil sur au moins un \u00e9tage et sont donc \u00e9clair\u00e9s, alors que les autres ne le sont pas. Il n'y a pas de b\u00e2timent \u00e0 l'indice 4 . \u00c9crire une fonction nb_batiments_eclaires qui prend en argument la liste hauteurs des b\u00e2timents et qui renvoie le nombre de b\u00e2timents \u00e9clair\u00e9s. La hauteur des b\u00e2timents (en nombre d'\u00e9tages) est donn\u00e9e par une liste d'entiers positifs. Une hauteur de z\u00e9ro \u00e9tage signifie l'absence de b\u00e2timent \u00e0 l'endroit d\u00e9sign\u00e9. Pour l'exemple ci-dessus, cette liste est [2, 1, 2, 4, 0, 4, 5, 3, 5, 6] . Exemples \ud83d\udc0d Console Python >>> nb_batiments_eclaires ([ 2 , 1 , 2 , 4 , 0 , 4 , 5 , 3 , 5 , 6 ]) 4 >>> nb_batiments_eclaires ([ 0 , 3 , 1 , 2 ]) 1 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([])backslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([0])backslash-newlineassert 0 == nbpython-underscorebatimentspython-underscoreeclaires([0]python-star10)backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([1])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([10, 5])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([5, 10])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 10, 5, 0])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([0, 5, 10, 0])backslash-newlineassert 2 == nbpython-underscorebatimentspython-underscoreeclaires([1, 10, 5, 1])backslash-newlineassert 3 == nbpython-underscorebatimentspython-underscoreeclaires([1, 5, 10, 1])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([10]python-star5)backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 10, 10, 10, 0])backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorebatimentspython-underscoreeclaires(hauteurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline def nbpython-underscorebatimentspython-underscoreeclaires(hauteurs):backslash-newline resultat = 0backslash-newline plafond = 0backslash-newline for h in hauteurs:backslash-newline if h > plafond:backslash-newline plafond = hbackslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert 4 == nbpython-underscorebatimentspython-underscoreeclaires([2, 1, 2, 4, 0, 4, 5, 3, 5, 6])backslash-newlineassert 1 == nbpython-underscorebatimentspython-underscoreeclaires([0, 3, 1, 2])backslash-newlinebackslash-newline A Z","title":"Soleil couchant sur les b\u00e2timents"},{"location":"1-facile/1250-exclamations/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def nb_max_consecutifs ( motif , phrase ): nb_max = 0 nb_courant = 0 for caractere in phrase : if caractere == motif : nb_courant += 1 if nb_courant > nb_max : nb_max = nb_courant else : nb_courant = 0 return nb_max On initialise le nombre d'occurrences maximal ainsi que le courant, tous deux \u00e0 z\u00e9ro. On fait une boucle, sans avoir besoin de l'indice, si le caract\u00e8re correspond au motif, on incr\u00e9mente le compteur courant, et on met \u00e0 jour si n\u00e9cessaire le maximum provisoire, sinon on remet le compteur courant \u00e0 0","title":"Commentaires"},{"location":"1-facile/1250-exclamations/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def nb_max_consecutifs ( motif , phrase ): nb_max = 0 nb_courant = 0 for caractere in phrase : if caractere == motif : nb_courant += 1 if nb_courant > nb_max : nb_max = nb_courant else : nb_courant = 0 return nb_max On initialise le nombre d'occurrences maximal ainsi que le courant, tous deux \u00e0 z\u00e9ro. On fait une boucle, sans avoir besoin de l'indice, si le caract\u00e8re correspond au motif, on incr\u00e9mente le compteur courant, et on met \u00e0 jour si n\u00e9cessaire le maximum provisoire, sinon on remet le compteur courant \u00e0 0","title":"Commentaires"},{"location":"1-facile/1250-exclamations/sujet/","tags":["boucle","string"],"text":"Nombre d'exclamations cons\u00e9cutives !!! \u2693\ufe0e Dans une phrase !!! \u00e9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00e9rentes raisons ! Bref. \u00c9crire une fonction nb_max_consecutifs qui prend un caract\u00e8re motif (une chaine de caract\u00e8res de longueur 1), et une chaine de caract\u00e8res phrase \u00e0 analyser. La fonction renvoie le nombre maximal d'occurrences cons\u00e9cutives de motif dans phrase . Exemples \ud83d\udc0d Console Python >>> phrase = \"Dans une phrase !!! \u00e9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00e9rentes raisons ! Bref.\" >>> nb_max_consecutifs ( \"!\" , phrase ) 3 \ud83d\udc0d Console Python >>> phrase = \"Un mot puis un autre avec espaces.\" >>> nb_max_consecutifs ( \" \" , phrase ) 8 \ud83d\udc0d Console Python >>> expression = \"((2 * x + 3) / (x + 1))\" >>> nb_max_consecutifs ( \"(\" , expression ) 2 >>> nb_max_consecutifs ( \"-\" , expression ) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newlinebackslash-newline# autresbackslash-newlinebackslash-newlinebackslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"!!!! !!! !! !\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"! !! !!! !!!! !!! !! !\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"! !! !!! !!!!\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \"---\") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \" ---\") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \" --- \") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \"--- \") == 3backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscoremaxpython-underscoreconsecutifs(motif, phrase):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newline def nbpython-underscoremaxpython-underscoreconsecutifs(motif, phrase):backslash-newline nbpython-underscoremax = 0backslash-newline nbpython-underscorecourant = 0backslash-newline for caractere in phrase:backslash-newline if caractere == motif:backslash-newline nbpython-underscorecourant += 1backslash-newline if nbpython-underscorecourant > nbpython-underscoremax:backslash-newline nbpython-underscoremax = nbpython-underscorecourantbackslash-newline else:backslash-newline nbpython-underscorecourant = 0backslash-newline return nbpython-underscoremaxbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} On initialise le nombre d'occurrences maximal ainsi que le courant, tous deux \u00e0 z\u00e9ro. On fait une boucle, sans avoir besoin de l'indice, si le caract\u00e8re correspond au motif, on incr\u00e9mente le compteur courant, et on met \u00e0 jour si n\u00e9cessaire le maximum provisoire, sinon on remet le compteur courant \u00e0 0 Z","title":"Exclamations"},{"location":"1-facile/1250-exclamations/sujet/#nombre-dexclamations-consecutives","text":"Dans une phrase !!! \u00e9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00e9rentes raisons ! Bref. \u00c9crire une fonction nb_max_consecutifs qui prend un caract\u00e8re motif (une chaine de caract\u00e8res de longueur 1), et une chaine de caract\u00e8res phrase \u00e0 analyser. La fonction renvoie le nombre maximal d'occurrences cons\u00e9cutives de motif dans phrase . Exemples \ud83d\udc0d Console Python >>> phrase = \"Dans une phrase !!! \u00e9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00e9rentes raisons ! Bref.\" >>> nb_max_consecutifs ( \"!\" , phrase ) 3 \ud83d\udc0d Console Python >>> phrase = \"Un mot puis un autre avec espaces.\" >>> nb_max_consecutifs ( \" \" , phrase ) 8 \ud83d\udc0d Console Python >>> expression = \"((2 * x + 3) / (x + 1))\" >>> nb_max_consecutifs ( \"(\" , expression ) 2 >>> nb_max_consecutifs ( \"-\" , expression ) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newlinebackslash-newline# autresbackslash-newlinebackslash-newlinebackslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"!!!! !!! !! !\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"! !! !!! !!!! !!! !! !\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", \"! !! !!! !!!!\") == 4backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \"---\") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \" ---\") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \" --- \") == 3backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", \"--- \") == 3backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscoremaxpython-underscoreconsecutifs(motif, phrase):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newline def nbpython-underscoremaxpython-underscoreconsecutifs(motif, phrase):backslash-newline nbpython-underscoremax = 0backslash-newline nbpython-underscorecourant = 0backslash-newline for caractere in phrase:backslash-newline if caractere == motif:backslash-newline nbpython-underscorecourant += 1backslash-newline if nbpython-underscorecourant > nbpython-underscoremax:backslash-newline nbpython-underscoremax = nbpython-underscorecourantbackslash-newline else:backslash-newline nbpython-underscorecourant = 0backslash-newline return nbpython-underscoremaxbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinephrase = \"Dans une phrase !!! \u00c3\u00a9crite !!! certains utilisateurs abusent des points d'exclamations !! Ce pour diff\u00c3\u00a9rentes raisons ! Bref.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"!\", phrase) == 3backslash-newlinebackslash-newlinephrase = \"Un mot puis un autre avec espaces.\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\" \", phrase) == 8backslash-newlinebackslash-newlineexpression = \"((2 python-star x + 3) / (x + 1))\"backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"(\", expression) == 2backslash-newlineassert nbpython-underscoremaxpython-underscoreconsecutifs(\"-\", expression) == 0backslash-newlinebackslash-newline A","title":"Nombre d'exclamations cons\u00e9cutives !!!"},{"location":"1-facile/1250-exclamations/sujet/#commentaires","text":"{{ py('exo_corr') }} On initialise le nombre d'occurrences maximal ainsi que le courant, tous deux \u00e0 z\u00e9ro. On fait une boucle, sans avoir besoin de l'indice, si le caract\u00e8re correspond au motif, on incr\u00e9mente le compteur courant, et on met \u00e0 jour si n\u00e9cessaire le maximum provisoire, sinon on remet le compteur courant \u00e0 0 Z","title":"Commentaires"},{"location":"1-facile/1250-gelee/exo_REM/","text":"Commentaires \u2693\ufe0e Sorti de son contexte, l'exercice revient \u00e0 d\u00e9terminer la longueur de la plus longue sous-s\u00e9quence d'\u00e9l\u00e9ments v\u00e9rifiant une certaine condition dans une liste. En l'occurrence, la longueur de la plus longue sous-s\u00e9quence de nombres n\u00e9gatifs. Une solution possible \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def gelees(temperatures):backslash-newline pluspython-underscorelonguepython-underscoreperiode = 0backslash-newline periode = 0backslash-newline for temp in temperatures:backslash-newline if temp <= 0:backslash-newline periode += 1backslash-newline if periode > pluspython-underscorelonguepython-underscoreperiode:backslash-newline pluspython-underscorelonguepython-underscoreperiode = periodebackslash-newline else:backslash-newline periode = 0backslash-newline return pluspython-underscorelonguepython-underscoreperiodebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline A Z Comme on cherche la plus longue longueur, on commence par l'initialiser \u00e0 0 (ligne 2). On cr\u00e9e ensuite la variable periode qui stockera la longueur de la sous-s\u00e9quence de nombres n\u00e9gatifs actuellement lue. Avant la lecture, elle est naturellement \u00e0 0 (ligne 3). On parcourt ensuite les valeurs de la liste temperatures et pour chacune d'elle : si elle est n\u00e9gative : on incr\u00e9mente la valeur de la sous-s\u00e9quence actuelle on teste si cette sous-s\u00e9quence est plus longue que la plus longue d\u00e9j\u00e0 trouv\u00e9e. Si c'est le cas, on met \u00e0 jour la valeur (ligne 8) sinon (la temp\u00e9rature est strictement positive), on remet la longueur de la s\u00e9quence actuelle \u00e0 0 (ligne 10) La fonction renvoie pour terminer la longueur de la plus longue p\u00e9riode.","title":"Commentaires"},{"location":"1-facile/1250-gelee/exo_REM/#commentaires","text":"Sorti de son contexte, l'exercice revient \u00e0 d\u00e9terminer la longueur de la plus longue sous-s\u00e9quence d'\u00e9l\u00e9ments v\u00e9rifiant une certaine condition dans une liste. En l'occurrence, la longueur de la plus longue sous-s\u00e9quence de nombres n\u00e9gatifs.","title":"Commentaires"},{"location":"1-facile/1250-gelee/exo_REM/#une-solution-possible","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def gelees(temperatures):backslash-newline pluspython-underscorelonguepython-underscoreperiode = 0backslash-newline periode = 0backslash-newline for temp in temperatures:backslash-newline if temp <= 0:backslash-newline periode += 1backslash-newline if periode > pluspython-underscorelonguepython-underscoreperiode:backslash-newline pluspython-underscorelonguepython-underscoreperiode = periodebackslash-newline else:backslash-newline periode = 0backslash-newline return pluspython-underscorelonguepython-underscoreperiodebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline A Z Comme on cherche la plus longue longueur, on commence par l'initialiser \u00e0 0 (ligne 2). On cr\u00e9e ensuite la variable periode qui stockera la longueur de la sous-s\u00e9quence de nombres n\u00e9gatifs actuellement lue. Avant la lecture, elle est naturellement \u00e0 0 (ligne 3). On parcourt ensuite les valeurs de la liste temperatures et pour chacune d'elle : si elle est n\u00e9gative : on incr\u00e9mente la valeur de la sous-s\u00e9quence actuelle on teste si cette sous-s\u00e9quence est plus longue que la plus longue d\u00e9j\u00e0 trouv\u00e9e. Si c'est le cas, on met \u00e0 jour la valeur (ligne 8) sinon (la temp\u00e9rature est strictement positive), on remet la longueur de la s\u00e9quence actuelle \u00e0 0 (ligne 10) La fonction renvoie pour terminer la longueur de la plus longue p\u00e9riode.","title":"Une solution possible"},{"location":"1-facile/1250-gelee/sujet/","tags":["boucle"],"text":"Plus longue p\u00e9riode de gel\u00e9es \u2693\ufe0e Un m\u00e9t\u00e9orologue a relev\u00e9 les temp\u00e9ratures au lever du jour dans sa rue. Il souhaite d\u00e9terminer la dur\u00e9e de la plus longue p\u00e9riode de gel\u00e9es cons\u00e9cutives durant ces relev\u00e9s. Vous devez \u00e9crire une fonction gelees(temperatures) qui renvoie la longueur de la plus longue s\u00e9quence de nombres n\u00e9gatifs ou nuls cons\u00e9cutifs dans la liste. Les temp\u00e9ratures sont donn\u00e9es sous forme d'une liste de nombres : \ud83d\udc0d Script Python temperatures = [ 2 , - 3 , - 2 , 0 , 1 , - 1 ] Si la liste est vide, la fonction renverra la valeur 0 . On rappelle que l'eau g\u00e8le \u00e0 partir de 0\u00b0C inclus. Exemples \ud83d\udc0d Console Python >>> gelees ([ 2 , - 3 , - 2 , 0 , 1 , - 1 ]) 3 >>> gelees ([ 3 , 2 , 2 ]) 0 >>> gelees ([]) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert gelees([-2, -3, -2, 0, -1, -1]) == 6backslash-newlineassert gelees([0, 0, 0]) == 3backslash-newlineassert gelees([1]python-star1000+[-1]+[1]python-star1000) == 1backslash-newlinebackslash-newline Valider 5/5 def gelees(temperatures):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newline def gelees(temperatures):backslash-newline pluspython-underscorelonguepython-underscoreperiode = 0backslash-newline periode = 0backslash-newline for temp in temperatures:backslash-newline if temp <= 0:backslash-newline periode += 1backslash-newline if periode > pluspython-underscorelonguepython-underscoreperiode:backslash-newline pluspython-underscorelonguepython-underscoreperiode = periodebackslash-newline else:backslash-newline periode = 0backslash-newline return pluspython-underscorelonguepython-underscoreperiodebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Sorti de son contexte, l'exercice revient \u00e0 d\u00e9terminer la longueur de la plus longue sous-s\u00e9quence d'\u00e9l\u00e9ments v\u00e9rifiant une certaine condition dans une liste. En l'occurrence, la longueur de la plus longue sous-s\u00e9quence de nombres n\u00e9gatifs. Une solution possible \u2693\ufe0e {{ IDE('exo_corr') }} Comme on cherche la plus longue longueur, on commence par l'initialiser \u00e0 0 (ligne 2). On cr\u00e9e ensuite la variable periode qui stockera la longueur de la sous-s\u00e9quence de nombres n\u00e9gatifs actuellement lue. Avant la lecture, elle est naturellement \u00e0 0 (ligne 3). On parcourt ensuite les valeurs de la liste temperatures et pour chacune d'elle : si elle est n\u00e9gative : on incr\u00e9mente la valeur de la sous-s\u00e9quence actuelle on teste si cette sous-s\u00e9quence est plus longue que la plus longue d\u00e9j\u00e0 trouv\u00e9e. Si c'est le cas, on met \u00e0 jour la valeur (ligne 8) sinon (la temp\u00e9rature est strictement positive), on remet la longueur de la s\u00e9quence actuelle \u00e0 0 (ligne 10) La fonction renvoie pour terminer la longueur de la plus longue p\u00e9riode. Z","title":"Gel\u00e9es"},{"location":"1-facile/1250-gelee/sujet/#plus-longue-periode-de-gelees","text":"Un m\u00e9t\u00e9orologue a relev\u00e9 les temp\u00e9ratures au lever du jour dans sa rue. Il souhaite d\u00e9terminer la dur\u00e9e de la plus longue p\u00e9riode de gel\u00e9es cons\u00e9cutives durant ces relev\u00e9s. Vous devez \u00e9crire une fonction gelees(temperatures) qui renvoie la longueur de la plus longue s\u00e9quence de nombres n\u00e9gatifs ou nuls cons\u00e9cutifs dans la liste. Les temp\u00e9ratures sont donn\u00e9es sous forme d'une liste de nombres : \ud83d\udc0d Script Python temperatures = [ 2 , - 3 , - 2 , 0 , 1 , - 1 ] Si la liste est vide, la fonction renverra la valeur 0 . On rappelle que l'eau g\u00e8le \u00e0 partir de 0\u00b0C inclus. Exemples \ud83d\udc0d Console Python >>> gelees ([ 2 , - 3 , - 2 , 0 , 1 , - 1 ]) 3 >>> gelees ([ 3 , 2 , 2 ]) 0 >>> gelees ([]) 0 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert gelees([-2, -3, -2, 0, -1, -1]) == 6backslash-newlineassert gelees([0, 0, 0]) == 3backslash-newlineassert gelees([1]python-star1000+[-1]+[1]python-star1000) == 1backslash-newlinebackslash-newline Valider 5/5 def gelees(temperatures):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newline def gelees(temperatures):backslash-newline pluspython-underscorelonguepython-underscoreperiode = 0backslash-newline periode = 0backslash-newline for temp in temperatures:backslash-newline if temp <= 0:backslash-newline periode += 1backslash-newline if periode > pluspython-underscorelonguepython-underscoreperiode:backslash-newline pluspython-underscorelonguepython-underscoreperiode = periodebackslash-newline else:backslash-newline periode = 0backslash-newline return pluspython-underscorelonguepython-underscoreperiodebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert gelees([2, -3, -2, 0, 1, -1]) == 3backslash-newlineassert gelees([3, 2, 2]) == 0backslash-newlineassert gelees([]) == 0backslash-newlinebackslash-newline A","title":"Plus longue p\u00e9riode de gel\u00e9es"},{"location":"1-facile/1250-gelee/sujet/#commentaires","text":"Sorti de son contexte, l'exercice revient \u00e0 d\u00e9terminer la longueur de la plus longue sous-s\u00e9quence d'\u00e9l\u00e9ments v\u00e9rifiant une certaine condition dans une liste. En l'occurrence, la longueur de la plus longue sous-s\u00e9quence de nombres n\u00e9gatifs.","title":"Commentaires"},{"location":"1-facile/1250-gelee/sujet/#une-solution-possible","text":"{{ IDE('exo_corr') }} Comme on cherche la plus longue longueur, on commence par l'initialiser \u00e0 0 (ligne 2). On cr\u00e9e ensuite la variable periode qui stockera la longueur de la sous-s\u00e9quence de nombres n\u00e9gatifs actuellement lue. Avant la lecture, elle est naturellement \u00e0 0 (ligne 3). On parcourt ensuite les valeurs de la liste temperatures et pour chacune d'elle : si elle est n\u00e9gative : on incr\u00e9mente la valeur de la sous-s\u00e9quence actuelle on teste si cette sous-s\u00e9quence est plus longue que la plus longue d\u00e9j\u00e0 trouv\u00e9e. Si c'est le cas, on met \u00e0 jour la valeur (ligne 8) sinon (la temp\u00e9rature est strictement positive), on remet la longueur de la s\u00e9quence actuelle \u00e0 0 (ligne 10) La fonction renvoie pour terminer la longueur de la plus longue p\u00e9riode. Z","title":"Une solution possible"},{"location":"1-facile/1250-multiplication/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def multiplication ( a , b ): if b < 0 : b = - b a = - a somme = 0 for i in range ( b ): somme += a return somme Pour effectuer le produit \\(a\\times b\\) on distingue deux cas de figures : \\(b \\ge 0\\) : dans ce cas, on se contente d'additionner \\(b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) \\(b \\lt 0\\) : dans ce cas, \\(-b\\) est positif. On soustrait \\(-b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) Ainsi : \\(2\\times 3\\) = 0+2+2+2=6$ \\(-2\\times 3\\) = 0+(-2)+(-2)+(-2)=-6$ \\(2\\times -3\\) = 0-2-2-2=-6$ \\(-2\\times -3\\) = 0-(-2)-(-2)-(-2)=6$","title":"Commentaires"},{"location":"1-facile/1250-multiplication/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def multiplication ( a , b ): if b < 0 : b = - b a = - a somme = 0 for i in range ( b ): somme += a return somme Pour effectuer le produit \\(a\\times b\\) on distingue deux cas de figures : \\(b \\ge 0\\) : dans ce cas, on se contente d'additionner \\(b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) \\(b \\lt 0\\) : dans ce cas, \\(-b\\) est positif. On soustrait \\(-b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) Ainsi : \\(2\\times 3\\) = 0+2+2+2=6$ \\(-2\\times 3\\) = 0+(-2)+(-2)+(-2)=-6$ \\(2\\times -3\\) = 0-2-2-2=-6$ \\(-2\\times -3\\) = 0-(-2)-(-2)-(-2)=6$","title":"Commentaires"},{"location":"1-facile/1250-multiplication/sujet/","tags":["boucle"],"text":"Multiplication sans * \u2693\ufe0e Programmer la fonction multiplication : prenant en param\u00e8tres deux nombres entiers a et b , renvoyant le produit de ces deux nombres. Exemples \ud83d\udc0d Console Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) -12 >>> multiplication ( 3 , - 4 ) -12 >>> multiplication ( - 2 , 0 ) 0 Contrainte Les seules op\u00e9rations autoris\u00e9es sont l'addition et la soustraction ! Indications On rappelle que si \\(n\\) est un nombre n\u00e9gatif, \\(-n\\) est un nombre positif. On a \\(5 \\times (-3) = -5\\times 3=0 +(- 5)+(- 5)+(- 5)\\) ! Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser from itertools import productbackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinefrom itertools import productbackslash-newlinebackslash-newlinepremiers = [a for a in range(-10, 11)]backslash-newlineseconds = [a for a in range(-10, 11)]backslash-newlinefor a, b in product(premiers, seconds):backslash-newline assert multiplication(a, b) == apython-starb, f\"Erreur sur le produit {a}python-star{b}\"backslash-newlinebackslash-newline Valider 5/5 def multiplication(a, b):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline def multiplication(a, b):backslash-newline if b < 0:backslash-newline b = -bbackslash-newline a = -abackslash-newlinebackslash-newline somme = 0backslash-newline for i in range(b):backslash-newline somme += abackslash-newlinebackslash-newline return sommebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr', 0, \"# TESTS\") }} Pour effectuer le produit \\(a\\times b\\) on distingue deux cas de figures : \\(b \\ge 0\\) : dans ce cas, on se contente d'additionner \\(b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) \\(b \\lt 0\\) : dans ce cas, \\(-b\\) est positif. On soustrait \\(-b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) Ainsi : \\(2\\times 3\\) = 0+2+2+2=6$ \\(-2\\times 3\\) = 0+(-2)+(-2)+(-2)=-6$ \\(2\\times -3\\) = 0-2-2-2=-6$ \\(-2\\times -3\\) = 0-(-2)-(-2)-(-2)=6$ Z","title":"Multiplier sans *"},{"location":"1-facile/1250-multiplication/sujet/#multiplication-sans","text":"Programmer la fonction multiplication : prenant en param\u00e8tres deux nombres entiers a et b , renvoyant le produit de ces deux nombres. Exemples \ud83d\udc0d Console Python >>> multiplication ( 3 , 5 ) 15 >>> multiplication ( - 4 , - 8 ) 32 >>> multiplication ( - 2 , 6 ) -12 >>> multiplication ( 3 , - 4 ) -12 >>> multiplication ( - 2 , 0 ) 0 Contrainte Les seules op\u00e9rations autoris\u00e9es sont l'addition et la soustraction ! Indications On rappelle que si \\(n\\) est un nombre n\u00e9gatif, \\(-n\\) est un nombre positif. On a \\(5 \\times (-3) = -5\\times 3=0 +(- 5)+(- 5)+(- 5)\\) ! Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser from itertools import productbackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinefrom itertools import productbackslash-newlinebackslash-newlinepremiers = [a for a in range(-10, 11)]backslash-newlineseconds = [a for a in range(-10, 11)]backslash-newlinefor a, b in product(premiers, seconds):backslash-newline assert multiplication(a, b) == apython-starb, f\"Erreur sur le produit {a}python-star{b}\"backslash-newlinebackslash-newline Valider 5/5 def multiplication(a, b):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline def multiplication(a, b):backslash-newline if b < 0:backslash-newline b = -bbackslash-newline a = -abackslash-newlinebackslash-newline somme = 0backslash-newline for i in range(b):backslash-newline somme += abackslash-newlinebackslash-newline return sommebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert multiplication(3, 5) == 15backslash-newlineassert multiplication(-4, -8) == 32backslash-newlineassert multiplication(-2, 6) == -12backslash-newlineassert multiplication(3, -4) == -12backslash-newlineassert multiplication(-2, 0) == 0backslash-newlinebackslash-newline A","title":"Multiplication sans *"},{"location":"1-facile/1250-multiplication/sujet/#commentaires","text":"{{ py('exo_corr', 0, \"# TESTS\") }} Pour effectuer le produit \\(a\\times b\\) on distingue deux cas de figures : \\(b \\ge 0\\) : dans ce cas, on se contente d'additionner \\(b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) \\(b \\lt 0\\) : dans ce cas, \\(-b\\) est positif. On soustrait \\(-b\\) fois le nombre \\(a\\) \u00e0 \\(0\\) Ainsi : \\(2\\times 3\\) = 0+2+2+2=6$ \\(-2\\times 3\\) = 0+(-2)+(-2)+(-2)=-6$ \\(2\\times -3\\) = 0-2-2-2=-6$ \\(-2\\times -3\\) = 0-(-2)-(-2)-(-2)=6$ Z","title":"Commentaires"},{"location":"1-facile/1250-recherche_indices/exo_REM/","text":"Commentaires \u2693\ufe0e Version recommand\u00e9e \u2693\ufe0e \ud83d\udc0d Script Python def recherche_positions ( element , tableau ): return [ i for i in range ( len ( tableau )) if tableau [ i ] == element ] Version sans compr\u00e9hension de liste \u2693\ufe0e \ud83d\udc0d Script Python def recherche_positions ( element , tableau ): positions = [] for i in range ( len ( tableau )): if tableau [ i ] == element : positions . append ( i ) return positions","title":"Commentaires"},{"location":"1-facile/1250-recherche_indices/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1250-recherche_indices/exo_REM/#version-recommandee","text":"\ud83d\udc0d Script Python def recherche_positions ( element , tableau ): return [ i for i in range ( len ( tableau )) if tableau [ i ] == element ]","title":"Version recommand\u00e9e"},{"location":"1-facile/1250-recherche_indices/exo_REM/#version-sans-comprehension-de-liste","text":"\ud83d\udc0d Script Python def recherche_positions ( element , tableau ): positions = [] for i in range ( len ( tableau )): if tableau [ i ] == element : positions . append ( i ) return positions","title":"Version sans compr\u00e9hension de liste"},{"location":"1-facile/1250-recherche_indices/sujet/","tags":["boucle"],"text":"Recherche des positions d'un \u00e9l\u00e9ment dans un tableau \u2693\ufe0e \u00c9crire une fonction recherche_positions qui prend en param\u00e8tres element un nombre et tableau un tableau de nombres, et qui renvoie la liste croissante des indices de element dans tableau et la liste vide [] si element n'appara\u00eet pas dans tableau . On n'utilisera ni la m\u00e9thode index . Exemples \ud83d\udc0d Console Python >>> recherche_positions ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [0, 3] >>> recherche_positions ( 4 , [ 1 , 2 , 3 ]) [] >>> recherche_positions ( 10 , [ 2 , 10 , 3 , 10 , 4 , 10 , 5 ]) [1, 3, 5] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(3, [3, 2, 1, 3, 2, 1]) == [0, 3]backslash-newlineassert recherchepython-underscorepositions(4, [1, 2, 3]) == []backslash-newlineassert recherchepython-underscorepositions(10, [2, 10, 3, 10, 4, 10, 5]) == [1, 3, 5]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(1, [1, 1, 1, 1]) == [0, 1, 2, 3]backslash-newlineassert recherchepython-underscorepositions(5, [0, 0, 5]) == [2]backslash-newlineassert recherchepython-underscorepositions(-1, [-1, 0, -1, 0, -1, 0, -1]) == [0, 2, 4, 6]backslash-newlinebackslash-newline Valider 5/5 def recherchepython-underscorepositions(element, tableau):backslash-newline return [i for i in range(len(tableau)) if tableau[i] == element]backslash-newlinebackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(3, [3, 2, 1, 3, 2, 1]) == [0, 3]backslash-newlineassert recherchepython-underscorepositions(4, [1, 2, 3]) == []backslash-newlineassert recherchepython-underscorepositions(1, [1, 1, 1, 1]) == [0, 1, 2, 3]backslash-newlineassert recherchepython-underscorepositions(5, [0, 0, 5]) == [2]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version recommand\u00e9e \u2693\ufe0e {{ py('exo_corr') }} Version sans compr\u00e9hension de liste \u2693\ufe0e \ud83d\udc0d Script Python def recherche_positions ( element , tableau ): positions = [] for i in range ( len ( tableau )): if tableau [ i ] == element : positions . append ( i ) return positions Z","title":"Recherche d'indices"},{"location":"1-facile/1250-recherche_indices/sujet/#recherche-des-positions-dun-element-dans-un-tableau","text":"\u00c9crire une fonction recherche_positions qui prend en param\u00e8tres element un nombre et tableau un tableau de nombres, et qui renvoie la liste croissante des indices de element dans tableau et la liste vide [] si element n'appara\u00eet pas dans tableau . On n'utilisera ni la m\u00e9thode index . Exemples \ud83d\udc0d Console Python >>> recherche_positions ( 3 , [ 3 , 2 , 1 , 3 , 2 , 1 ]) [0, 3] >>> recherche_positions ( 4 , [ 1 , 2 , 3 ]) [] >>> recherche_positions ( 10 , [ 2 , 10 , 3 , 10 , 4 , 10 , 5 ]) [1, 3, 5] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(3, [3, 2, 1, 3, 2, 1]) == [0, 3]backslash-newlineassert recherchepython-underscorepositions(4, [1, 2, 3]) == []backslash-newlineassert recherchepython-underscorepositions(10, [2, 10, 3, 10, 4, 10, 5]) == [1, 3, 5]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(1, [1, 1, 1, 1]) == [0, 1, 2, 3]backslash-newlineassert recherchepython-underscorepositions(5, [0, 0, 5]) == [2]backslash-newlineassert recherchepython-underscorepositions(-1, [-1, 0, -1, 0, -1, 0, -1]) == [0, 2, 4, 6]backslash-newlinebackslash-newline Valider 5/5 def recherchepython-underscorepositions(element, tableau):backslash-newline return [i for i in range(len(tableau)) if tableau[i] == element]backslash-newlinebackslash-newlinebackslash-newlineassert recherchepython-underscorepositions(3, [3, 2, 1, 3, 2, 1]) == [0, 3]backslash-newlineassert recherchepython-underscorepositions(4, [1, 2, 3]) == []backslash-newlineassert recherchepython-underscorepositions(1, [1, 1, 1, 1]) == [0, 1, 2, 3]backslash-newlineassert recherchepython-underscorepositions(5, [0, 0, 5]) == [2]backslash-newlinebackslash-newline A","title":"Recherche des positions d'un \u00e9l\u00e9ment dans un tableau"},{"location":"1-facile/1250-recherche_indices/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1250-recherche_indices/sujet/#version-recommandee","text":"{{ py('exo_corr') }}","title":"Version recommand\u00e9e"},{"location":"1-facile/1250-recherche_indices/sujet/#version-sans-comprehension-de-liste","text":"\ud83d\udc0d Script Python def recherche_positions ( element , tableau ): positions = [] for i in range ( len ( tableau )): if tableau [ i ] == element : positions . append ( i ) return positions Z","title":"Version sans compr\u00e9hension de liste"},{"location":"1-facile/1250-remplacer/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): resultat = [] for val in valeurs : if val == valeur_cible : resultat . append ( nouvelle_valeur ) else : resultat . append ( val ) return resultat Il n'y a pas de difficult\u00e9s majeures si ce n'est prendre soin de ne pas modifier la liste initiale. On cr\u00e9e donc une seconde liste que l'on compl\u00e8te au fur et \u00e0 mesure en parcourant les valeurs de valeurs . On aurait aussi pu utiliser une liste par compr\u00e9hension et un op\u00e9rateur ternaire : \ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): return [ val if val != valeur_cible else nouvelle_valeur for val in valeurs ]","title":"Commentaires"},{"location":"1-facile/1250-remplacer/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): resultat = [] for val in valeurs : if val == valeur_cible : resultat . append ( nouvelle_valeur ) else : resultat . append ( val ) return resultat Il n'y a pas de difficult\u00e9s majeures si ce n'est prendre soin de ne pas modifier la liste initiale. On cr\u00e9e donc une seconde liste que l'on compl\u00e8te au fur et \u00e0 mesure en parcourant les valeurs de valeurs . On aurait aussi pu utiliser une liste par compr\u00e9hension et un op\u00e9rateur ternaire : \ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): return [ val if val != valeur_cible else nouvelle_valeur for val in valeurs ]","title":"Commentaires"},{"location":"1-facile/1250-remplacer/sujet/","tags":["boucle"],"text":"Remplacer une valeur \u2693\ufe0e \u00c9crire la fonction remplacer prenant en argument : une liste d'entiers valeurs un entier valeur_cible un entier nouvelle_valeur et renvoyant une nouvelle liste contenant les m\u00eames valeurs que valeurs , dans le m\u00eame ordre, sauf valeur_cible qui a \u00e9t\u00e9 remplac\u00e9 par nouvelle_valeur . La liste pass\u00e9e en param\u00e8tre ne doit pas \u00eatre modifi\u00e9e . Exemples \ud83d\udc0d Console Python >>> valeurs = [ 3 , 8 , 7 ] >>> remplacer ( valeurs , 3 , 0 ) [0, 8, 7] >>> valeurs [3, 8, 7] \ud83d\udc0d Console Python >>> valeurs = [ 3 , 8 , 3 , 5 ] >>> remplacer ( valeurs , 3 , 0 ) [0, 8, 0, 5] >>> liste [3, 8, 3, 5] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [3, 8, 7], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [3, 8, 3, 5], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newline# Valeurs identiques \u00c3 l'entr\u00c3\u00a9ebackslash-newlinevaleurs = [5] python-star 8backslash-newlineassert remplacer(valeurs, 5, 10) == [10] python-star 8backslash-newlineassert valeurs == [5] python-star 8, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# Valeurs identiques \u00c3 la sortiebackslash-newlinevaleurs = [5] python-star 8 + [10] python-star 2backslash-newlineassert remplacer(valeurs, 10, 5) == [5] python-star 10backslash-newlineassert valeurs == [5] python-star 8 + [10] python-star 2, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# Cible non pr\u00c3\u00a9sentebackslash-newlinevaleurs = [5] python-star 8backslash-newlineassert remplacer(valeurs, 10, 1) == [5] python-star 8backslash-newlineassert valeurs == [5] python-star 8, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# liste videbackslash-newlinevaleurs = []backslash-newlineassert remplacer(valeurs, 10, 1) == []backslash-newlineassert valeurs == [], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newline Valider 5/5 def remplacer(valeurs, valeurpython-underscorecible, nouvellepython-underscorevaleur):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer([3, 8, 7], 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [3, 8, 7]backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer([3, 8, 3, 5], 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [3, 8, 3, 5]backslash-newlinebackslash-newline def remplacer(valeurs, valeurpython-underscorecible, nouvellepython-underscorevaleur):backslash-newline resultat = []backslash-newline for val in valeurs:backslash-newline if val == valeurpython-underscorecible:backslash-newline resultat.append(nouvellepython-underscorevaleur)backslash-newline else:backslash-newline resultat.append(val)backslash-newlinebackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [backslash-newline 3, 8, 7], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [backslash-newline 3, 8, 3, 5], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr', 0, \"# TESTS\") }} Il n'y a pas de difficult\u00e9s majeures si ce n'est prendre soin de ne pas modifier la liste initiale. On cr\u00e9e donc une seconde liste que l'on compl\u00e8te au fur et \u00e0 mesure en parcourant les valeurs de valeurs . On aurait aussi pu utiliser une liste par compr\u00e9hension et un op\u00e9rateur ternaire : \ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): return [ val if val != valeur_cible else nouvelle_valeur for val in valeurs ] Z","title":"Remplacer une valeur"},{"location":"1-facile/1250-remplacer/sujet/#remplacer-une-valeur","text":"\u00c9crire la fonction remplacer prenant en argument : une liste d'entiers valeurs un entier valeur_cible un entier nouvelle_valeur et renvoyant une nouvelle liste contenant les m\u00eames valeurs que valeurs , dans le m\u00eame ordre, sauf valeur_cible qui a \u00e9t\u00e9 remplac\u00e9 par nouvelle_valeur . La liste pass\u00e9e en param\u00e8tre ne doit pas \u00eatre modifi\u00e9e . Exemples \ud83d\udc0d Console Python >>> valeurs = [ 3 , 8 , 7 ] >>> remplacer ( valeurs , 3 , 0 ) [0, 8, 7] >>> valeurs [3, 8, 7] \ud83d\udc0d Console Python >>> valeurs = [ 3 , 8 , 3 , 5 ] >>> remplacer ( valeurs , 3 , 0 ) [0, 8, 0, 5] >>> liste [3, 8, 3, 5] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [3, 8, 7], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [3, 8, 3, 5], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newline# Valeurs identiques \u00c3 l'entr\u00c3\u00a9ebackslash-newlinevaleurs = [5] python-star 8backslash-newlineassert remplacer(valeurs, 5, 10) == [10] python-star 8backslash-newlineassert valeurs == [5] python-star 8, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# Valeurs identiques \u00c3 la sortiebackslash-newlinevaleurs = [5] python-star 8 + [10] python-star 2backslash-newlineassert remplacer(valeurs, 10, 5) == [5] python-star 10backslash-newlineassert valeurs == [5] python-star 8 + [10] python-star 2, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# Cible non pr\u00c3\u00a9sentebackslash-newlinevaleurs = [5] python-star 8backslash-newlineassert remplacer(valeurs, 10, 1) == [5] python-star 8backslash-newlineassert valeurs == [5] python-star 8, \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# liste videbackslash-newlinevaleurs = []backslash-newlineassert remplacer(valeurs, 10, 1) == []backslash-newlineassert valeurs == [], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newline Valider 5/5 def remplacer(valeurs, valeurpython-underscorecible, nouvellepython-underscorevaleur):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer([3, 8, 7], 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [3, 8, 7]backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer([3, 8, 3, 5], 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [3, 8, 3, 5]backslash-newlinebackslash-newline def remplacer(valeurs, valeurpython-underscorecible, nouvellepython-underscorevaleur):backslash-newline resultat = []backslash-newline for val in valeurs:backslash-newline if val == valeurpython-underscorecible:backslash-newline resultat.append(nouvellepython-underscorevaleur)backslash-newline else:backslash-newline resultat.append(val)backslash-newlinebackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# 1er testbackslash-newlinevaleurs = [3, 8, 7]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 7]backslash-newlineassert valeurs == [backslash-newline 3, 8, 7], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newline# 2nd testbackslash-newlinevaleurs = [3, 8, 3, 5]backslash-newlineassert remplacer(valeurs, 3, 0) == [0, 8, 0, 5]backslash-newlineassert valeurs == [backslash-newline 3, 8, 3, 5], \"Il ne faut pas modifier les valeurs donn\u00c3\u00a9es en entr\u00c3\u00a9e\"backslash-newlinebackslash-newline A","title":"Remplacer une valeur"},{"location":"1-facile/1250-remplacer/sujet/#commentaires","text":"{{ py('exo_corr', 0, \"# TESTS\") }} Il n'y a pas de difficult\u00e9s majeures si ce n'est prendre soin de ne pas modifier la liste initiale. On cr\u00e9e donc une seconde liste que l'on compl\u00e8te au fur et \u00e0 mesure en parcourant les valeurs de valeurs . On aurait aussi pu utiliser une liste par compr\u00e9hension et un op\u00e9rateur ternaire : \ud83d\udc0d Script Python def remplacer ( valeurs , valeur_cible , nouvelle_valeur ): return [ val if val != valeur_cible else nouvelle_valeur for val in valeurs ] Z","title":"Commentaires"},{"location":"1-facile/1250-val_ind_max/sujet/","tags":["boucle","tuple"],"text":"Maximum d'un tableau : valeur et indice \u2693\ufe0e \u00c9crire une fonction valeur_et_indice_du_max qui prend en param\u00e8tre une liste de nombres entiers valeurs et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l'indice de la premi\u00e8re apparition de ce maximum dans la liste. Pour une liste vide, la fonction renvoie ( None , None ) Exemples \ud83d\udc0d Console Python >>> valeur_et_indice_du_max ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) (9, 3) >>> valeur_et_indice_du_max ([ 1 , 1 , 1 , 99 , 99 ]) (99, 3) >>> valeur_et_indice_du_max ([ 10 ]) (10, 0) >>> valeur_et_indice_du_max ([]) (None, None) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([100, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (100, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 800]) == (800, 9)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 199, 199, 5]) == (199, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([100]) == (100, 0)backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newline def valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax(valeurs):backslash-newline if valeurs == []:backslash-newline return (None, None)backslash-newline else:backslash-newline valeurpython-underscoremaxi = valeurs[0]backslash-newline indicepython-underscoremaxi = 0backslash-newline for i in range(1, len(valeurs)):backslash-newline x = valeurs[i]backslash-newline if x > valeurpython-underscoremaxi:backslash-newline valeurpython-underscoremaxi = xbackslash-newline indicepython-underscoremaxi = ibackslash-newline return (valeurpython-underscoremaxi, indicepython-underscoremaxi)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newline A Z","title":"Valeur et indice du max"},{"location":"1-facile/1250-val_ind_max/sujet/#maximum-dun-tableau-valeur-et-indice","text":"\u00c9crire une fonction valeur_et_indice_du_max qui prend en param\u00e8tre une liste de nombres entiers valeurs et renvoie un couple donnant le plus grand \u00e9l\u00e9ment de cette liste, ainsi que l'indice de la premi\u00e8re apparition de ce maximum dans la liste. Pour une liste vide, la fonction renvoie ( None , None ) Exemples \ud83d\udc0d Console Python >>> valeur_et_indice_du_max ([ 1 , 5 , 6 , 9 , 1 , 2 , 3 , 7 , 9 , 8 ]) (9, 3) >>> valeur_et_indice_du_max ([ 1 , 1 , 1 , 99 , 99 ]) (99, 3) >>> valeur_et_indice_du_max ([ 10 ]) (10, 0) >>> valeur_et_indice_du_max ([]) (None, None) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([100, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (100, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 800]) == (800, 9)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 199, 199, 5]) == (199, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([100]) == (100, 0)backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newline def valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax(valeurs):backslash-newline if valeurs == []:backslash-newline return (None, None)backslash-newline else:backslash-newline valeurpython-underscoremaxi = valeurs[0]backslash-newline indicepython-underscoremaxi = 0backslash-newline for i in range(1, len(valeurs)):backslash-newline x = valeurs[i]backslash-newline if x > valeurpython-underscoremaxi:backslash-newline valeurpython-underscoremaxi = xbackslash-newline indicepython-underscoremaxi = ibackslash-newline return (valeurpython-underscoremaxi, indicepython-underscoremaxi)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 5, 6, 9, 1, 2, 3, 7, 9, 8]) == (9, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([1, 1, 1, 99, 99]) == (99, 3)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([10]) == (10, 0)backslash-newlineassert valeurpython-underscoreetpython-underscoreindicepython-underscoredupython-underscoremax([]) == (None, None)backslash-newlinebackslash-newline A Z","title":"Maximum d'un tableau : valeur et indice"},{"location":"1-facile/1275-join/exo_REM/","text":"Commentaires \u2693\ufe0e Version it\u00e9rative \u2693\ufe0e \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : if discours != \"\" : # on a d\u00e9j\u00e0 mis un mot discours += \" \" discours += mot return discours On ajoute une espace avant d'ajouter un mot au discours, sauf si c'est le premier ; chose que l'on d\u00e9tecte quand le discours est vide. Version fonctionnelle \u2693\ufe0e L'\u00e9nonc\u00e9 interdit d'utiliser join Voici ce que \u00e7a aurait pu donner : 1 ligne ! \ud83d\udc0d Script Python def supprimheu ( mots ): return \" \" . join ( mot for mot in mots if mot != \"heu\" ) Une version rigolote serait \ud83d\udc0d Script Python def supprimheu ( heus ): return \" \" . join ( heu for heu in heus if heu != \"heu\" ) Version avec filtre avant collage \u2693\ufe0e \ud83d\udc0d Script Python def supprimeuh ( mots ): liste_mots = [] for mot in mots : if mot != \"heu\" : liste_mots . append ( mot ) if liste_mots == []: return '' chaine = liste_mots [ 0 ] for mot in liste_mots [ 1 :]: chaine = chaine + ' ' + mot return chaine Autre version it\u00e9rative \u2693\ufe0e Dans la plupart des juges en ligne, la pr\u00e9sence d'espaces suppl\u00e9mentaires en fin de ligne est accept\u00e9e. Dans ce cas , une solution est : \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : discours += mot + \" \" return discours Derni\u00e8re remarque : si on souhaite apr\u00e8s coup enlever les espaces en trop \u00e0 la fin, on peut utiliser rstrip ainsi : py return discours.rstrip() Mais, attention, cela coute une copie compl\u00e8te de la chaine de caract\u00e8re.","title":"Commentaires"},{"location":"1-facile/1275-join/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1275-join/exo_REM/#version-iterative","text":"\ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : if discours != \"\" : # on a d\u00e9j\u00e0 mis un mot discours += \" \" discours += mot return discours On ajoute une espace avant d'ajouter un mot au discours, sauf si c'est le premier ; chose que l'on d\u00e9tecte quand le discours est vide.","title":"Version it\u00e9rative"},{"location":"1-facile/1275-join/exo_REM/#version-fonctionnelle","text":"L'\u00e9nonc\u00e9 interdit d'utiliser join Voici ce que \u00e7a aurait pu donner : 1 ligne ! \ud83d\udc0d Script Python def supprimheu ( mots ): return \" \" . join ( mot for mot in mots if mot != \"heu\" ) Une version rigolote serait \ud83d\udc0d Script Python def supprimheu ( heus ): return \" \" . join ( heu for heu in heus if heu != \"heu\" )","title":"Version fonctionnelle"},{"location":"1-facile/1275-join/exo_REM/#version-avec-filtre-avant-collage","text":"\ud83d\udc0d Script Python def supprimeuh ( mots ): liste_mots = [] for mot in mots : if mot != \"heu\" : liste_mots . append ( mot ) if liste_mots == []: return '' chaine = liste_mots [ 0 ] for mot in liste_mots [ 1 :]: chaine = chaine + ' ' + mot return chaine","title":"Version avec filtre avant collage"},{"location":"1-facile/1275-join/exo_REM/#autre-version-iterative","text":"Dans la plupart des juges en ligne, la pr\u00e9sence d'espaces suppl\u00e9mentaires en fin de ligne est accept\u00e9e. Dans ce cas , une solution est : \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : discours += mot + \" \" return discours Derni\u00e8re remarque : si on souhaite apr\u00e8s coup enlever les espaces en trop \u00e0 la fin, on peut utiliser rstrip ainsi : py return discours.rstrip() Mais, attention, cela coute une copie compl\u00e8te de la chaine de caract\u00e8re.","title":"Autre version it\u00e9rative"},{"location":"1-facile/1275-join/sujet/","tags":["boucle","string","a_trou"],"text":"Collage de mots \u2693\ufe0e Un logiciel de reconnaissance vocale donne la liste des mots d'un candidat h\u00e9sitant, il y a de nombreux \u00ab heu \u00bb que l'on souhaite supprimer de son discours. \u00c9crire une fonction supprimeuh qui prend en param\u00e8tre mots : une liste de mots qui sont des chaines de caract\u00e8res (non vides) uniquement compos\u00e9es de lettres minuscules, et qui renvoie le discours sous forme d'une seule chaine de caract\u00e8res qui ne contient plus les mots \"heu\" de la liste. Les mots seront s\u00e9par\u00e9s par une seule espace. Il n'y aura pas d'espace ni au d\u00e9but, ni \u00e0 la fin du discours. On n'utilisera pas join , ni print dans cet exercice. Exemples \ud83d\udc0d Console Python >>> supprimheu ([ \"je\" , \"heu\" , \"vais\" , \"coder\" , \"heu\" , \"la\" , \"fonction\" , \"supprimheu\" ]) 'je vais coder la fonction supprimheu' \ud83d\udc0d Console Python >>> supprimheu ([ \"c\" , \"est\" , \"facile\" ]) 'c est facile' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert supprimheu([]) == ''backslash-newlineassert supprimheu([\"heu\"]) == ''backslash-newlineassert supprimheu([\"heu\", \"bonjour\"]) == 'bonjour'backslash-newlineassert supprimheu([\"bien\", \"le\", \"bonjour\"]) == 'bien le bonjour'backslash-newlineassert supprimheu([\"bien\", \"le\", \"bonjour\", \"heu\"]) == 'bien le bonjour'backslash-newlinebackslash-newline Valider 5/5 def supprimheu(mots):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert supprimheu([\"je\", \"heu\", \"vais\", \"coder\", \"heu\", \"la\",backslash-newline \"fonction\", \"supprimheu\"]) == 'je vais coder la fonction supprimheu'backslash-newlinebackslash-newlineassert supprimheu([\"c\", \"est\", \"facile\"]) == 'c est facile'backslash-newlinebackslash-newline def supprimheu(mots):backslash-newline discours = \"\"backslash-newline for mot in mots:backslash-newline if mot != \"heu\":backslash-newline if discours != \"\":backslash-newline # on a d\u00c3\u00a9j\u00c3 mis un motbackslash-newline discours += \" \"backslash-newline discours += motbackslash-newline return discoursbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert supprimheu([\"je\", \"heu\", \"vais\", \"coder\", \"heu\", \"la\", \"fonction\", \"supprimheu\"]) == 'je vais coder la fonction supprimheu'backslash-newlinebackslash-newlineassert supprimheu([\"c\", \"est\", \"facile\"]) == 'c est facile'backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version it\u00e9rative \u2693\ufe0e \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : if discours != \"\" : # on a d\u00e9j\u00e0 mis un mot discours += \" \" discours += mot return discours On ajoute une espace avant d'ajouter un mot au discours, sauf si c'est le premier ; chose que l'on d\u00e9tecte quand le discours est vide. Version fonctionnelle \u2693\ufe0e L'\u00e9nonc\u00e9 interdit d'utiliser join Voici ce que \u00e7a aurait pu donner : 1 ligne ! \ud83d\udc0d Script Python def supprimheu ( mots ): return \" \" . join ( mot for mot in mots if mot != \"heu\" ) Une version rigolote serait \ud83d\udc0d Script Python def supprimheu ( heus ): return \" \" . join ( heu for heu in heus if heu != \"heu\" ) Version avec filtre avant collage \u2693\ufe0e \ud83d\udc0d Script Python def supprimeuh ( mots ): liste_mots = [] for mot in mots : if mot != \"heu\" : liste_mots . append ( mot ) if liste_mots == []: return '' chaine = liste_mots [ 0 ] for mot in liste_mots [ 1 :]: chaine = chaine + ' ' + mot return chaine Autre version it\u00e9rative \u2693\ufe0e Dans la plupart des juges en ligne, la pr\u00e9sence d'espaces suppl\u00e9mentaires en fin de ligne est accept\u00e9e. Dans ce cas , une solution est : \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : discours += mot + \" \" return discours Derni\u00e8re remarque : si on souhaite apr\u00e8s coup enlever les espaces en trop \u00e0 la fin, on peut utiliser rstrip ainsi : py return discours.rstrip() Mais, attention, cela coute une copie compl\u00e8te de la chaine de caract\u00e8re. Z","title":"Collage"},{"location":"1-facile/1275-join/sujet/#collage-de-mots","text":"Un logiciel de reconnaissance vocale donne la liste des mots d'un candidat h\u00e9sitant, il y a de nombreux \u00ab heu \u00bb que l'on souhaite supprimer de son discours. \u00c9crire une fonction supprimeuh qui prend en param\u00e8tre mots : une liste de mots qui sont des chaines de caract\u00e8res (non vides) uniquement compos\u00e9es de lettres minuscules, et qui renvoie le discours sous forme d'une seule chaine de caract\u00e8res qui ne contient plus les mots \"heu\" de la liste. Les mots seront s\u00e9par\u00e9s par une seule espace. Il n'y aura pas d'espace ni au d\u00e9but, ni \u00e0 la fin du discours. On n'utilisera pas join , ni print dans cet exercice. Exemples \ud83d\udc0d Console Python >>> supprimheu ([ \"je\" , \"heu\" , \"vais\" , \"coder\" , \"heu\" , \"la\" , \"fonction\" , \"supprimheu\" ]) 'je vais coder la fonction supprimheu' \ud83d\udc0d Console Python >>> supprimheu ([ \"c\" , \"est\" , \"facile\" ]) 'c est facile' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert supprimheu([]) == ''backslash-newlineassert supprimheu([\"heu\"]) == ''backslash-newlineassert supprimheu([\"heu\", \"bonjour\"]) == 'bonjour'backslash-newlineassert supprimheu([\"bien\", \"le\", \"bonjour\"]) == 'bien le bonjour'backslash-newlineassert supprimheu([\"bien\", \"le\", \"bonjour\", \"heu\"]) == 'bien le bonjour'backslash-newlinebackslash-newline Valider 5/5 def supprimheu(mots):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert supprimheu([\"je\", \"heu\", \"vais\", \"coder\", \"heu\", \"la\",backslash-newline \"fonction\", \"supprimheu\"]) == 'je vais coder la fonction supprimheu'backslash-newlinebackslash-newlineassert supprimheu([\"c\", \"est\", \"facile\"]) == 'c est facile'backslash-newlinebackslash-newline def supprimheu(mots):backslash-newline discours = \"\"backslash-newline for mot in mots:backslash-newline if mot != \"heu\":backslash-newline if discours != \"\":backslash-newline # on a d\u00c3\u00a9j\u00c3 mis un motbackslash-newline discours += \" \"backslash-newline discours += motbackslash-newline return discoursbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert supprimheu([\"je\", \"heu\", \"vais\", \"coder\", \"heu\", \"la\", \"fonction\", \"supprimheu\"]) == 'je vais coder la fonction supprimheu'backslash-newlinebackslash-newlineassert supprimheu([\"c\", \"est\", \"facile\"]) == 'c est facile'backslash-newlinebackslash-newline A","title":"Collage de mots"},{"location":"1-facile/1275-join/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1275-join/sujet/#version-iterative","text":"\ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : if discours != \"\" : # on a d\u00e9j\u00e0 mis un mot discours += \" \" discours += mot return discours On ajoute une espace avant d'ajouter un mot au discours, sauf si c'est le premier ; chose que l'on d\u00e9tecte quand le discours est vide.","title":"Version it\u00e9rative"},{"location":"1-facile/1275-join/sujet/#version-fonctionnelle","text":"L'\u00e9nonc\u00e9 interdit d'utiliser join Voici ce que \u00e7a aurait pu donner : 1 ligne ! \ud83d\udc0d Script Python def supprimheu ( mots ): return \" \" . join ( mot for mot in mots if mot != \"heu\" ) Une version rigolote serait \ud83d\udc0d Script Python def supprimheu ( heus ): return \" \" . join ( heu for heu in heus if heu != \"heu\" )","title":"Version fonctionnelle"},{"location":"1-facile/1275-join/sujet/#version-avec-filtre-avant-collage","text":"\ud83d\udc0d Script Python def supprimeuh ( mots ): liste_mots = [] for mot in mots : if mot != \"heu\" : liste_mots . append ( mot ) if liste_mots == []: return '' chaine = liste_mots [ 0 ] for mot in liste_mots [ 1 :]: chaine = chaine + ' ' + mot return chaine","title":"Version avec filtre avant collage"},{"location":"1-facile/1275-join/sujet/#autre-version-iterative","text":"Dans la plupart des juges en ligne, la pr\u00e9sence d'espaces suppl\u00e9mentaires en fin de ligne est accept\u00e9e. Dans ce cas , une solution est : \ud83d\udc0d Script Python def supprimheu ( mots ): discours = \"\" for mot in mots : if mot != \"heu\" : discours += mot + \" \" return discours Derni\u00e8re remarque : si on souhaite apr\u00e8s coup enlever les espaces en trop \u00e0 la fin, on peut utiliser rstrip ainsi : py return discours.rstrip() Mais, attention, cela coute une copie compl\u00e8te de la chaine de caract\u00e8re. Z","title":"Autre version it\u00e9rative"},{"location":"1-facile/1275-moy_ponderee/exo_REM/","text":"Commentaires \u2693\ufe0e It\u00e9ration sans indice \u2693\ufe0e Version recommand\u00e9e \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for ( note , coeff ) in notes_ponderees : cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff parcourir un tuple La construction \ud83d\udc0d Script Python for ( note , coeff ) in notes_ponderees : ... est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python for element in notes_ponderees : note = element [ 0 ] coeff = element [ 1 ] ... On pr\u00e9f\u00e8rera la premi\u00e8re version. It\u00e9ration avec indice \u2693\ufe0e Peu d'int\u00e9r\u00eat \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for i in range ( len ( notes_ponderees )): note , coeff = notes_ponderees [ i ] cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff unpack d'un tuple La construction \ud83d\udc0d Script Python note , coeff = notes_ponderees [ i ] est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python note = notes_ponderees [ i ][ 0 ] coeff = notes_ponderees [ i ][ 1 ] On pr\u00e9f\u00e8rera la premi\u00e8re version. Version fonctionnelle \u2693\ufe0e Non recommand\u00e9e ; deux parcours de la liste \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = sum ( note * coeff for ( note , coeff ) in notes_ponderees ) cumul_coeffs = sum ( coeff for ( note , coeff ) in notes_ponderees ) return cumul_points / cumul_coeff","title":"Commentaires"},{"location":"1-facile/1275-moy_ponderee/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1275-moy_ponderee/exo_REM/#iteration-sans-indice","text":"Version recommand\u00e9e \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for ( note , coeff ) in notes_ponderees : cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff parcourir un tuple La construction \ud83d\udc0d Script Python for ( note , coeff ) in notes_ponderees : ... est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python for element in notes_ponderees : note = element [ 0 ] coeff = element [ 1 ] ... On pr\u00e9f\u00e8rera la premi\u00e8re version.","title":"It\u00e9ration sans indice"},{"location":"1-facile/1275-moy_ponderee/exo_REM/#iteration-avec-indice","text":"Peu d'int\u00e9r\u00eat \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for i in range ( len ( notes_ponderees )): note , coeff = notes_ponderees [ i ] cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff unpack d'un tuple La construction \ud83d\udc0d Script Python note , coeff = notes_ponderees [ i ] est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python note = notes_ponderees [ i ][ 0 ] coeff = notes_ponderees [ i ][ 1 ] On pr\u00e9f\u00e8rera la premi\u00e8re version.","title":"It\u00e9ration avec indice"},{"location":"1-facile/1275-moy_ponderee/exo_REM/#version-fonctionnelle","text":"Non recommand\u00e9e ; deux parcours de la liste \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = sum ( note * coeff for ( note , coeff ) in notes_ponderees ) cumul_coeffs = sum ( coeff for ( note , coeff ) in notes_ponderees ) return cumul_points / cumul_coeff","title":"Version fonctionnelle"},{"location":"1-facile/1275-moy_ponderee/sujet/","tags":["boucle","tuple","maths"],"text":"Moyenne de notes avec coefficients \u2693\ufe0e Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste non vide compos\u00e9e de couples (note, coefficient) . Dans ce couple : note est un nombre de type flottant ( float ) compris entre 0.0 et 20.0 coefficient est un nombre de type entier ( int ) strictement positif \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Exemple Le calcul suivant illustre l'exemple : \\[\\frac{2\u00d715,\\!0 + 1\u00d79,\\!0 + 3\u00d712,\\!0}{2+1+3} = 12,\\!5\\] \ud83d\udc0d Console Python >>> moyenne ([( 15.0 , 2 ), ( 9.0 , 1 ), ( 12.0 , 3 )]) 12.5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([( 0.0, 1)]), 0.0), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([(20.0, 1)]), 20.0), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([(10.0, 5)]), 10.0), \"Erreur sur ce test\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def moyenne(notespython-underscoreponderes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline \"Renvoie un bool\u00c3\u00a9en : les nombres x et y sont-ils proches ?\"backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline def moyenne(notespython-underscoreponderees):backslash-newline cumulpython-underscorepoints = 0.0backslash-newline cumulpython-underscorecoeffs = 0backslash-newline for (note, coeff) in notespython-underscoreponderees:backslash-newline cumulpython-underscorepoints += coeff python-star notebackslash-newline cumulpython-underscorecoeffs += coeffbackslash-newline return cumulpython-underscorepoints / cumulpython-underscorecoeffsbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline \"Renvoie un bool\u00c3\u00a9en : les nombres x et y sont-ils proches ?\"backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e It\u00e9ration sans indice \u2693\ufe0e Version recommand\u00e9e \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for ( note , coeff ) in notes_ponderees : cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff parcourir un tuple La construction \ud83d\udc0d Script Python for ( note , coeff ) in notes_ponderees : ... est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python for element in notes_ponderees : note = element [ 0 ] coeff = element [ 1 ] ... On pr\u00e9f\u00e8rera la premi\u00e8re version. It\u00e9ration avec indice \u2693\ufe0e Peu d'int\u00e9r\u00eat \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for i in range ( len ( notes_ponderees )): note , coeff = notes_ponderees [ i ] cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff unpack d'un tuple La construction \ud83d\udc0d Script Python note , coeff = notes_ponderees [ i ] est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python note = notes_ponderees [ i ][ 0 ] coeff = notes_ponderees [ i ][ 1 ] On pr\u00e9f\u00e8rera la premi\u00e8re version. Version fonctionnelle \u2693\ufe0e Non recommand\u00e9e ; deux parcours de la liste \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = sum ( note * coeff for ( note , coeff ) in notes_ponderees ) cumul_coeffs = sum ( coeff for ( note , coeff ) in notes_ponderees ) return cumul_points / cumul_coeff Z","title":"Moyenne pond\u00e9r\u00e9e"},{"location":"1-facile/1275-moy_ponderee/sujet/#moyenne-de-notes-avec-coefficients","text":"Les r\u00e9sultats aux \u00e9valuations d'un \u00e9l\u00e8ve sont regroup\u00e9s dans une liste non vide compos\u00e9e de couples (note, coefficient) . Dans ce couple : note est un nombre de type flottant ( float ) compris entre 0.0 et 20.0 coefficient est un nombre de type entier ( int ) strictement positif \u00c9crire une fonction moyenne qui renvoie la moyenne pond\u00e9r\u00e9e de cette liste donn\u00e9e en param\u00e8tre. Exemple Le calcul suivant illustre l'exemple : \\[\\frac{2\u00d715,\\!0 + 1\u00d79,\\!0 + 3\u00d712,\\!0}{2+1+3} = 12,\\!5\\] \ud83d\udc0d Console Python >>> moyenne ([( 15.0 , 2 ), ( 9.0 , 1 ), ( 12.0 , 3 )]) 12.5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([( 0.0, 1)]), 0.0), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([(20.0, 1)]), 20.0), \"Erreur sur ce test\"backslash-newlineassert sontpython-underscoreproches(moyenne([(10.0, 5)]), 10.0), \"Erreur sur ce test\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def moyenne(notespython-underscoreponderes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline \"Renvoie un bool\u00c3\u00a9en : les nombres x et y sont-ils proches ?\"backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline def moyenne(notespython-underscoreponderees):backslash-newline cumulpython-underscorepoints = 0.0backslash-newline cumulpython-underscorecoeffs = 0backslash-newline for (note, coeff) in notespython-underscoreponderees:backslash-newline cumulpython-underscorepoints += coeff python-star notebackslash-newline cumulpython-underscorecoeffs += coeffbackslash-newline return cumulpython-underscorepoints / cumulpython-underscorecoeffsbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline \"Renvoie un bool\u00c3\u00a9en : les nombres x et y sont-ils proches ?\"backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2)]), 15.0)backslash-newlineassert sontpython-underscoreproches(moyenne([(15.0, 2), (9.0, 1), (12.0, 3)]), 12.5)backslash-newlinebackslash-newline A","title":"Moyenne de notes avec coefficients"},{"location":"1-facile/1275-moy_ponderee/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1275-moy_ponderee/sujet/#iteration-sans-indice","text":"Version recommand\u00e9e \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for ( note , coeff ) in notes_ponderees : cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff parcourir un tuple La construction \ud83d\udc0d Script Python for ( note , coeff ) in notes_ponderees : ... est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python for element in notes_ponderees : note = element [ 0 ] coeff = element [ 1 ] ... On pr\u00e9f\u00e8rera la premi\u00e8re version.","title":"It\u00e9ration sans indice"},{"location":"1-facile/1275-moy_ponderee/sujet/#iteration-avec-indice","text":"Peu d'int\u00e9r\u00eat \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = 0.0 cumul_coeffs = 0 for i in range ( len ( notes_ponderees )): note , coeff = notes_ponderees [ i ] cumul_points += coeff * note cumul_coeff += coeff return cumul_points / cumul_coeff unpack d'un tuple La construction \ud83d\udc0d Script Python note , coeff = notes_ponderees [ i ] est \u00e9quivalente \u00e0 \ud83d\udc0d Script Python note = notes_ponderees [ i ][ 0 ] coeff = notes_ponderees [ i ][ 1 ] On pr\u00e9f\u00e8rera la premi\u00e8re version.","title":"It\u00e9ration avec indice"},{"location":"1-facile/1275-moy_ponderee/sujet/#version-fonctionnelle","text":"Non recommand\u00e9e ; deux parcours de la liste \ud83d\udc0d Script Python def moyenne ( notes_ponderees ): cumul_points = sum ( note * coeff for ( note , coeff ) in notes_ponderees ) cumul_coeffs = sum ( coeff for ( note , coeff ) in notes_ponderees ) return cumul_points / cumul_coeff Z","title":"Version fonctionnelle"},{"location":"1-facile/1275-nb_puis_double/sujet/","tags":["boucle"],"text":"Double du pr\u00e9c\u00e9dent dans un tableau \u2693\ufe0e \u00c9crire une fonction nombres_puis_double qui prend en param\u00e8tre un tableau de nombres entiers, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers (a, b) qu'il peut y avoir dans le tableau tel que b suit a et b = 2 * a . Exemples \ud83d\udc0d Console Python >>> nombres_puis_double ([ 1 , 4 , 2 , 5 ]) [] >>> nombres_puis_double ([ 1 , 3 , 6 , 7 ]) [(3, 6)] >>> nombres_puis_double ([ 7 , 1 , 2 , 5 , 3 , 6 ]) [(1, 2), (3, 6)] >>> nombres_puis_double ([ 5 , 1 , 2 , 4 , 8 , - 5 , - 10 , 7 ]) [(1, 2), (2, 4), (4, 8), (-5, -10)] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newlinebackslash-newline# corner casebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([10, 4, 2, 5]) == [], \"Attention aux indices\"backslash-newlinebackslash-newline Valider 5/5 def nombrespython-underscorepuispython-underscoredouble(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newline def nombrespython-underscorepuispython-underscoredouble(valeurs):backslash-newline resultat = []backslash-newline for i in range(1, len(valeurs)):backslash-newline if valeurs[i] == valeurs[i - 1] python-star 2:backslash-newline resultat.append((valeurs[i - 1], valeurs[i]))backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newline A Z","title":"Nombres puis double"},{"location":"1-facile/1275-nb_puis_double/sujet/#double-du-precedent-dans-un-tableau","text":"\u00c9crire une fonction nombres_puis_double qui prend en param\u00e8tre un tableau de nombres entiers, et qui renvoie la liste (\u00e9ventuellement vide) des couples d'entiers (a, b) qu'il peut y avoir dans le tableau tel que b suit a et b = 2 * a . Exemples \ud83d\udc0d Console Python >>> nombres_puis_double ([ 1 , 4 , 2 , 5 ]) [] >>> nombres_puis_double ([ 1 , 3 , 6 , 7 ]) [(3, 6)] >>> nombres_puis_double ([ 7 , 1 , 2 , 5 , 3 , 6 ]) [(1, 2), (3, 6)] >>> nombres_puis_double ([ 5 , 1 , 2 , 4 , 8 , - 5 , - 10 , 7 ]) [(1, 2), (2, 4), (4, 8), (-5, -10)] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newlinebackslash-newline# corner casebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([10, 4, 2, 5]) == [], \"Attention aux indices\"backslash-newlinebackslash-newline Valider 5/5 def nombrespython-underscorepuispython-underscoredouble(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newline def nombrespython-underscorepuispython-underscoredouble(valeurs):backslash-newline resultat = []backslash-newline for i in range(1, len(valeurs)):backslash-newline if valeurs[i] == valeurs[i - 1] python-star 2:backslash-newline resultat.append((valeurs[i - 1], valeurs[i]))backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 4, 2, 5]) == []backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([1, 3, 6, 7]) == [(3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble([7, 1, 2, 5, 3, 6]) == [(1, 2), (3, 6)]backslash-newlineassert nombrespython-underscorepuispython-underscoredouble(backslash-newline [5, 1, 2, 4, 8, -5, -10, 7]) == [(1, 2), (2, 4), (4, 8), (-5, -10)]backslash-newlinebackslash-newline A Z","title":"Double du pr\u00e9c\u00e9dent dans un tableau"},{"location":"1-facile/1300-delta_encoding/exo_REM/","text":"Commentaires \u2693\ufe0e Liste en compr\u00e9hension \u2693\ufe0e \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [ valeurs [ i ] - valeurs [ i - 1 ] for i in range ( 1 , len ( valeurs ))] return ( valeurs [ 0 ], differences ) Liste dynamique \u2693\ufe0e \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( 1 , len ( valeurs )): differences . append ( valeurs [ i ] - valeurs [ i - 1 ]) return ( valeurs [ 0 ], differences ) On pouvait aussi it\u00e9rer de 0 \u00e0 len ( valeurs ) - 1 \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( len ( valeurs ) - 1 ): differences . append ( valeurs [ i + 1 ] - valeurs [ i ]) return ( valeurs [ 0 ], differences )","title":"Commentaires"},{"location":"1-facile/1300-delta_encoding/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1300-delta_encoding/exo_REM/#liste-en-comprehension","text":"\ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [ valeurs [ i ] - valeurs [ i - 1 ] for i in range ( 1 , len ( valeurs ))] return ( valeurs [ 0 ], differences )","title":"Liste en compr\u00e9hension"},{"location":"1-facile/1300-delta_encoding/exo_REM/#liste-dynamique","text":"\ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( 1 , len ( valeurs )): differences . append ( valeurs [ i ] - valeurs [ i - 1 ]) return ( valeurs [ 0 ], differences ) On pouvait aussi it\u00e9rer de 0 \u00e0 len ( valeurs ) - 1 \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( len ( valeurs ) - 1 ): differences . append ( valeurs [ i + 1 ] - valeurs [ i ]) return ( valeurs [ 0 ], differences )","title":"Liste dynamique"},{"location":"1-facile/1300-delta_encoding/sujet/","tags":["boucle","tuple"],"text":"Delta encoding \u2693\ufe0e Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta_encoding qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tuple \u00e0 deux \u00e9l\u00e9ments comprenant : En premier, la valeur initiale En second, le tableau des diff\u00e9rences, contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l'aide de cette technique. Exemples \ud83d\udc0d Script Python >>> delta_encoding ([ 1_000_000 , 1_000_042 , 1_000_040 , 1_000_055 , 1_000_010 ]) ( 1000000 , [ 42 , - 2 , 15 , - 45 ]) >>> delta_encoding ([ 42 ]) ( 42 , []) Afin de gagner en lisibilit\u00e9, Python autorise de placer un tiret-bas pour s\u00e9parer les chiffres par paquets de trois. Ainsi 1_000_000 correspond bien \u00e0 un million, et est plus lisible que 1000000 . En revanche, l'affichage en console d'un r\u00e9sultat ne l'utilise pas. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert deltapython-underscoreencoding([backslash-newline 1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010backslash-newline]) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newlinebackslash-newlineassert deltapython-underscoreencoding([0, 1, 2, 3, 4]) == (0, [1, 1, 1, 1])backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def deltapython-underscoreencoding(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert deltapython-underscoreencoding(backslash-newline [1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010]backslash-newline) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newline def deltapython-underscoreencoding(valeurs):backslash-newline differences = [valeurs[i] - valeurs[i - 1] for i in range(1, len(valeurs))]backslash-newline return (valeurs[0], differences)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert deltapython-underscoreencoding([backslash-newline 1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010backslash-newline]) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Liste en compr\u00e9hension \u2693\ufe0e \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [ valeurs [ i ] - valeurs [ i - 1 ] for i in range ( 1 , len ( valeurs ))] return ( valeurs [ 0 ], differences ) Liste dynamique \u2693\ufe0e \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( 1 , len ( valeurs )): differences . append ( valeurs [ i ] - valeurs [ i - 1 ]) return ( valeurs [ 0 ], differences ) On pouvait aussi it\u00e9rer de 0 \u00e0 len ( valeurs ) - 1 \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( len ( valeurs ) - 1 ): differences . append ( valeurs [ i + 1 ] - valeurs [ i ]) return ( valeurs [ 0 ], differences ) Z","title":"Codage par diff\u00e9rence"},{"location":"1-facile/1300-delta_encoding/sujet/#delta-encoding","text":"Le codage par diff\u00e9rence ( delta encoding en anglais) permet de compresser un tableau de donn\u00e9es en indiquant pour chaque donn\u00e9e, sa diff\u00e9rence avec la pr\u00e9c\u00e9dente (plut\u00f4t que la donn\u00e9e elle-m\u00eame). On se retrouve alors avec un tableau de donn\u00e9es assez petites n\u00e9cessitant moins de place en m\u00e9moire. Cette m\u00e9thode se r\u00e9v\u00e8le efficace lorsque les valeurs cons\u00e9cutives sont proches. Programmer la fonction delta_encoding qui prend en param\u00e8tre un tableau non vide de nombres entiers et qui renvoie un tuple \u00e0 deux \u00e9l\u00e9ments comprenant : En premier, la valeur initiale En second, le tableau des diff\u00e9rences, contenant les valeurs enti\u00e8res compress\u00e9es \u00e0 l'aide de cette technique. Exemples \ud83d\udc0d Script Python >>> delta_encoding ([ 1_000_000 , 1_000_042 , 1_000_040 , 1_000_055 , 1_000_010 ]) ( 1000000 , [ 42 , - 2 , 15 , - 45 ]) >>> delta_encoding ([ 42 ]) ( 42 , []) Afin de gagner en lisibilit\u00e9, Python autorise de placer un tiret-bas pour s\u00e9parer les chiffres par paquets de trois. Ainsi 1_000_000 correspond bien \u00e0 un million, et est plus lisible que 1000000 . En revanche, l'affichage en console d'un r\u00e9sultat ne l'utilise pas. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert deltapython-underscoreencoding([backslash-newline 1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010backslash-newline]) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newlinebackslash-newlineassert deltapython-underscoreencoding([0, 1, 2, 3, 4]) == (0, [1, 1, 1, 1])backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def deltapython-underscoreencoding(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert deltapython-underscoreencoding(backslash-newline [1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010]backslash-newline) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newline def deltapython-underscoreencoding(valeurs):backslash-newline differences = [valeurs[i] - valeurs[i - 1] for i in range(1, len(valeurs))]backslash-newline return (valeurs[0], differences)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert deltapython-underscoreencoding([backslash-newline 1python-underscore000python-underscore000, 1python-underscore000python-underscore042, 1python-underscore000python-underscore040, 1python-underscore000python-underscore055, 1python-underscore000python-underscore010backslash-newline]) == (1000000, [42, -2, 15, -45])backslash-newlinebackslash-newlineassert deltapython-underscoreencoding([42]) == (42, [])backslash-newlinebackslash-newline A","title":"Delta encoding"},{"location":"1-facile/1300-delta_encoding/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1300-delta_encoding/sujet/#liste-en-comprehension","text":"\ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [ valeurs [ i ] - valeurs [ i - 1 ] for i in range ( 1 , len ( valeurs ))] return ( valeurs [ 0 ], differences )","title":"Liste en compr\u00e9hension"},{"location":"1-facile/1300-delta_encoding/sujet/#liste-dynamique","text":"\ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( 1 , len ( valeurs )): differences . append ( valeurs [ i ] - valeurs [ i - 1 ]) return ( valeurs [ 0 ], differences ) On pouvait aussi it\u00e9rer de 0 \u00e0 len ( valeurs ) - 1 \ud83d\udc0d Script Python def delta_encoding ( valeurs ): differences = [] for i in range ( len ( valeurs ) - 1 ): differences . append ( valeurs [ i + 1 ] - valeurs [ i ]) return ( valeurs [ 0 ], differences ) Z","title":"Liste dynamique"},{"location":"1-facile/1300-moyenne/sujet/","tags":["boucle"],"text":"\u00c9crire une fonction moyenne prenant en param\u00e8tre un tableau non vide d'entiers et qui renvoie la moyenne des valeurs du tableau. On n'utilisera pas la fonction pr\u00e9d\u00e9finie sum dans cet exercice. Exemples \ud83d\udc0d Console Python >>> moyenne ([ 10 , 20 , 30 , 40 , 60 , 110 ]) 45.0 >>> moyenne ([ 1 , 3 ]) 2.0 >>> moyenne ([ 44 , 51 , 12 , 72 , 65 , 34 ]) 46.333333333333336 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(x, y):backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([10, 20, 30, 40, 60, 110]), 45.0)backslash-newlineassert sontpython-underscoreproches(moyenne([1, 3]), 2.0)backslash-newlineassert sontpython-underscoreproches(moyenne([44, 51, 12, 72, 65, 34]), 46.333333333333336)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([69, 80, 43, 21, 42, 18]), 45.5)backslash-newlineassert sontpython-underscoreproches(moyenne([29, 94, 65, 77, 95, 31, 79]), 67.14285714285714)backslash-newlineassert sontpython-underscoreproches(moyenne([3, 1, 7, 6, 8]), 5.0)backslash-newlinebackslash-newline Valider 5/5 def sontpython-underscoreproches(x, y):backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlinebackslash-newline# Votre fonction moyenne icibackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sontpython-underscoreproches(moyenne([10, 20, 30, 40, 60, 110]), 45.0)backslash-newlineassert sontpython-underscoreproches(moyenne([1, 3]), 2.0)backslash-newlineassert sontpython-underscoreproches(moyenne([44, 51, 12, 72, 65, 34]), 46.333333333333336)backslash-newlinebackslash-newline def sontpython-underscoreproches(x, y):backslash-newline return abs(x - y) < 10python-starpython-star-6backslash-newlinebackslash-newlinedef moyenne(tableau):backslash-newline n = len(tableau)backslash-newline somme = 0backslash-newline for valeur in tableau:backslash-newline somme += valeurbackslash-newline return somme / nbackslash-newlinebackslash-newline A Z","title":"Moyenne simple"},{"location":"1-facile/1300-rendu_monnaie_3p/exo_REM/","text":"Commentaires \u2693\ufe0e Premi\u00e8re version \u2693\ufe0e \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 = somme_a_rendre // 5 somme_a_rendre -= 5 * n_5 n_2 = somme_a_rendre // 2 somme_a_rendre -= 2 * n_2 n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 ) Version, avec divmod \u2693\ufe0e La fonction divmod renvoie le quotient et le reste d'une division enti\u00e8re. \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 , somme_a_rendre = divmod ( somme_a_rendre , 5 ) n_2 , somme_a_rendre = divmod ( somme_a_rendre , 2 ) n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 ) Version avec une boucle \u2693\ufe0e \ud83d\udc0d Script Python VALEURS = ( 5 , 2 , 1 ) def rendu ( somme_a_rendre ): resultat = [ 0 , 0 , 0 ] for i in range ( 3 ): resultat [ i ], somme_a_rendre = divmod ( somme_a_rendre , VALEURS [ i ]) return tuple ( retour ) Cette derni\u00e8re version est utile si on envisage un autre syst\u00e8me de pi\u00e8ces avec de nombreuses valeurs.","title":"Commentaires"},{"location":"1-facile/1300-rendu_monnaie_3p/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1300-rendu_monnaie_3p/exo_REM/#premiere-version","text":"\ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 = somme_a_rendre // 5 somme_a_rendre -= 5 * n_5 n_2 = somme_a_rendre // 2 somme_a_rendre -= 2 * n_2 n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 )","title":"Premi\u00e8re version"},{"location":"1-facile/1300-rendu_monnaie_3p/exo_REM/#version-avec-divmod","text":"La fonction divmod renvoie le quotient et le reste d'une division enti\u00e8re. \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 , somme_a_rendre = divmod ( somme_a_rendre , 5 ) n_2 , somme_a_rendre = divmod ( somme_a_rendre , 2 ) n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 )","title":"Version, avec divmod"},{"location":"1-facile/1300-rendu_monnaie_3p/exo_REM/#version-avec-une-boucle","text":"\ud83d\udc0d Script Python VALEURS = ( 5 , 2 , 1 ) def rendu ( somme_a_rendre ): resultat = [ 0 , 0 , 0 ] for i in range ( 3 ): resultat [ i ], somme_a_rendre = divmod ( somme_a_rendre , VALEURS [ i ]) return tuple ( retour ) Cette derni\u00e8re version est utile si on envisage un autre syst\u00e8me de pi\u00e8ces avec de nombreuses valeurs.","title":"Version avec une boucle"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/","tags":["maths"],"text":"Rendu de monnaie avec 3 types de pi\u00e8ces \u2693\ufe0e On s'int\u00e9resse au probl\u00e8me du rendu d'une quantit\u00e9 somme_a_rendre de monnaie. On suppose qu'on dispose d'un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d'\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif somme_a_rendre qui renvoie un tuple de trois entiers qui correspondent aux nombres de billets de 5 euros de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euro. Exemples Pour rendre 7 \u20ac, on rend 1 billet de 5 \u20ac, 1 pi\u00e8ce de 2 \u20ac et 0 pi\u00e8ce de 1 \u20ac. \ud83d\udc0d Console Python >>> rendu ( 7 ) (1, 1, 0) Pour rendre 10 \u20ac, on rend 2 billets de 5 \u20ac. Pour rendre 13 \u20ac, on rend 2 billets de 5 \u20ac, une pi\u00e8ce de 2 \u20ac et une pi\u00e8ce de 1 \u20ac. Pour rendre 32 \u20ac, on rend 6 billets de 5 \u20ac et une pi\u00e8ce de 2 \u20ac. \ud83d\udc0d Console Python >>> rendu ( 10 ) (2, 0, 0) >>> rendu ( 13 ) (2, 1, 1) >>> rendu ( 32 ) (6, 1, 0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef RENDU(sommepython-underscoreapython-underscorerendre):backslash-newline npython-underscore5 = sommepython-underscoreapython-underscorerendre // 5backslash-newline sommepython-underscoreapython-underscorerendre -= 5 python-star npython-underscore5backslash-newlinebackslash-newline npython-underscore2 = sommepython-underscoreapython-underscorerendre // 2backslash-newline sommepython-underscoreapython-underscorerendre -= 2 python-star npython-underscore2backslash-newlinebackslash-newline npython-underscore1 = sommepython-underscoreapython-underscorerendrebackslash-newline backslash-newline return (npython-underscore5, npython-underscore2, npython-underscore1)backslash-newlinebackslash-newlinefor sommepython-underscoreapython-underscorerendre in range(50):backslash-newline attendu = RENDU(sommepython-underscoreapython-underscorerendre)backslash-newline assert tuple(rendu(sommepython-underscoreapython-underscorerendre)) == attendu, f\"Erreur avec le rendu de {sommepython-underscoreapython-underscorerendre}\"backslash-newlinebackslash-newline Valider 5/5 def rendu(sommepython-underscoreapython-underscorerendre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newline def rendu(sommepython-underscoreapython-underscorerendre):backslash-newline npython-underscore5 = sommepython-underscoreapython-underscorerendre // 5backslash-newline sommepython-underscoreapython-underscorerendre -= 5 python-star npython-underscore5backslash-newlinebackslash-newline npython-underscore2 = sommepython-underscoreapython-underscorerendre // 2backslash-newline sommepython-underscoreapython-underscorerendre -= 2 python-star npython-underscore2backslash-newlinebackslash-newline npython-underscore1 = sommepython-underscoreapython-underscorerendrebackslash-newline backslash-newline return (npython-underscore5, npython-underscore2, npython-underscore1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Premi\u00e8re version \u2693\ufe0e \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 = somme_a_rendre // 5 somme_a_rendre -= 5 * n_5 n_2 = somme_a_rendre // 2 somme_a_rendre -= 2 * n_2 n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 ) Version, avec divmod \u2693\ufe0e La fonction divmod renvoie le quotient et le reste d'une division enti\u00e8re. \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 , somme_a_rendre = divmod ( somme_a_rendre , 5 ) n_2 , somme_a_rendre = divmod ( somme_a_rendre , 2 ) n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 ) Version avec une boucle \u2693\ufe0e \ud83d\udc0d Script Python VALEURS = ( 5 , 2 , 1 ) def rendu ( somme_a_rendre ): resultat = [ 0 , 0 , 0 ] for i in range ( 3 ): resultat [ i ], somme_a_rendre = divmod ( somme_a_rendre , VALEURS [ i ]) return tuple ( retour ) Cette derni\u00e8re version est utile si on envisage un autre syst\u00e8me de pi\u00e8ces avec de nombreuses valeurs. Z","title":"Rendu de monnaie"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/#rendu-de-monnaie-avec-3-types-de-pieces","text":"On s'int\u00e9resse au probl\u00e8me du rendu d'une quantit\u00e9 somme_a_rendre de monnaie. On suppose qu'on dispose d'un nombre infini de billets de 5 euros, de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro. Le but est d'\u00e9crire une fonction nomm\u00e9e rendu dont le param\u00e8tre est un entier positif somme_a_rendre qui renvoie un tuple de trois entiers qui correspondent aux nombres de billets de 5 euros de pi\u00e8ces de 2 euros et de pi\u00e8ces de 1 euro \u00e0 rendre afin que le total rendu soit \u00e9gal \u00e0 somme_a_rendre . On commencera par rendre le nombre maximal de billets de 5 euros, puis celui des pi\u00e8ces de 2 euros et enfin celui des pi\u00e8ces de 1 euro. Exemples Pour rendre 7 \u20ac, on rend 1 billet de 5 \u20ac, 1 pi\u00e8ce de 2 \u20ac et 0 pi\u00e8ce de 1 \u20ac. \ud83d\udc0d Console Python >>> rendu ( 7 ) (1, 1, 0) Pour rendre 10 \u20ac, on rend 2 billets de 5 \u20ac. Pour rendre 13 \u20ac, on rend 2 billets de 5 \u20ac, une pi\u00e8ce de 2 \u20ac et une pi\u00e8ce de 1 \u20ac. Pour rendre 32 \u20ac, on rend 6 billets de 5 \u20ac et une pi\u00e8ce de 2 \u20ac. \ud83d\udc0d Console Python >>> rendu ( 10 ) (2, 0, 0) >>> rendu ( 13 ) (2, 1, 1) >>> rendu ( 32 ) (6, 1, 0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef RENDU(sommepython-underscoreapython-underscorerendre):backslash-newline npython-underscore5 = sommepython-underscoreapython-underscorerendre // 5backslash-newline sommepython-underscoreapython-underscorerendre -= 5 python-star npython-underscore5backslash-newlinebackslash-newline npython-underscore2 = sommepython-underscoreapython-underscorerendre // 2backslash-newline sommepython-underscoreapython-underscorerendre -= 2 python-star npython-underscore2backslash-newlinebackslash-newline npython-underscore1 = sommepython-underscoreapython-underscorerendrebackslash-newline backslash-newline return (npython-underscore5, npython-underscore2, npython-underscore1)backslash-newlinebackslash-newlinefor sommepython-underscoreapython-underscorerendre in range(50):backslash-newline attendu = RENDU(sommepython-underscoreapython-underscorerendre)backslash-newline assert tuple(rendu(sommepython-underscoreapython-underscorerendre)) == attendu, f\"Erreur avec le rendu de {sommepython-underscoreapython-underscorerendre}\"backslash-newlinebackslash-newline Valider 5/5 def rendu(sommepython-underscoreapython-underscorerendre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newline def rendu(sommepython-underscoreapython-underscorerendre):backslash-newline npython-underscore5 = sommepython-underscoreapython-underscorerendre // 5backslash-newline sommepython-underscoreapython-underscorerendre -= 5 python-star npython-underscore5backslash-newlinebackslash-newline npython-underscore2 = sommepython-underscoreapython-underscorerendre // 2backslash-newline sommepython-underscoreapython-underscorerendre -= 2 python-star npython-underscore2backslash-newlinebackslash-newline npython-underscore1 = sommepython-underscoreapython-underscorerendrebackslash-newline backslash-newline return (npython-underscore5, npython-underscore2, npython-underscore1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert tuple(rendu( 7)) == (1, 1, 0)backslash-newlineassert tuple(rendu(10)) == (2, 0, 0)backslash-newlineassert tuple(rendu(13)) == (2, 1, 1)backslash-newlineassert tuple(rendu(32)) == (6, 1, 0)backslash-newlinebackslash-newline A","title":"Rendu de monnaie avec 3 types de pi\u00e8ces"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/#premiere-version","text":"\ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 = somme_a_rendre // 5 somme_a_rendre -= 5 * n_5 n_2 = somme_a_rendre // 2 somme_a_rendre -= 2 * n_2 n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 )","title":"Premi\u00e8re version"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/#version-avec-divmod","text":"La fonction divmod renvoie le quotient et le reste d'une division enti\u00e8re. \ud83d\udc0d Script Python def rendu ( somme_a_rendre ): n_5 , somme_a_rendre = divmod ( somme_a_rendre , 5 ) n_2 , somme_a_rendre = divmod ( somme_a_rendre , 2 ) n_1 = somme_a_rendre return ( n_5 , n_2 , n_1 )","title":"Version, avec divmod"},{"location":"1-facile/1300-rendu_monnaie_3p/sujet/#version-avec-une-boucle","text":"\ud83d\udc0d Script Python VALEURS = ( 5 , 2 , 1 ) def rendu ( somme_a_rendre ): resultat = [ 0 , 0 , 0 ] for i in range ( 3 ): resultat [ i ], somme_a_rendre = divmod ( somme_a_rendre , VALEURS [ i ]) return tuple ( retour ) Cette derni\u00e8re version est utile si on envisage un autre syst\u00e8me de pi\u00e8ces avec de nombreuses valeurs. Z","title":"Version avec une boucle"},{"location":"1-facile/1350-ecretage/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def limite_amplitude ( x , x_min , x_max ): if x < x_min : return x_min elif x > x_max : return x_max else : return x La fonction limite_amplitude est compos\u00e9e d'une structure conditionnelle, avec trois cas. La fonction ecrete construit une liste vide qu'elle \u00e9tend par accumulation. On aurait pu faire une liste en compr\u00e9hension avec le code : \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): return [ limite_amplitude ( x , x_min , x_max ) for x in valeurs ] Pour les experts On peut avoir aussi un code avec un style fonctionnel \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): filtre = lambda x : limite_amplitude ( x , x_min , x_max ) return list ( map ( filtre , valeurs )) filtre est une fonction qui pourrait aussi \u00eatre d\u00e9finie par \ud83d\udc0d Script Python def filtre ( x ): return limite_amplitude ( x , x_min , x_max ) Le constructeur lambda permet de d\u00e9finir une fonction anonyme, c'est parfois utile comme param\u00e8tre pass\u00e9 \u00e0 une autre fonction.","title":"Commentaires"},{"location":"1-facile/1350-ecretage/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def limite_amplitude ( x , x_min , x_max ): if x < x_min : return x_min elif x > x_max : return x_max else : return x La fonction limite_amplitude est compos\u00e9e d'une structure conditionnelle, avec trois cas. La fonction ecrete construit une liste vide qu'elle \u00e9tend par accumulation. On aurait pu faire une liste en compr\u00e9hension avec le code : \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): return [ limite_amplitude ( x , x_min , x_max ) for x in valeurs ] Pour les experts On peut avoir aussi un code avec un style fonctionnel \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): filtre = lambda x : limite_amplitude ( x , x_min , x_max ) return list ( map ( filtre , valeurs )) filtre est une fonction qui pourrait aussi \u00eatre d\u00e9finie par \ud83d\udc0d Script Python def filtre ( x ): return limite_amplitude ( x , x_min , x_max ) Le constructeur lambda permet de d\u00e9finir une fonction anonyme, c'est parfois utile comme param\u00e8tre pass\u00e9 \u00e0 une autre fonction.","title":"Commentaires"},{"location":"1-facile/1350-ecretage/sujet/","tags":["boucle"],"text":"\u00c9cr\u00eatage des valeurs d'un tableau \u2693\ufe0e L'\u00e9cr\u00eatage d'un signal consiste \u00e0 limiter l'amplitude du signal entre deux valeurs x_min et x_max . On peut \u00e9galement appliquer cela aux valeurs d'un tableau. Voici par exemple un tableau valeurs que l'on a \u00e9cr\u00eat\u00e9 entre \\(-150\\) et \\(150\\) pour donner le tableau valeurs_ecretees : \ud83d\udc0d Script Python valeurs = [ 34 , 56 , 89 , 134 , 152 , 250 , 87 , - 34 , - 187 , - 310 ] valeurs_ecretees = [ 34 , 56 , 89 , 134 , 150 , 150 , 87 , - 34 , - 150 , - 150 ] Question 1 : Compl\u00e9ter une fonction limite_amplitude qui prend en param\u00e8tre un nombre x ainsi que deux nombres x_min et x_max avec x_min <= x_max et qui renvoie : x si x est compris entre x_min et x_max , x_min si x est plus petit que x_min , x_max si x est plus grand que x_max . Exemple \ud83d\udc0d Console Python >>> limite_amplitude ( 34 , - 150 , 150 ) 34 >>> limite_amplitude ( - 187 , - 150 , 150 ) -150 Question 2 : Compl\u00e9ter la fonction ecrete ci-dessous qui prend en param\u00e8tre un tableau de valeurs ainsi que x_min et x_max avec x_min <= x_max et renvoie un tableau des valeurs \u00e9cr\u00eat\u00e9es entre x_min et x_max . Exemple \ud83d\udc0d Console Python >>> valeurs = [ 34 , 56 , 89 , 134 , 152 , 250 , 87 , - 34 , - 187 , - 310 ] >>> ecrete ( valeurs , - 150 , 150 ) [34, 56, 89, 134, 150, 150, 87, -34, -150, -150] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newline# Question 1 :backslash-newlinebackslash-newlineassert limitepython-underscoreamplitude(-15, -10, 10) == -10, \"-15 est trop petit (pas entre -10 et 10), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlineassert limitepython-underscoreamplitude(-10, -10, 10) == -10backslash-newlineassert limitepython-underscoreamplitude( -8, -10, 10) == -8backslash-newlineassert limitepython-underscoreamplitude( 7, -10, 10) == 7backslash-newlineassert limitepython-underscoreamplitude( 10, -10, 10) == 10backslash-newlineassert limitepython-underscoreamplitude( 18, -10, 10) == 10, \"18 est trop grand (pas entre -10 et 10), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlinebackslash-newlineassert limitepython-underscoreamplitude(209, 210, 220) == 210, \"209 est trop petit (pas entre 210 et 220), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlineassert limitepython-underscoreamplitude(210, 210, 220) == 210backslash-newlineassert limitepython-underscoreamplitude(215, 210, 220) == 215backslash-newlineassert limitepython-underscoreamplitude(220, 210, 220) == 220backslash-newlineassert limitepython-underscoreamplitude(221, 210, 220) == 220, \"221 est trop grand (pas entre 210 et 220), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlinebackslash-newlinebackslash-newline# Question 2 :backslash-newlinebackslash-newlinevaleurs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]backslash-newlineattendu = [5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 10, 10, 10]backslash-newlineresultat = ecrete(valeurs, 5, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = [-13, -4, 6, 5, 8, -3, -12, -3, 0, 6, 7]backslash-newlineattendu = [-10, -5, -5, -5, -5, -5, -10, -5, -5, -5, -5]backslash-newlineresultat = ecrete(valeurs, -10, -5)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = [7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5]backslash-newlineattendu = [7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5]backslash-newlineresultat = ecrete(valeurs, 0, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = []backslash-newlineattendu = []backslash-newlineresultat = ecrete(valeurs, 0, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newline Valider 5/5 def limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax):backslash-newline ...backslash-newlinebackslash-newlinedef ecrete(valeurs, xpython-underscoremin, xpython-underscoremax):backslash-newline valeurspython-underscoreecretees = ...backslash-newline for ...:backslash-newline y = limitepython-underscoreamplitude(...)backslash-newline valeurspython-underscoreecretees.append(...)backslash-newline return valeurspython-underscoreecreteesbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline def limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax):backslash-newline if x < xpython-underscoremin:backslash-newline return xpython-underscoreminbackslash-newline elif x > xpython-underscoremax :backslash-newline return xpython-underscoremaxbackslash-newline else:backslash-newline return xbackslash-newlinebackslash-newlinedef ecrete(valeurs, xpython-underscoremin, xpython-underscoremax):backslash-newline valeurspython-underscoreecretees = []backslash-newline for x in valeurs:backslash-newline y = limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax)backslash-newline valeurspython-underscoreecretees.append(y)backslash-newline return valeurspython-underscoreecreteesbackslash-newlinebackslash-newline# testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} La fonction limite_amplitude est compos\u00e9e d'une structure conditionnelle, avec trois cas. La fonction ecrete construit une liste vide qu'elle \u00e9tend par accumulation. On aurait pu faire une liste en compr\u00e9hension avec le code : \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): return [ limite_amplitude ( x , x_min , x_max ) for x in valeurs ] Pour les experts On peut avoir aussi un code avec un style fonctionnel \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): filtre = lambda x : limite_amplitude ( x , x_min , x_max ) return list ( map ( filtre , valeurs )) filtre est une fonction qui pourrait aussi \u00eatre d\u00e9finie par \ud83d\udc0d Script Python def filtre ( x ): return limite_amplitude ( x , x_min , x_max ) Le constructeur lambda permet de d\u00e9finir une fonction anonyme, c'est parfois utile comme param\u00e8tre pass\u00e9 \u00e0 une autre fonction. Z","title":"\u00c9cr\u00eatage"},{"location":"1-facile/1350-ecretage/sujet/#ecretage-des-valeurs-dun-tableau","text":"L'\u00e9cr\u00eatage d'un signal consiste \u00e0 limiter l'amplitude du signal entre deux valeurs x_min et x_max . On peut \u00e9galement appliquer cela aux valeurs d'un tableau. Voici par exemple un tableau valeurs que l'on a \u00e9cr\u00eat\u00e9 entre \\(-150\\) et \\(150\\) pour donner le tableau valeurs_ecretees : \ud83d\udc0d Script Python valeurs = [ 34 , 56 , 89 , 134 , 152 , 250 , 87 , - 34 , - 187 , - 310 ] valeurs_ecretees = [ 34 , 56 , 89 , 134 , 150 , 150 , 87 , - 34 , - 150 , - 150 ] Question 1 : Compl\u00e9ter une fonction limite_amplitude qui prend en param\u00e8tre un nombre x ainsi que deux nombres x_min et x_max avec x_min <= x_max et qui renvoie : x si x est compris entre x_min et x_max , x_min si x est plus petit que x_min , x_max si x est plus grand que x_max . Exemple \ud83d\udc0d Console Python >>> limite_amplitude ( 34 , - 150 , 150 ) 34 >>> limite_amplitude ( - 187 , - 150 , 150 ) -150 Question 2 : Compl\u00e9ter la fonction ecrete ci-dessous qui prend en param\u00e8tre un tableau de valeurs ainsi que x_min et x_max avec x_min <= x_max et renvoie un tableau des valeurs \u00e9cr\u00eat\u00e9es entre x_min et x_max . Exemple \ud83d\udc0d Console Python >>> valeurs = [ 34 , 56 , 89 , 134 , 152 , 250 , 87 , - 34 , - 187 , - 310 ] >>> ecrete ( valeurs , - 150 , 150 ) [34, 56, 89, 134, 150, 150, 87, -34, -150, -150] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newline# Question 1 :backslash-newlinebackslash-newlineassert limitepython-underscoreamplitude(-15, -10, 10) == -10, \"-15 est trop petit (pas entre -10 et 10), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlineassert limitepython-underscoreamplitude(-10, -10, 10) == -10backslash-newlineassert limitepython-underscoreamplitude( -8, -10, 10) == -8backslash-newlineassert limitepython-underscoreamplitude( 7, -10, 10) == 7backslash-newlineassert limitepython-underscoreamplitude( 10, -10, 10) == 10backslash-newlineassert limitepython-underscoreamplitude( 18, -10, 10) == 10, \"18 est trop grand (pas entre -10 et 10), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlinebackslash-newlineassert limitepython-underscoreamplitude(209, 210, 220) == 210, \"209 est trop petit (pas entre 210 et 220), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlineassert limitepython-underscoreamplitude(210, 210, 220) == 210backslash-newlineassert limitepython-underscoreamplitude(215, 210, 220) == 215backslash-newlineassert limitepython-underscoreamplitude(220, 210, 220) == 220backslash-newlineassert limitepython-underscoreamplitude(221, 210, 220) == 220, \"221 est trop grand (pas entre 210 et 220), on \u00c3\u00a9cr\u00c3\u00aate\"backslash-newlinebackslash-newlinebackslash-newline# Question 2 :backslash-newlinebackslash-newlinevaleurs = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]backslash-newlineattendu = [5, 5, 5, 5, 5, 5, 6, 7, 8, 9, 10, 10, 10, 10]backslash-newlineresultat = ecrete(valeurs, 5, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = [-13, -4, 6, 5, 8, -3, -12, -3, 0, 6, 7]backslash-newlineattendu = [-10, -5, -5, -5, -5, -5, -10, -5, -5, -5, -5]backslash-newlineresultat = ecrete(valeurs, -10, -5)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = [7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5]backslash-newlineattendu = [7, 8, 3, 9, 8, 7, 2, 4, 8, 9, 0, 1, 5, 8, 8, 8, 4, 5, 4, 5]backslash-newlineresultat = ecrete(valeurs, 0, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newlinevaleurs = []backslash-newlineattendu = []backslash-newlineresultat = ecrete(valeurs, 0, 10)backslash-newlineassert resultat == attendu, f\"Erreur avec {valeurs}\"backslash-newlinebackslash-newline Valider 5/5 def limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax):backslash-newline ...backslash-newlinebackslash-newlinedef ecrete(valeurs, xpython-underscoremin, xpython-underscoremax):backslash-newline valeurspython-underscoreecretees = ...backslash-newline for ...:backslash-newline y = limitepython-underscoreamplitude(...)backslash-newline valeurspython-underscoreecretees.append(...)backslash-newline return valeurspython-underscoreecreteesbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline def limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax):backslash-newline if x < xpython-underscoremin:backslash-newline return xpython-underscoreminbackslash-newline elif x > xpython-underscoremax :backslash-newline return xpython-underscoremaxbackslash-newline else:backslash-newline return xbackslash-newlinebackslash-newlinedef ecrete(valeurs, xpython-underscoremin, xpython-underscoremax):backslash-newline valeurspython-underscoreecretees = []backslash-newline for x in valeurs:backslash-newline y = limitepython-underscoreamplitude(x, xpython-underscoremin, xpython-underscoremax)backslash-newline valeurspython-underscoreecretees.append(y)backslash-newline return valeurspython-underscoreecreteesbackslash-newlinebackslash-newline# testsbackslash-newlinevaleurs = [34, 56, 89, 134, 152, 250, 87, -34, -187, -310]backslash-newlineattendu = [34, 56, 89, 134, 150, 150, 87, -34, -150, -150]backslash-newlineresultat = ecrete(valeurs, -150, 150)backslash-newlineassert attendu == resultat, f\"Erreur avec ecrete({valeurs})\"backslash-newlinebackslash-newline A","title":"\u00c9cr\u00eatage des valeurs d'un tableau"},{"location":"1-facile/1350-ecretage/sujet/#commentaires","text":"{{ py('exo_corr') }} La fonction limite_amplitude est compos\u00e9e d'une structure conditionnelle, avec trois cas. La fonction ecrete construit une liste vide qu'elle \u00e9tend par accumulation. On aurait pu faire une liste en compr\u00e9hension avec le code : \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): return [ limite_amplitude ( x , x_min , x_max ) for x in valeurs ] Pour les experts On peut avoir aussi un code avec un style fonctionnel \ud83d\udc0d Script Python def ecrete ( valeurs , x_min , x_max ): filtre = lambda x : limite_amplitude ( x , x_min , x_max ) return list ( map ( filtre , valeurs )) filtre est une fonction qui pourrait aussi \u00eatre d\u00e9finie par \ud83d\udc0d Script Python def filtre ( x ): return limite_amplitude ( x , x_min , x_max ) Le constructeur lambda permet de d\u00e9finir une fonction anonyme, c'est parfois utile comme param\u00e8tre pass\u00e9 \u00e0 une autre fonction. Z","title":"Commentaires"},{"location":"1-facile/1375-palindrome/sujet/","tags":["boucle","string"],"text":"Cr\u00e9ation de palindrome \u2693\ufe0e Un palindrome est un mot qui se lit lettre par lettre, de gauche \u00e0 droite, exactement comme de droite \u00e0 gauche. Exemples \"kayak\" , \"radar\" , \"rdtxtdr\" sont des palindromes de longueur impaire. \"elle\" , \"serres\" , \"afeefa\" sont des palindromes de longueur paire. On peut construire un palindrome \u00e0 partir d'une chaine de caract\u00e8res et d'un autre palindrome , en concat\u00e9nant la chaine, le palindrome et la chaine renvers\u00e9e. \"kayak\" peut s'obtenir avec \"ka\", \"y\", \"ak\" \"radar\" peut s'obtenir avec \"r\", \"ada\", \"r\" \"rdtxtdr\" peut s'obtenir avec \"rd\", \"txt\", \"dr\" \"elle\" peut s'obtenir avec \"e\", \"ll\", \"e\" \"serres\" peut s'obtenir avec \"ser\", \"\", \"res\" \"arfettttefra\" peut s'obtenir avec \"ar\", \"fettttef\", \"ra\" \u00c9crire une fonction cree_palindrome qui prend deux param\u00e8tres : une chaine de caract\u00e8res mot et une chaine de caract\u00e8res qui sera palindrome . La fonction renvoie le palindrome cr\u00e9\u00e9 en concat\u00e9nant mot , palindrome , et le renversement de mot . Exemples \ud83d\udc0d Console Python >>> cree_palindrome ( \"ka\" , \"y\" ) 'kayak' >>> cree_palindrome ( \"ser\" , \"\" ) 'serres' >>> cree_palindrome ( \"r\" , \"ada\" ) 'radar' >>> cree_palindrome ( \"ar\" , \"fettttef\" ) 'arfettttefra' On n'utilisera pas les tranches de chaines de caract\u00e8res ! On garantit que palindrome est bien un palindrome, il sera inutile de le v\u00e9rifier. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"\", \"\") == ''backslash-newlineassert creepython-underscorepalindrome(\"\", \"a\") == 'a'backslash-newlineassert creepython-underscorepalindrome(\"a\", \"\") == 'aa'backslash-newlineassert creepython-underscorepalindrome(\"abcd\", \"tyuuyt\") == 'abcdtyuuytdcba'backslash-newlineassert creepython-underscorepalindrome(\"abcde\", \"tyuzuyt\") == 'abcdetyuzuytedcba'backslash-newlinebackslash-newline Valider 5/5 def creepython-underscorepalindrome(mot, palindrome):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newline def creepython-underscorepalindrome(mot, palindrome):backslash-newline sortie = mot + palindromebackslash-newline l = len(mot)backslash-newline for i in range(l):backslash-newline sortie += mot[l - 1 - i]backslash-newline return sortiebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Palindrome"},{"location":"1-facile/1375-palindrome/sujet/#creation-de-palindrome","text":"Un palindrome est un mot qui se lit lettre par lettre, de gauche \u00e0 droite, exactement comme de droite \u00e0 gauche. Exemples \"kayak\" , \"radar\" , \"rdtxtdr\" sont des palindromes de longueur impaire. \"elle\" , \"serres\" , \"afeefa\" sont des palindromes de longueur paire. On peut construire un palindrome \u00e0 partir d'une chaine de caract\u00e8res et d'un autre palindrome , en concat\u00e9nant la chaine, le palindrome et la chaine renvers\u00e9e. \"kayak\" peut s'obtenir avec \"ka\", \"y\", \"ak\" \"radar\" peut s'obtenir avec \"r\", \"ada\", \"r\" \"rdtxtdr\" peut s'obtenir avec \"rd\", \"txt\", \"dr\" \"elle\" peut s'obtenir avec \"e\", \"ll\", \"e\" \"serres\" peut s'obtenir avec \"ser\", \"\", \"res\" \"arfettttefra\" peut s'obtenir avec \"ar\", \"fettttef\", \"ra\" \u00c9crire une fonction cree_palindrome qui prend deux param\u00e8tres : une chaine de caract\u00e8res mot et une chaine de caract\u00e8res qui sera palindrome . La fonction renvoie le palindrome cr\u00e9\u00e9 en concat\u00e9nant mot , palindrome , et le renversement de mot . Exemples \ud83d\udc0d Console Python >>> cree_palindrome ( \"ka\" , \"y\" ) 'kayak' >>> cree_palindrome ( \"ser\" , \"\" ) 'serres' >>> cree_palindrome ( \"r\" , \"ada\" ) 'radar' >>> cree_palindrome ( \"ar\" , \"fettttef\" ) 'arfettttefra' On n'utilisera pas les tranches de chaines de caract\u00e8res ! On garantit que palindrome est bien un palindrome, il sera inutile de le v\u00e9rifier. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"\", \"\") == ''backslash-newlineassert creepython-underscorepalindrome(\"\", \"a\") == 'a'backslash-newlineassert creepython-underscorepalindrome(\"a\", \"\") == 'aa'backslash-newlineassert creepython-underscorepalindrome(\"abcd\", \"tyuuyt\") == 'abcdtyuuytdcba'backslash-newlineassert creepython-underscorepalindrome(\"abcde\", \"tyuzuyt\") == 'abcdetyuzuytedcba'backslash-newlinebackslash-newline Valider 5/5 def creepython-underscorepalindrome(mot, palindrome):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newline def creepython-underscorepalindrome(mot, palindrome):backslash-newline sortie = mot + palindromebackslash-newline l = len(mot)backslash-newline for i in range(l):backslash-newline sortie += mot[l - 1 - i]backslash-newline return sortiebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert creepython-underscorepalindrome(\"ka\", \"y\") == 'kayak'backslash-newlineassert creepython-underscorepalindrome(\"ser\", \"\") == 'serres'backslash-newlineassert creepython-underscorepalindrome(\"r\", \"ada\") == 'radar'backslash-newlineassert creepython-underscorepalindrome(\"ar\", \"fettttef\") == 'arfettttefra'backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Cr\u00e9ation de palindrome"},{"location":"1-facile/1375-split/exo_REM/","text":"Commentaires \u2693\ufe0e Une solution possible \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline mot = \"\"backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline mot += caracterebackslash-newline else:backslash-newline if len(mot) >= 4:backslash-newline mots.append(mot)backslash-newline mot = \"\"backslash-newline return motsbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newline A Z Version fonctionnelle \u2693\ufe0e Dans un style fonctionnel, on utilise split (mais c'\u00e9tait interdit justement pour cet exercice). Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline return [mot for mot in discours.split() if len(mot) >= 4]backslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineprint(decoupepython-underscoremots(discours))backslash-newlinebackslash-newline A Z Remarque discours.split(\" \") coupe discours uniquement aux espaces. discours.split() coupe discours aux espaces, sauts de ligne, tabulations. Version avec join \u2693\ufe0e Ici, la boucle pour construire un mot est courte ; dans le pire des cas on a des mots d'une vingtaine de lettres. Mais dans d'autres situations , de longues boucles avec ajout de caract\u00e8res dans une chaine de plus en plus grande, la chaine est recopi\u00e9e int\u00e9gralement \u00e0 chaque tour (c'est un objet immuable). On aimerait \u00e9viter la recopie enti\u00e8re du d\u00e9but de la chaine. Pour cela, on cr\u00e9e une liste vide, dans laquelle on ajoute tous les morceaux \u00e0 chaque tour de boucle. Il n'y a pas de copie. \u00c0 la fin, on colle les morceaux avec join . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline lettres = list()backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline lettres.append(caractere)backslash-newline else:backslash-newline if len(lettres) >= 4:backslash-newline mots.append(\"\".join(lettres))backslash-newline lettres = list()backslash-newline return motsbackslash-newlinebackslash-newline A Z Cette version est th\u00e9oriquement meilleure, elle serait tr\u00e8s utile dans un autre cadre.","title":"Commentaires"},{"location":"1-facile/1375-split/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1375-split/exo_REM/#une-solution-possible","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline mot = \"\"backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline mot += caracterebackslash-newline else:backslash-newline if len(mot) >= 4:backslash-newline mots.append(mot)backslash-newline mot = \"\"backslash-newline return motsbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newline A Z","title":"Une solution possible"},{"location":"1-facile/1375-split/exo_REM/#version-fonctionnelle","text":"Dans un style fonctionnel, on utilise split (mais c'\u00e9tait interdit justement pour cet exercice). Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline return [mot for mot in discours.split() if len(mot) >= 4]backslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineprint(decoupepython-underscoremots(discours))backslash-newlinebackslash-newline A Z Remarque discours.split(\" \") coupe discours uniquement aux espaces. discours.split() coupe discours aux espaces, sauts de ligne, tabulations.","title":"Version fonctionnelle"},{"location":"1-facile/1375-split/exo_REM/#version-avec-join","text":"Ici, la boucle pour construire un mot est courte ; dans le pire des cas on a des mots d'une vingtaine de lettres. Mais dans d'autres situations , de longues boucles avec ajout de caract\u00e8res dans une chaine de plus en plus grande, la chaine est recopi\u00e9e int\u00e9gralement \u00e0 chaque tour (c'est un objet immuable). On aimerait \u00e9viter la recopie enti\u00e8re du d\u00e9but de la chaine. Pour cela, on cr\u00e9e une liste vide, dans laquelle on ajoute tous les morceaux \u00e0 chaque tour de boucle. Il n'y a pas de copie. \u00c0 la fin, on colle les morceaux avec join . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline lettres = list()backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline lettres.append(caractere)backslash-newline else:backslash-newline if len(lettres) >= 4:backslash-newline mots.append(\"\".join(lettres))backslash-newline lettres = list()backslash-newline return motsbackslash-newlinebackslash-newline A Z Cette version est th\u00e9oriquement meilleure, elle serait tr\u00e8s utile dans un autre cadre.","title":"Version avec join"},{"location":"1-facile/1375-split/sujet/","tags":["boucle","string"],"text":"D\u00e9coupage de mots \u2693\ufe0e Pour analyser automatiquement les d\u00e9bats entre des orateurs, on vous demande de cr\u00e9er une fonction decoupe_mots qui renvoie la liste des mots de 4 lettres ou plus dans une chaine de caract\u00e8res discours pass\u00e9e en param\u00e8tre. On suppose que la chaine discours a \u00e9t\u00e9 renvoy\u00e9e par une fonction de reconnaissance vocale qui ignore la ponctuation et ne renvoie que des lettres minuscules sans accent ainsi que des espaces. Le discours se termine aussi par une espace. On n'utilisera pas la fonction split dans cet exercice. Exemples \ud83d\udc0d Console Python >>> discours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \" >>> decoupe_mots ( discours ) ['peux', 'vous', 'dire', 'aujourd', 'amis', 'depit', 'difficultes', 'frustrations', 'actuelles', 'quand', 'meme', 'fait', 'reve', 'reve', 'profondement', 'enracine', 'dans', 'reve', 'americain'] \ud83d\udc0d Console Python >>> test_2 = \"abcd azerty xyz azerty \" >>> decoupe_mots ( test_2 ) ['abcd', 'azerty', 'azerty'] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newlinebackslash-newlineassert decoupepython-underscoremots(\"\") == []backslash-newlineassert decoupepython-underscoremots(\" \") == []backslash-newlineassert decoupepython-underscoremots(\"a b c d \") == []backslash-newlineassert decoupepython-underscoremots(\"a bc def ghij \") == [\"ghij\"]backslash-newlineassert decoupepython-underscoremots(\"abcd efg hi j \") == [\"abcd\"]backslash-newlineassert decoupepython-underscoremots(\" abcd abcd \") == [\"abcd\", \"abcd\"]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def decoupepython-underscoremots(discours):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newlinebackslash-newline def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline mot = \"\"backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline mot += caracterebackslash-newline else:backslash-newline if len(mot) >= 4:backslash-newline mots.append(mot)backslash-newline mot = \"\"backslash-newline return motsbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Une solution possible \u2693\ufe0e {{ IDE('exo_corr') }} Version fonctionnelle \u2693\ufe0e Dans un style fonctionnel, on utilise split (mais c'\u00e9tait interdit justement pour cet exercice). {{ IDE('exo_var2') }} Remarque discours.split(\" \") coupe discours uniquement aux espaces. discours.split() coupe discours aux espaces, sauts de ligne, tabulations. Version avec join \u2693\ufe0e Ici, la boucle pour construire un mot est courte ; dans le pire des cas on a des mots d'une vingtaine de lettres. Mais dans d'autres situations , de longues boucles avec ajout de caract\u00e8res dans une chaine de plus en plus grande, la chaine est recopi\u00e9e int\u00e9gralement \u00e0 chaque tour (c'est un objet immuable). On aimerait \u00e9viter la recopie enti\u00e8re du d\u00e9but de la chaine. Pour cela, on cr\u00e9e une liste vide, dans laquelle on ajoute tous les morceaux \u00e0 chaque tour de boucle. Il n'y a pas de copie. \u00c0 la fin, on colle les morceaux avec join . {{ IDE('exo_var3') }} Cette version est th\u00e9oriquement meilleure, elle serait tr\u00e8s utile dans un autre cadre. Z","title":"D\u00e9coupe"},{"location":"1-facile/1375-split/sujet/#decoupage-de-mots","text":"Pour analyser automatiquement les d\u00e9bats entre des orateurs, on vous demande de cr\u00e9er une fonction decoupe_mots qui renvoie la liste des mots de 4 lettres ou plus dans une chaine de caract\u00e8res discours pass\u00e9e en param\u00e8tre. On suppose que la chaine discours a \u00e9t\u00e9 renvoy\u00e9e par une fonction de reconnaissance vocale qui ignore la ponctuation et ne renvoie que des lettres minuscules sans accent ainsi que des espaces. Le discours se termine aussi par une espace. On n'utilisera pas la fonction split dans cet exercice. Exemples \ud83d\udc0d Console Python >>> discours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \" >>> decoupe_mots ( discours ) ['peux', 'vous', 'dire', 'aujourd', 'amis', 'depit', 'difficultes', 'frustrations', 'actuelles', 'quand', 'meme', 'fait', 'reve', 'reve', 'profondement', 'enracine', 'dans', 'reve', 'americain'] \ud83d\udc0d Console Python >>> test_2 = \"abcd azerty xyz azerty \" >>> decoupe_mots ( test_2 ) ['abcd', 'azerty', 'azerty'] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newlinebackslash-newlineassert decoupepython-underscoremots(\"\") == []backslash-newlineassert decoupepython-underscoremots(\" \") == []backslash-newlineassert decoupepython-underscoremots(\"a b c d \") == []backslash-newlineassert decoupepython-underscoremots(\"a bc def ghij \") == [\"ghij\"]backslash-newlineassert decoupepython-underscoremots(\"abcd efg hi j \") == [\"abcd\"]backslash-newlineassert decoupepython-underscoremots(\" abcd abcd \") == [\"abcd\", \"abcd\"]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def decoupepython-underscoremots(discours):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newlinebackslash-newline def decoupepython-underscoremots(discours):backslash-newline mots = list()backslash-newline mot = \"\"backslash-newline for caractere in discours:backslash-newline if caractere != \" \":backslash-newline mot += caracterebackslash-newline else:backslash-newline if len(mot) >= 4:backslash-newline mots.append(mot)backslash-newline mot = \"\"backslash-newline return motsbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinediscours = \"je peux vous dire aujourd hui mes amis qu en depit des difficultes et des frustrations actuelles j ai quand meme fait un reve c est un reve profondement enracine dans le reve americain \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(discours) == [backslash-newline 'peux', 'vous', 'dire', 'aujourd', 'amis', 'depit',backslash-newline 'difficultes', 'frustrations', 'actuelles', 'quand',backslash-newline 'meme', 'fait', 'reve', 'reve', 'profondement',backslash-newline 'enracine', 'dans', 'reve', 'americain'backslash-newline]backslash-newlinebackslash-newlinetestpython-underscore2 = \"abcd azerty xyz azerty \"backslash-newlinebackslash-newlineassert decoupepython-underscoremots(testpython-underscore2) == [\"abcd\", \"azerty\", \"azerty\"]backslash-newlinebackslash-newline A","title":"D\u00e9coupage de mots"},{"location":"1-facile/1375-split/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1375-split/sujet/#une-solution-possible","text":"{{ IDE('exo_corr') }}","title":"Une solution possible"},{"location":"1-facile/1375-split/sujet/#version-fonctionnelle","text":"Dans un style fonctionnel, on utilise split (mais c'\u00e9tait interdit justement pour cet exercice). {{ IDE('exo_var2') }} Remarque discours.split(\" \") coupe discours uniquement aux espaces. discours.split() coupe discours aux espaces, sauts de ligne, tabulations.","title":"Version fonctionnelle"},{"location":"1-facile/1375-split/sujet/#version-avec-join","text":"Ici, la boucle pour construire un mot est courte ; dans le pire des cas on a des mots d'une vingtaine de lettres. Mais dans d'autres situations , de longues boucles avec ajout de caract\u00e8res dans une chaine de plus en plus grande, la chaine est recopi\u00e9e int\u00e9gralement \u00e0 chaque tour (c'est un objet immuable). On aimerait \u00e9viter la recopie enti\u00e8re du d\u00e9but de la chaine. Pour cela, on cr\u00e9e une liste vide, dans laquelle on ajoute tous les morceaux \u00e0 chaque tour de boucle. Il n'y a pas de copie. \u00c0 la fin, on colle les morceaux avec join . {{ IDE('exo_var3') }} Cette version est th\u00e9oriquement meilleure, elle serait tr\u00e8s utile dans un autre cadre. Z","title":"Version avec join"},{"location":"1-facile/1400-arange/sujet/","tags":["boucle","float"],"text":"Nombres espac\u00e9s (2) \u2693\ufe0e Pour construire la repr\u00e9sentation graphique d'une fonction d\u00e9finie sur un intervalle, on calcule les images de plusieurs ant\u00e9c\u00e9dents r\u00e9guli\u00e8rement espac\u00e9s, ce qui permet de placer des points \u00e0 relier. Encore faut-il disposer des ant\u00e9c\u00e9dents. Comment les choisir ? Exemples Pour une fonction d\u00e9finie sur \\([2.0, 4.0[\\) , avec des points r\u00e9guli\u00e8rement espac\u00e9s par pas de \\(0.5\\) , on prend \\(2.0, 2.5, 3.0, 3.5\\) . Pour une fonction d\u00e9finie sur \\([5.0, 6.5[\\) , avec des points r\u00e9guli\u00e8rement espac\u00e9s par pas de \\(0.25\\) , on prend \\(5.0, 5.25, 5.5, 5.75, 6.0, 6.25\\) . En param\u00e8tre, on utilisera debut , fin et pas : des flottants ; pas est strictement positif. debut et fin d\u00e9crivent l'intervalle dont on souhaite quelques \u00e9l\u00e9ments r\u00e9guli\u00e8rement espac\u00e9s. \u00c9crire une fonction telle que arange(debut, fin, pas) renvoie une liste de flottants qui v\u00e9rifie : - les nombres sont tous strictement inf\u00e9rieurs \u00e0 ( fin moins \\(10^{-6}\\) ) ; - le premier, s'il existe, est debut ; - les nombres sont rang\u00e9s dans l'ordre croissant ; - l'\u00e9cart entre deux nombres cons\u00e9cutifs est pas . Erreur relative On rappelle qu'on ne fait pas de tests d'\u00e9galit\u00e9 entre flottants. La validation de cet exercice autorise des nombres avec une erreur relative de \\(10^{-6}\\) . En contrepartie , aucun nombre sup\u00e9rieur \u00e0 ( fin - \\(10^{-6}\\) ) ne sera accept\u00e9 dans la r\u00e9ponse. Concr\u00e8tement, si vous devez \u00e9crire un test x < fin alors vous devrez \u00e9crire x < fin - 10 **- 6 \u00e0 la place. Exemples \ud83d\udc0d Console Python >>> arange ( 2.0 , 4.0 , 0.5 ) [2.0, 2.5, 3.0, 3.5] >>> arange ( 5.0 , 6.5 , 0.25 ) [5.0, 5.25, 5.5, 5.75, 6.0, 6.25] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef propython-underscorearange(debut, fin, pas):backslash-newline resultat = []backslash-newline x = debutbackslash-newline while x < fin - 10python-starpython-star-6:backslash-newline resultat.append(x)backslash-newline x += pasbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinefor n in range(1, 30):backslash-newline debut, fin, pas = 4.0 + 5python-starn, 1.0 + 8python-starn, 1/nbackslash-newline resultat = arange(debut, fin, pas)backslash-newline attendu = propython-underscorearange(debut, fin, pas)backslash-newline assert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newline for a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange({debut}, {fin}, {pas})\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def arange(debut, fin, pas):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newline def arange(debut, fin, pas):backslash-newline resultat = []backslash-newline x = debutbackslash-newline while x < fin - 10python-starpython-star-6:backslash-newline resultat.append(x)backslash-newline x += pasbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newline A Z","title":"arange"},{"location":"1-facile/1400-arange/sujet/#nombres-espaces-2","text":"Pour construire la repr\u00e9sentation graphique d'une fonction d\u00e9finie sur un intervalle, on calcule les images de plusieurs ant\u00e9c\u00e9dents r\u00e9guli\u00e8rement espac\u00e9s, ce qui permet de placer des points \u00e0 relier. Encore faut-il disposer des ant\u00e9c\u00e9dents. Comment les choisir ? Exemples Pour une fonction d\u00e9finie sur \\([2.0, 4.0[\\) , avec des points r\u00e9guli\u00e8rement espac\u00e9s par pas de \\(0.5\\) , on prend \\(2.0, 2.5, 3.0, 3.5\\) . Pour une fonction d\u00e9finie sur \\([5.0, 6.5[\\) , avec des points r\u00e9guli\u00e8rement espac\u00e9s par pas de \\(0.25\\) , on prend \\(5.0, 5.25, 5.5, 5.75, 6.0, 6.25\\) . En param\u00e8tre, on utilisera debut , fin et pas : des flottants ; pas est strictement positif. debut et fin d\u00e9crivent l'intervalle dont on souhaite quelques \u00e9l\u00e9ments r\u00e9guli\u00e8rement espac\u00e9s. \u00c9crire une fonction telle que arange(debut, fin, pas) renvoie une liste de flottants qui v\u00e9rifie : - les nombres sont tous strictement inf\u00e9rieurs \u00e0 ( fin moins \\(10^{-6}\\) ) ; - le premier, s'il existe, est debut ; - les nombres sont rang\u00e9s dans l'ordre croissant ; - l'\u00e9cart entre deux nombres cons\u00e9cutifs est pas . Erreur relative On rappelle qu'on ne fait pas de tests d'\u00e9galit\u00e9 entre flottants. La validation de cet exercice autorise des nombres avec une erreur relative de \\(10^{-6}\\) . En contrepartie , aucun nombre sup\u00e9rieur \u00e0 ( fin - \\(10^{-6}\\) ) ne sera accept\u00e9 dans la r\u00e9ponse. Concr\u00e8tement, si vous devez \u00e9crire un test x < fin alors vous devrez \u00e9crire x < fin - 10 **- 6 \u00e0 la place. Exemples \ud83d\udc0d Console Python >>> arange ( 2.0 , 4.0 , 0.5 ) [2.0, 2.5, 3.0, 3.5] >>> arange ( 5.0 , 6.5 , 0.25 ) [5.0, 5.25, 5.5, 5.75, 6.0, 6.25] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef propython-underscorearange(debut, fin, pas):backslash-newline resultat = []backslash-newline x = debutbackslash-newline while x < fin - 10python-starpython-star-6:backslash-newline resultat.append(x)backslash-newline x += pasbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinefor n in range(1, 30):backslash-newline debut, fin, pas = 4.0 + 5python-starn, 1.0 + 8python-starn, 1/nbackslash-newline resultat = arange(debut, fin, pas)backslash-newline attendu = propython-underscorearange(debut, fin, pas)backslash-newline assert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newline for a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange({debut}, {fin}, {pas})\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def arange(debut, fin, pas):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newline def arange(debut, fin, pas):backslash-newline resultat = []backslash-newline x = debutbackslash-newline while x < fin - 10python-starpython-star-6:backslash-newline resultat.append(x)backslash-newline x += pasbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(a, b):backslash-newline return abs(b - a) < 10python-starpython-star-6backslash-newlinebackslash-newlineresultat = arange(2.0, 4.0, 0.5)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(2.0, 4.0, 0.5)\"backslash-newlinebackslash-newlineresultat = arange(5.0, 6.5, 0.25)backslash-newlineattendu = [5.0, 5.25, 5.5, 5.75, 6.0, 6.25]backslash-newlineassert len(resultat) == len(attendu), \"Erreur sur la longueur renvoy\u00c3\u00a9e\"backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert sontpython-underscoreproches(a, b), f\"Erreur avec {a} qui n'est pas proche de {b} dans arange(5.0, 6.5, 0.25)\"backslash-newlinebackslash-newline A Z","title":"Nombres espac\u00e9s (2)"},{"location":"1-facile/1400-linspace/sujet/","tags":["boucle","float"],"text":"Nombres espac\u00e9s \u2693\ufe0e Pour construire la repr\u00e9sentation graphique d'une fonction d\u00e9finie sur un intervalle, on calcule les images de plusieurs ant\u00e9c\u00e9dents r\u00e9guli\u00e8rement espac\u00e9s, ce qui permet de placer des points \u00e0 relier. Encore faut-il disposer des ant\u00e9c\u00e9dents. Comment les choisir ? Exemples Pour une fonction d\u00e9finie sur \\([2.0, 4.0]\\) , avec 5 points r\u00e9guli\u00e8rement espac\u00e9s, on prend \\(2.0, 2.5, 3.0, 3.5, 4.0\\) . Pour une fonction d\u00e9finie sur \\([5.0, 6.5[\\) , avec 6 points r\u00e9guli\u00e8rement espac\u00e9s, on prend \\(5.0, 5.25, 5.5, 5.75, 6.0, 6.25\\) . Dans notre exercice, on se limite aux intervalles de type ferm\u00e9 \\([a\\,;\\,b]\\) ou non ferm\u00e9 \\([a\\,;\\,b[\\) pour lesquels on souhaite proposer \\(n\\) nombres r\u00e9guli\u00e8rement espac\u00e9s, o\u00f9 \\(n\\) est un nombre entier au moins \u00e9gal \u00e0 2. Si l'intervalle est de type \\([a\\,;\\,b]\\) , on part de \\(a\\) et on avance par pas de \\(\\dfrac{b-a}{n-1}\\) . Si l'intervalle est de type \\([a\\,;\\,b[\\) , on part de \\(a\\) et on avance par pas de \\(\\dfrac{b-a}{n}\\) . \u00c9crire une fonction telle que linspace(a, b, n, ferme) renvoie une liste de \\(n\\) nombres flottants r\u00e9guli\u00e8rement espac\u00e9s en partant de a , o\u00f9 a et b sont des flottants, n est un entier au moins \u00e9gal \u00e0 2, et ferme est un bool\u00e9en. Si le bool\u00e9en ferme est \u00e9gal \u00e0 True , on choisira un pas adapt\u00e9 \u00e0 l'intervalle ferm\u00e9 \\([a\\,;\\,b]\\) . Si le bool\u00e9en ferme est \u00e9gal \u00e0 False , on choisira un pas adapt\u00e9 \u00e0 l'intervalle non ferm\u00e9 \\([a\\,;\\,b[\\) . On garantit que \\(a\\) et \\(b\\) sont compris entre \\(-10^9\\) et \\(10^9\\) , et que la diff\u00e9rence \\(b-a\\) est sup\u00e9rieure \u00e0 \\(10^{-9}\\) . On garantit que \\(n\\) est inf\u00e9rieur \u00e0 \\(1000\\) . Exemples \ud83d\udc0d Console Python >>> linspace ( 2.0 , 4.0 , 5 , True ) [2.0, 2.5, 3.0, 3.5, 4.0] >>> linspace ( 5.0 , 9.5 , 6 , False ) [5.0, 5.75, 6.5, 7.25, 8.0, 8.75] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineresultat = linspace(-10, 10, 7, True)backslash-newlineattendu = [-30/3, -20/3, -10/3, 0, 10/3, 20/3, 30/3]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(-10, 10, 7, True)\"backslash-newlinebackslash-newlinebackslash-newlineresultat = linspace(-0.1, 0.1, 3, False)backslash-newlineattendu = [-1/10, -1/30, 1/30]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(-0.1, 0.1, 3, False)\"backslash-newlinebackslash-newline Valider 5/5 def linspace(a, b, n, ferme):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline def linspace(a, b, n, ferme):backslash-newline if ferme:backslash-newline pas = (b - a) / (n - 1)backslash-newline else:backslash-newline pas = (b - a) / nbackslash-newline antecedants = [a]backslash-newline x = abackslash-newline for i in range(n - 1):backslash-newline x += pasbackslash-newline antecedants.append(x)backslash-newline return antecedantsbackslash-newlinebackslash-newlinebackslash-newline# tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline A Z","title":"linspace"},{"location":"1-facile/1400-linspace/sujet/#nombres-espaces","text":"Pour construire la repr\u00e9sentation graphique d'une fonction d\u00e9finie sur un intervalle, on calcule les images de plusieurs ant\u00e9c\u00e9dents r\u00e9guli\u00e8rement espac\u00e9s, ce qui permet de placer des points \u00e0 relier. Encore faut-il disposer des ant\u00e9c\u00e9dents. Comment les choisir ? Exemples Pour une fonction d\u00e9finie sur \\([2.0, 4.0]\\) , avec 5 points r\u00e9guli\u00e8rement espac\u00e9s, on prend \\(2.0, 2.5, 3.0, 3.5, 4.0\\) . Pour une fonction d\u00e9finie sur \\([5.0, 6.5[\\) , avec 6 points r\u00e9guli\u00e8rement espac\u00e9s, on prend \\(5.0, 5.25, 5.5, 5.75, 6.0, 6.25\\) . Dans notre exercice, on se limite aux intervalles de type ferm\u00e9 \\([a\\,;\\,b]\\) ou non ferm\u00e9 \\([a\\,;\\,b[\\) pour lesquels on souhaite proposer \\(n\\) nombres r\u00e9guli\u00e8rement espac\u00e9s, o\u00f9 \\(n\\) est un nombre entier au moins \u00e9gal \u00e0 2. Si l'intervalle est de type \\([a\\,;\\,b]\\) , on part de \\(a\\) et on avance par pas de \\(\\dfrac{b-a}{n-1}\\) . Si l'intervalle est de type \\([a\\,;\\,b[\\) , on part de \\(a\\) et on avance par pas de \\(\\dfrac{b-a}{n}\\) . \u00c9crire une fonction telle que linspace(a, b, n, ferme) renvoie une liste de \\(n\\) nombres flottants r\u00e9guli\u00e8rement espac\u00e9s en partant de a , o\u00f9 a et b sont des flottants, n est un entier au moins \u00e9gal \u00e0 2, et ferme est un bool\u00e9en. Si le bool\u00e9en ferme est \u00e9gal \u00e0 True , on choisira un pas adapt\u00e9 \u00e0 l'intervalle ferm\u00e9 \\([a\\,;\\,b]\\) . Si le bool\u00e9en ferme est \u00e9gal \u00e0 False , on choisira un pas adapt\u00e9 \u00e0 l'intervalle non ferm\u00e9 \\([a\\,;\\,b[\\) . On garantit que \\(a\\) et \\(b\\) sont compris entre \\(-10^9\\) et \\(10^9\\) , et que la diff\u00e9rence \\(b-a\\) est sup\u00e9rieure \u00e0 \\(10^{-9}\\) . On garantit que \\(n\\) est inf\u00e9rieur \u00e0 \\(1000\\) . Exemples \ud83d\udc0d Console Python >>> linspace ( 2.0 , 4.0 , 5 , True ) [2.0, 2.5, 3.0, 3.5, 4.0] >>> linspace ( 5.0 , 9.5 , 6 , False ) [5.0, 5.75, 6.5, 7.25, 8.0, 8.75] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineresultat = linspace(-10, 10, 7, True)backslash-newlineattendu = [-30/3, -20/3, -10/3, 0, 10/3, 20/3, 30/3]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(-10, 10, 7, True)\"backslash-newlinebackslash-newlinebackslash-newlineresultat = linspace(-0.1, 0.1, 3, False)backslash-newlineattendu = [-1/10, -1/30, 1/30]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(-0.1, 0.1, 3, False)\"backslash-newlinebackslash-newline Valider 5/5 def linspace(a, b, n, ferme):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline def linspace(a, b, n, ferme):backslash-newline if ferme:backslash-newline pas = (b - a) / (n - 1)backslash-newline else:backslash-newline pas = (b - a) / nbackslash-newline antecedants = [a]backslash-newline x = abackslash-newline for i in range(n - 1):backslash-newline x += pasbackslash-newline antecedants.append(x)backslash-newline return antecedantsbackslash-newlinebackslash-newlinebackslash-newline# tests, \u00c3 ne pas modifierbackslash-newlinebackslash-newlinedef sontpython-underscoreproches(resultat, attendu):backslash-newline if len(resultat) != len(attendu):backslash-newline return Falsebackslash-newline for a, b in zip(resultat, attendu):backslash-newline if abs(a - b) > 10python-starpython-star-6:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlineresultat = linspace(2.0, 4.0, 5, True)backslash-newlineattendu = [2.0, 2.5, 3.0, 3.5, 4.0]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(2.0, 4.0, 5, True)\"backslash-newlinebackslash-newlineresultat = linspace(5.0, 9.5, 6, False)backslash-newlineattendu = [5.0, 5.75, 6.5, 7.25, 8.0, 8.75]backslash-newlineassert sontpython-underscoreproches(resultat, attendu) , \"Erreur avec linspace(5.0, 9.5, 6, False)\"backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Nombres espac\u00e9s"},{"location":"1-facile/1400-nb_zeros/exo_REM/","text":"Commentaires \u2693\ufe0e Version simple \u2693\ufe0e \ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 On fait attention ; la fonction bouclerait \u00e0 l'infini pour \\(n=0\\) ; elle n'est pas clairement d\u00e9finie. \u00c9tudions des variantes. Version avec divmod \u2693\ufe0e divmod renvoie le quotient et le reste dans une division enti\u00e8re. Par exemple divmod(1789, 100) renvoie (17, 89) . En effet, \\(1789\\) divis\u00e9 par \\(100\\) donne un quotient de \\(17\\) et un reste de \\(89\\) . On peut v\u00e9rifier que \\(1789 = 17\u00d7100 + 89\\) . \ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 resultat = - 1 reste = - 1 while reste != 0 : n , reste = divmod ( n , 10 ) resultat += 1 return resultat Ici, on initialise reste et resultat \u00e0 \\(-1\\) ; on est s\u00fbr de faire au moins un tour de boucle, et il y en aura un de plus que le nombre cherch\u00e9. On ne fait qu'une seule division par tour de boucle. Dans la version pr\u00e9c\u00e9dente, il y a avait une division et un modulo par tour de boucle. Soyons honn\u00eate : cette version apporte tr\u00e8s peu en efficacit\u00e9, mais rend le code plus complexe. La premi\u00e8re version est largement recommand\u00e9e.","title":"Commentaires"},{"location":"1-facile/1400-nb_zeros/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1400-nb_zeros/exo_REM/#version-simple","text":"\ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 On fait attention ; la fonction bouclerait \u00e0 l'infini pour \\(n=0\\) ; elle n'est pas clairement d\u00e9finie. \u00c9tudions des variantes.","title":"Version simple"},{"location":"1-facile/1400-nb_zeros/exo_REM/#version-avec-divmod","text":"divmod renvoie le quotient et le reste dans une division enti\u00e8re. Par exemple divmod(1789, 100) renvoie (17, 89) . En effet, \\(1789\\) divis\u00e9 par \\(100\\) donne un quotient de \\(17\\) et un reste de \\(89\\) . On peut v\u00e9rifier que \\(1789 = 17\u00d7100 + 89\\) . \ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 resultat = - 1 reste = - 1 while reste != 0 : n , reste = divmod ( n , 10 ) resultat += 1 return resultat Ici, on initialise reste et resultat \u00e0 \\(-1\\) ; on est s\u00fbr de faire au moins un tour de boucle, et il y en aura un de plus que le nombre cherch\u00e9. On ne fait qu'une seule division par tour de boucle. Dans la version pr\u00e9c\u00e9dente, il y a avait une division et un modulo par tour de boucle. Soyons honn\u00eate : cette version apporte tr\u00e8s peu en efficacit\u00e9, mais rend le code plus complexe. La premi\u00e8re version est largement recommand\u00e9e.","title":"Version avec divmod"},{"location":"1-facile/1400-nb_zeros/sujet/","tags":["boucle","maths"],"text":"Nombre de z\u00e9ros \u00e0 la fin d'un entier \u2693\ufe0e On souhaite avoir une fonction nb_zeros qui d\u00e9termine le nombre de z\u00e9ros \u00e0 la fin de l'\u00e9criture d\u00e9cimale d'un entier \\(n>0\\) , tr\u00e8s grand. M\u00e9thode On s'interdit , ici, d'utiliser la fonction de conversion str . Cette m\u00e9thode est totalement inefficace avec des nombres tr\u00e8s grands. On demande plut\u00f4t de compter combien de fois on peut diviser un nombre par \\(10\\) avec un reste \u00e9gal \u00e0 z\u00e9ro. Par exemple, \\(42000 = 4200\u00d710 + 0\\) , \\(4200 = 420\u00d710 + 0\\) , \\(420 = 42\u00d710 + 0\\) , \\(42\\) n'est pas divisible par $10. On a pu diviser \\(42000\\) trois fois par \\(10\\) avec un reste \u00e9gal \u00e0 \\(0\\) . Ce nombre se finit donc par 3 z\u00e9ros. Exemples \ud83d\udc0d Console Python >>> nb_zeros ( 42000 ) 3 >>> nb_zeros ( 3210 ) 1 >>> nb_zeros ( 282475249 ) 0 >>> nb_zeros ( 7 ** 10000 ) 0 >>> nb_zeros ( 7 ** 10000 * 1000 ) 3 Pour information, \\(7^{10} = 282475249\\) finit sans aucun z\u00e9ro. \\(7^{10000}\\) est un nombre tr\u00e8s grand qui finit sans aucun z\u00e9ro. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef NBpython-underscoreZEROS(n):backslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n = n // 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinefor n in range(1, 123):backslash-newline attendu = NBpython-underscoreZEROS(n)backslash-newline assert nbpython-underscorezeros(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinefor base in [backslash-newline 2python-starpython-star1000, 3python-starpython-star1000, 5python-starpython-star1000, 7python-starpython-star1000backslash-newline]:backslash-newline for attendu in range(10):backslash-newline n = base python-star 10python-starpython-starattendubackslash-newline assert nbpython-underscorezeros(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorezeros(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newline def nbpython-underscorezeros(n):backslash-newline assert n > 0backslash-newlinebackslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n = n // 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version simple \u2693\ufe0e {{ py('exo_corr') }} On fait attention ; la fonction bouclerait \u00e0 l'infini pour \\(n=0\\) ; elle n'est pas clairement d\u00e9finie. \u00c9tudions des variantes. Version avec divmod \u2693\ufe0e divmod renvoie le quotient et le reste dans une division enti\u00e8re. Par exemple divmod(1789, 100) renvoie (17, 89) . En effet, \\(1789\\) divis\u00e9 par \\(100\\) donne un quotient de \\(17\\) et un reste de \\(89\\) . On peut v\u00e9rifier que \\(1789 = 17\u00d7100 + 89\\) . \ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 resultat = - 1 reste = - 1 while reste != 0 : n , reste = divmod ( n , 10 ) resultat += 1 return resultat Ici, on initialise reste et resultat \u00e0 \\(-1\\) ; on est s\u00fbr de faire au moins un tour de boucle, et il y en aura un de plus que le nombre cherch\u00e9. On ne fait qu'une seule division par tour de boucle. Dans la version pr\u00e9c\u00e9dente, il y a avait une division et un modulo par tour de boucle. Soyons honn\u00eate : cette version apporte tr\u00e8s peu en efficacit\u00e9, mais rend le code plus complexe. La premi\u00e8re version est largement recommand\u00e9e. Z","title":"Nombre de z\u00e9ros \u00e0 la fin d'un entier"},{"location":"1-facile/1400-nb_zeros/sujet/#nombre-de-zeros-a-la-fin-dun-entier","text":"On souhaite avoir une fonction nb_zeros qui d\u00e9termine le nombre de z\u00e9ros \u00e0 la fin de l'\u00e9criture d\u00e9cimale d'un entier \\(n>0\\) , tr\u00e8s grand. M\u00e9thode On s'interdit , ici, d'utiliser la fonction de conversion str . Cette m\u00e9thode est totalement inefficace avec des nombres tr\u00e8s grands. On demande plut\u00f4t de compter combien de fois on peut diviser un nombre par \\(10\\) avec un reste \u00e9gal \u00e0 z\u00e9ro. Par exemple, \\(42000 = 4200\u00d710 + 0\\) , \\(4200 = 420\u00d710 + 0\\) , \\(420 = 42\u00d710 + 0\\) , \\(42\\) n'est pas divisible par $10. On a pu diviser \\(42000\\) trois fois par \\(10\\) avec un reste \u00e9gal \u00e0 \\(0\\) . Ce nombre se finit donc par 3 z\u00e9ros. Exemples \ud83d\udc0d Console Python >>> nb_zeros ( 42000 ) 3 >>> nb_zeros ( 3210 ) 1 >>> nb_zeros ( 282475249 ) 0 >>> nb_zeros ( 7 ** 10000 ) 0 >>> nb_zeros ( 7 ** 10000 * 1000 ) 3 Pour information, \\(7^{10} = 282475249\\) finit sans aucun z\u00e9ro. \\(7^{10000}\\) est un nombre tr\u00e8s grand qui finit sans aucun z\u00e9ro. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef NBpython-underscoreZEROS(n):backslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n = n // 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinefor n in range(1, 123):backslash-newline attendu = NBpython-underscoreZEROS(n)backslash-newline assert nbpython-underscorezeros(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinefor base in [backslash-newline 2python-starpython-star1000, 3python-starpython-star1000, 5python-starpython-star1000, 7python-starpython-star1000backslash-newline]:backslash-newline for attendu in range(10):backslash-newline n = base python-star 10python-starpython-starattendubackslash-newline assert nbpython-underscorezeros(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorezeros(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newline def nbpython-underscorezeros(n):backslash-newline assert n > 0backslash-newlinebackslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n = n // 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezeros(42000) == 3backslash-newlineassert nbpython-underscorezeros(3210) == 1backslash-newlineassert nbpython-underscorezeros(282475249) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000) == 0backslash-newlineassert nbpython-underscorezeros(7python-starpython-star10000 python-star 1000) == 3backslash-newlinebackslash-newline A","title":"Nombre de z\u00e9ros \u00e0 la fin d'un entier"},{"location":"1-facile/1400-nb_zeros/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"1-facile/1400-nb_zeros/sujet/#version-simple","text":"{{ py('exo_corr') }} On fait attention ; la fonction bouclerait \u00e0 l'infini pour \\(n=0\\) ; elle n'est pas clairement d\u00e9finie. \u00c9tudions des variantes.","title":"Version simple"},{"location":"1-facile/1400-nb_zeros/sujet/#version-avec-divmod","text":"divmod renvoie le quotient et le reste dans une division enti\u00e8re. Par exemple divmod(1789, 100) renvoie (17, 89) . En effet, \\(1789\\) divis\u00e9 par \\(100\\) donne un quotient de \\(17\\) et un reste de \\(89\\) . On peut v\u00e9rifier que \\(1789 = 17\u00d7100 + 89\\) . \ud83d\udc0d Script Python def nb_zeros ( n ): assert n > 0 resultat = - 1 reste = - 1 while reste != 0 : n , reste = divmod ( n , 10 ) resultat += 1 return resultat Ici, on initialise reste et resultat \u00e0 \\(-1\\) ; on est s\u00fbr de faire au moins un tour de boucle, et il y en aura un de plus que le nombre cherch\u00e9. On ne fait qu'une seule division par tour de boucle. Dans la version pr\u00e9c\u00e9dente, il y a avait une division et un modulo par tour de boucle. Soyons honn\u00eate : cette version apporte tr\u00e8s peu en efficacit\u00e9, mais rend le code plus complexe. La premi\u00e8re version est largement recommand\u00e9e. Z","title":"Version avec divmod"},{"location":"1-facile/1500-anniversaires/exo_REM/","text":"Commentaires \u2693\ufe0e Le probl\u00e8me revient \u00e0 filtrer les cl\u00e9s d'un dictionnaire selon un crit\u00e8re portant sur les valeurs. On pr\u00e9sente ci-dessous diff\u00e9rentes solutions parcourant le dictionnaire de fa\u00e7ons diff\u00e9rentes ainsi qu'une derni\u00e8re m\u00e9thode plus \"fonctionnelle\". Une solution possible \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances:backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z On d\u00e9bute par la cr\u00e9ation d'une liste ayant vocation \u00e0 contenir le pr\u00e9nom des personnes dont l'anniversaire tombe le mois pass\u00e9 en argument (ligne 2). Ensuite on parcourt les cl\u00e9s du dictionnaire en faisant for prenom in naissances: (ligne 3). Celles-ci \u00e9tant des pr\u00e9noms de personnes, la variable parcourant ces cl\u00e9s est naturellement nomm\u00e9e prenom . Pour chaque cl\u00e9, on teste si la valeur associ\u00e9e (le mois de naissance) est \u00e9gale au mois pass\u00e9 en argument (ligne 4). Si c'est le cas, on ajoute le pr\u00e9nom de la personne \u00e0 la liste des r\u00e9sultats (ligne 5). Enfin, on renvoie la liste des personnes dont l'anniversaire correspond. Autres m\u00e9thodes de parcours d'un dictionnaire \u2693\ufe0e Il est aussi possible de parcourir les cl\u00e9s d'un dictionnaire en faisant for prenom in naissances.keys(): . Le reste du code ne change pas. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances.keys():backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z Enfin, une derni\u00e8re m\u00e9thode propre aux dictionnaires permet de parcourir directement les couples (cle, valeur) . On fait alors for prenom, naissance in naissances.items(): . Le test qui suit est alors plus lisible. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom, moispython-underscorenaissance in naissances.items():backslash-newline if moispython-underscorenaissance == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z En une ligne ! \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline return [prenom for prenom in naissances if naissances[prenom] == mois]backslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z Dans cette m\u00e9thode, on cr\u00e9e une liste par compr\u00e9hension parcourant les couples (cle, valeur) comme dans la m\u00e9thode pr\u00e9c\u00e9dente et testant imm\u00e9diatement la validit\u00e9 du mois de naissance. On rappelle que la concision d'un code n'est pas forc\u00e9ment signe de qualit\u00e9 ! On peut perdre en lisibilit\u00e9.","title":"Commentaires"},{"location":"1-facile/1500-anniversaires/exo_REM/#commentaires","text":"Le probl\u00e8me revient \u00e0 filtrer les cl\u00e9s d'un dictionnaire selon un crit\u00e8re portant sur les valeurs. On pr\u00e9sente ci-dessous diff\u00e9rentes solutions parcourant le dictionnaire de fa\u00e7ons diff\u00e9rentes ainsi qu'une derni\u00e8re m\u00e9thode plus \"fonctionnelle\".","title":"Commentaires"},{"location":"1-facile/1500-anniversaires/exo_REM/#une-solution-possible","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances:backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z On d\u00e9bute par la cr\u00e9ation d'une liste ayant vocation \u00e0 contenir le pr\u00e9nom des personnes dont l'anniversaire tombe le mois pass\u00e9 en argument (ligne 2). Ensuite on parcourt les cl\u00e9s du dictionnaire en faisant for prenom in naissances: (ligne 3). Celles-ci \u00e9tant des pr\u00e9noms de personnes, la variable parcourant ces cl\u00e9s est naturellement nomm\u00e9e prenom . Pour chaque cl\u00e9, on teste si la valeur associ\u00e9e (le mois de naissance) est \u00e9gale au mois pass\u00e9 en argument (ligne 4). Si c'est le cas, on ajoute le pr\u00e9nom de la personne \u00e0 la liste des r\u00e9sultats (ligne 5). Enfin, on renvoie la liste des personnes dont l'anniversaire correspond.","title":"Une solution possible"},{"location":"1-facile/1500-anniversaires/exo_REM/#autres-methodes-de-parcours-dun-dictionnaire","text":"Il est aussi possible de parcourir les cl\u00e9s d'un dictionnaire en faisant for prenom in naissances.keys(): . Le reste du code ne change pas. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances.keys():backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z Enfin, une derni\u00e8re m\u00e9thode propre aux dictionnaires permet de parcourir directement les couples (cle, valeur) . On fait alors for prenom, naissance in naissances.items(): . Le test qui suit est alors plus lisible. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom, moispython-underscorenaissance in naissances.items():backslash-newline if moispython-underscorenaissance == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z","title":"Autres m\u00e9thodes de parcours d'un dictionnaire"},{"location":"1-facile/1500-anniversaires/exo_REM/#en-une-ligne","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def anniversaires(naissances, mois):backslash-newline return [prenom for prenom in naissances if naissances[prenom] == mois]backslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == [backslash-newline 'Nicolas']backslash-newlineassert sorted(anniversaires({'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == [backslash-newline 'Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Z Dans cette m\u00e9thode, on cr\u00e9e une liste par compr\u00e9hension parcourant les couples (cle, valeur) comme dans la m\u00e9thode pr\u00e9c\u00e9dente et testant imm\u00e9diatement la validit\u00e9 du mois de naissance. On rappelle que la concision d'un code n'est pas forc\u00e9ment signe de qualit\u00e9 ! On peut perdre en lisibilit\u00e9.","title":"En une ligne !"},{"location":"1-facile/1500-anniversaires/sujet/","tags":["dictionnaire"],"text":"Anniversaires \u2693\ufe0e On dispose d'un dictionnaire python dans lequel : les cl\u00e9s sont les pr\u00e9noms de diff\u00e9rentes personnes. Il n'y a aucun pr\u00e9nom en double les valeurs sont les mois de naissance de ces personnes stock\u00e9es sous forme de nombres entiers ( 1 pour janvier, ... 12 pour d\u00e9cembre) Par exemple : \ud83d\udc0d Script Python naissances = { 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 } Vous devez \u00e9crire une fonction anniversaires(naissances, mois) prenant en arguments le dictionnaire d\u00e9crit ci-dessus ainsi qu'un num\u00e9ro d'un mois et renvoyant une liste contenant les pr\u00e9noms des personnes n\u00e9es durant ce mois. Exemples \ud83d\udc0d Console Python >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 1 ) [] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 10 ) ['Nicolas'] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 7 ) ['Antoine', Camille] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 13 ) [] >>> anniversaires ({}, 1 ) [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires(dict(), 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newline# Dictionnaire videbackslash-newlineassert sorted(anniversaires({}, 13)) == []backslash-newline# Tous n\u00c3\u00a9s le mois cherch\u00c3\u00a9backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 1, 'Antoine': 1, 'Camille': 1}, 1)) == ['Antoine', 'Camille', 'Nicolas']backslash-newline# Tous n\u00c3\u00a9s un mois non cherch\u00c3\u00a9backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 1, 'Antoine': 1, 'Camille': 1}, 10)) == []backslash-newlinebackslash-newline Valider 5/5 def anniversaires(naissances, mois):backslash-newline ...backslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlineassert sorted(anniversaires(dict(), 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances:backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Le probl\u00e8me revient \u00e0 filtrer les cl\u00e9s d'un dictionnaire selon un crit\u00e8re portant sur les valeurs. On pr\u00e9sente ci-dessous diff\u00e9rentes solutions parcourant le dictionnaire de fa\u00e7ons diff\u00e9rentes ainsi qu'une derni\u00e8re m\u00e9thode plus \"fonctionnelle\". Une solution possible \u2693\ufe0e {{ IDE('exo_corr') }} On d\u00e9bute par la cr\u00e9ation d'une liste ayant vocation \u00e0 contenir le pr\u00e9nom des personnes dont l'anniversaire tombe le mois pass\u00e9 en argument (ligne 2). Ensuite on parcourt les cl\u00e9s du dictionnaire en faisant for prenom in naissances: (ligne 3). Celles-ci \u00e9tant des pr\u00e9noms de personnes, la variable parcourant ces cl\u00e9s est naturellement nomm\u00e9e prenom . Pour chaque cl\u00e9, on teste si la valeur associ\u00e9e (le mois de naissance) est \u00e9gale au mois pass\u00e9 en argument (ligne 4). Si c'est le cas, on ajoute le pr\u00e9nom de la personne \u00e0 la liste des r\u00e9sultats (ligne 5). Enfin, on renvoie la liste des personnes dont l'anniversaire correspond. Autres m\u00e9thodes de parcours d'un dictionnaire \u2693\ufe0e Il est aussi possible de parcourir les cl\u00e9s d'un dictionnaire en faisant for prenom in naissances.keys(): . Le reste du code ne change pas. {{ IDE('exo_var1') }} Enfin, une derni\u00e8re m\u00e9thode propre aux dictionnaires permet de parcourir directement les couples (cle, valeur) . On fait alors for prenom, naissance in naissances.items(): . Le test qui suit est alors plus lisible. {{ IDE('exo_var2') }} En une ligne ! \u2693\ufe0e {{ IDE('exo_var3') }} Dans cette m\u00e9thode, on cr\u00e9e une liste par compr\u00e9hension parcourant les couples (cle, valeur) comme dans la m\u00e9thode pr\u00e9c\u00e9dente et testant imm\u00e9diatement la validit\u00e9 du mois de naissance. On rappelle que la concision d'un code n'est pas forc\u00e9ment signe de qualit\u00e9 ! On peut perdre en lisibilit\u00e9. Z","title":"Anniversaires"},{"location":"1-facile/1500-anniversaires/sujet/#anniversaires","text":"On dispose d'un dictionnaire python dans lequel : les cl\u00e9s sont les pr\u00e9noms de diff\u00e9rentes personnes. Il n'y a aucun pr\u00e9nom en double les valeurs sont les mois de naissance de ces personnes stock\u00e9es sous forme de nombres entiers ( 1 pour janvier, ... 12 pour d\u00e9cembre) Par exemple : \ud83d\udc0d Script Python naissances = { 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 } Vous devez \u00e9crire une fonction anniversaires(naissances, mois) prenant en arguments le dictionnaire d\u00e9crit ci-dessus ainsi qu'un num\u00e9ro d'un mois et renvoyant une liste contenant les pr\u00e9noms des personnes n\u00e9es durant ce mois. Exemples \ud83d\udc0d Console Python >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 1 ) [] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 10 ) ['Nicolas'] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 7 ) ['Antoine', Camille] >>> anniversaires ({ 'Nicolas' : 10 , 'Antoine' : 7 , 'Camille' : 7 }, 13 ) [] >>> anniversaires ({}, 1 ) [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires(dict(), 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newline# Dictionnaire videbackslash-newlineassert sorted(anniversaires({}, 13)) == []backslash-newline# Tous n\u00c3\u00a9s le mois cherch\u00c3\u00a9backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 1, 'Antoine': 1, 'Camille': 1}, 1)) == ['Antoine', 'Camille', 'Nicolas']backslash-newline# Tous n\u00c3\u00a9s un mois non cherch\u00c3\u00a9backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 1, 'Antoine': 1, 'Camille': 1}, 10)) == []backslash-newlinebackslash-newline Valider 5/5 def anniversaires(naissances, mois):backslash-newline ...backslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlineassert sorted(anniversaires(dict(), 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline def anniversaires(naissances, mois):backslash-newline personnespython-underscoreanniversaire = []backslash-newline for prenom in naissances:backslash-newline if naissances[prenom] == mois:backslash-newline personnespython-underscoreanniversaire.append(prenom)backslash-newline return personnespython-underscoreanniversairebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 10)) == ['Nicolas']backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 7}, 7)) == ['Antoine', 'Camille']backslash-newlineassert sorted(anniversaires({}, 1)) == []backslash-newlineassert sorted(anniversaires(backslash-newline {'Nicolas': 10, 'Antoine': 7, 'Camille': 11}, 13)) == []backslash-newlinebackslash-newline A","title":"Anniversaires"},{"location":"1-facile/1500-anniversaires/sujet/#commentaires","text":"Le probl\u00e8me revient \u00e0 filtrer les cl\u00e9s d'un dictionnaire selon un crit\u00e8re portant sur les valeurs. On pr\u00e9sente ci-dessous diff\u00e9rentes solutions parcourant le dictionnaire de fa\u00e7ons diff\u00e9rentes ainsi qu'une derni\u00e8re m\u00e9thode plus \"fonctionnelle\".","title":"Commentaires"},{"location":"1-facile/1500-anniversaires/sujet/#une-solution-possible","text":"{{ IDE('exo_corr') }} On d\u00e9bute par la cr\u00e9ation d'une liste ayant vocation \u00e0 contenir le pr\u00e9nom des personnes dont l'anniversaire tombe le mois pass\u00e9 en argument (ligne 2). Ensuite on parcourt les cl\u00e9s du dictionnaire en faisant for prenom in naissances: (ligne 3). Celles-ci \u00e9tant des pr\u00e9noms de personnes, la variable parcourant ces cl\u00e9s est naturellement nomm\u00e9e prenom . Pour chaque cl\u00e9, on teste si la valeur associ\u00e9e (le mois de naissance) est \u00e9gale au mois pass\u00e9 en argument (ligne 4). Si c'est le cas, on ajoute le pr\u00e9nom de la personne \u00e0 la liste des r\u00e9sultats (ligne 5). Enfin, on renvoie la liste des personnes dont l'anniversaire correspond.","title":"Une solution possible"},{"location":"1-facile/1500-anniversaires/sujet/#autres-methodes-de-parcours-dun-dictionnaire","text":"Il est aussi possible de parcourir les cl\u00e9s d'un dictionnaire en faisant for prenom in naissances.keys(): . Le reste du code ne change pas. {{ IDE('exo_var1') }} Enfin, une derni\u00e8re m\u00e9thode propre aux dictionnaires permet de parcourir directement les couples (cle, valeur) . On fait alors for prenom, naissance in naissances.items(): . Le test qui suit est alors plus lisible. {{ IDE('exo_var2') }}","title":"Autres m\u00e9thodes de parcours d'un dictionnaire"},{"location":"1-facile/1500-anniversaires/sujet/#en-une-ligne","text":"{{ IDE('exo_var3') }} Dans cette m\u00e9thode, on cr\u00e9e une liste par compr\u00e9hension parcourant les couples (cle, valeur) comme dans la m\u00e9thode pr\u00e9c\u00e9dente et testant imm\u00e9diatement la validit\u00e9 du mois de naissance. On rappelle que la concision d'un code n'est pas forc\u00e9ment signe de qualit\u00e9 ! On peut perdre en lisibilit\u00e9. Z","title":"En une ligne !"},{"location":"1-facile/1500-top_like/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def top_likes ( likes ): max_pseudo = \"\" max_likes = - 1 for pseudo in likes : if likes [ pseudo ] > max_likes : max_pseudo = pseudo max_likes = likes [ pseudo ] elif likes [ pseudo ] == max_likes and pseudo < max_pseudo : max_pseudo = pseudo max_likes = likes [ pseudo ] return ( max_pseudo , max_likes ) Il s'agit d'une recherche de maximum. On initialise le pseudo ayant le plus de \u00ab like \u00bb \u00e0 \"\" et la variable max_likes \u00e0 -1 . On prend soin d\u00e8s la premi\u00e8re it\u00e9ration de la boucle de remplacer ces valeurs par celle associ\u00e9es au premier pseudo contenu dans le dictionnaire. Lors du parcours de pseudos, on compare le nombre de \u00ab like \u00bb associ\u00e9 \u00e0 la valeur conserv\u00e9e jusqu'\u00e0 maintenant. Si elle est plus importante on met \u00e0 jour. Si les nombres de \u00ab like \u00bb sont \u00e9gaux, on ne met \u00e0 jour que si l'on a aussi pseudo < max_pseudo .","title":"Commentaires"},{"location":"1-facile/1500-top_like/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def top_likes ( likes ): max_pseudo = \"\" max_likes = - 1 for pseudo in likes : if likes [ pseudo ] > max_likes : max_pseudo = pseudo max_likes = likes [ pseudo ] elif likes [ pseudo ] == max_likes and pseudo < max_pseudo : max_pseudo = pseudo max_likes = likes [ pseudo ] return ( max_pseudo , max_likes ) Il s'agit d'une recherche de maximum. On initialise le pseudo ayant le plus de \u00ab like \u00bb \u00e0 \"\" et la variable max_likes \u00e0 -1 . On prend soin d\u00e8s la premi\u00e8re it\u00e9ration de la boucle de remplacer ces valeurs par celle associ\u00e9es au premier pseudo contenu dans le dictionnaire. Lors du parcours de pseudos, on compare le nombre de \u00ab like \u00bb associ\u00e9 \u00e0 la valeur conserv\u00e9e jusqu'\u00e0 maintenant. Si elle est plus importante on met \u00e0 jour. Si les nombres de \u00ab like \u00bb sont \u00e9gaux, on ne met \u00e0 jour que si l'on a aussi pseudo < max_pseudo .","title":"Commentaires"},{"location":"1-facile/1500-top_like/sujet/","tags":["dictionnaire","boucle"],"text":"Top-Likes ! \u2693\ufe0e Sur le r\u00e9seau social TipTop, on s'int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans un dictionnaire o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : \ud83d\udc0d Script Python { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction top_likes qui : prend en param\u00e8tre un dictionnaire likes non-vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es des entiers, renvoie un tuple dont : la premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; en cas d'\u00e9galit\u00e9 sur plusieurs cl\u00e9s, on choisira la plus petite suivant l'ordre alphab\u00e9tique, la seconde valeur est la valeur maximale pr\u00e9sente dans le dictionnaire. Exemples \ud83d\udc0d Console Python >>> top_likes ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ('Ada', 201) >>> top_likes ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 222 , 'Tim' : 50 }) ('Alan', 222) >>> top_likes ({ 'David' : 222 , 'Ada' : 201 , 'Alan' : 222 , 'Tim' : 50 }) ('Alan', 222) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert toppython-underscorelikes({'David': 12, 'DaviD': 12, 'david': 12}) == ('DaviD', 12)backslash-newlineassert toppython-underscorelikes({'David': 1, 'Charles': 2, 'Bertrand': 3}) == ('Bertrand', 3)backslash-newlineassert toppython-underscorelikes({'David': 1, 'Bertrand': 3, 'Charles': 2}) == ('Bertrand', 3)backslash-newlineassert toppython-underscorelikes({'David': 10, 'Bertrand': 3, 'Charles': 2}) == ('David', 10)backslash-newlineassert toppython-underscorelikes({'David': 0, 'Ada': 0, 'Alan': 0, 'Tim': 0}) == (backslash-newline 'Ada', 0), \"\"\"Erreur si personne n'a de \"like\".\"\"\"backslash-newlinebackslash-newline Valider 5/5 def toppython-underscorelikes(likes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newline def toppython-underscorelikes(likes):backslash-newline maxpython-underscorepseudo = \"\"backslash-newline maxpython-underscorelikes = -1backslash-newline for pseudo in likes:backslash-newline if likes[pseudo] > maxpython-underscorelikes:backslash-newline maxpython-underscorepseudo = pseudobackslash-newline maxpython-underscorelikes = likes[pseudo]backslash-newline elif likes[pseudo] == maxpython-underscorelikes and pseudo < maxpython-underscorepseudo:backslash-newline maxpython-underscorepseudo = pseudobackslash-newline maxpython-underscorelikes = likes[pseudo]backslash-newline return (maxpython-underscorepseudo, maxpython-underscorelikes)backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr', 0, '# TESTS') }} Il s'agit d'une recherche de maximum. On initialise le pseudo ayant le plus de \u00ab like \u00bb \u00e0 \"\" et la variable max_likes \u00e0 -1 . On prend soin d\u00e8s la premi\u00e8re it\u00e9ration de la boucle de remplacer ces valeurs par celle associ\u00e9es au premier pseudo contenu dans le dictionnaire. Lors du parcours de pseudos, on compare le nombre de \u00ab like \u00bb associ\u00e9 \u00e0 la valeur conserv\u00e9e jusqu'\u00e0 maintenant. Si elle est plus importante on met \u00e0 jour. Si les nombres de \u00ab like \u00bb sont \u00e9gaux, on ne met \u00e0 jour que si l'on a aussi pseudo < max_pseudo . Z","title":"Top-Likes !"},{"location":"1-facile/1500-top_like/sujet/#top-likes","text":"Sur le r\u00e9seau social TipTop, on s'int\u00e9resse au nombre de \u00ab like \u00bb des abonn\u00e9s. Les donn\u00e9es sont stock\u00e9es dans un dictionnaire o\u00f9 les cl\u00e9s sont les pseudos et les valeurs correspondantes sont les nombres de \u00ab like \u00bb comme ci-dessous : \ud83d\udc0d Script Python { 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 } \u00c9crire une fonction top_likes qui : prend en param\u00e8tre un dictionnaire likes non-vide dont les cl\u00e9s sont des cha\u00eenes de caract\u00e8res et les valeurs associ\u00e9es des entiers, renvoie un tuple dont : la premi\u00e8re valeur est la cl\u00e9 du dictionnaire associ\u00e9e \u00e0 la valeur maximale ; en cas d'\u00e9galit\u00e9 sur plusieurs cl\u00e9s, on choisira la plus petite suivant l'ordre alphab\u00e9tique, la seconde valeur est la valeur maximale pr\u00e9sente dans le dictionnaire. Exemples \ud83d\udc0d Console Python >>> top_likes ({ 'Bob' : 102 , 'Ada' : 201 , 'Alice' : 103 , 'Tim' : 50 }) ('Ada', 201) >>> top_likes ({ 'Alan' : 222 , 'Ada' : 201 , 'Eve' : 222 , 'Tim' : 50 }) ('Alan', 222) >>> top_likes ({ 'David' : 222 , 'Ada' : 201 , 'Alan' : 222 , 'Tim' : 50 }) ('Alan', 222) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert toppython-underscorelikes({'David': 12, 'DaviD': 12, 'david': 12}) == ('DaviD', 12)backslash-newlineassert toppython-underscorelikes({'David': 1, 'Charles': 2, 'Bertrand': 3}) == ('Bertrand', 3)backslash-newlineassert toppython-underscorelikes({'David': 1, 'Bertrand': 3, 'Charles': 2}) == ('Bertrand', 3)backslash-newlineassert toppython-underscorelikes({'David': 10, 'Bertrand': 3, 'Charles': 2}) == ('David', 10)backslash-newlineassert toppython-underscorelikes({'David': 0, 'Ada': 0, 'Alan': 0, 'Tim': 0}) == (backslash-newline 'Ada', 0), \"\"\"Erreur si personne n'a de \"like\".\"\"\"backslash-newlinebackslash-newline Valider 5/5 def toppython-underscorelikes(likes):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newline def toppython-underscorelikes(likes):backslash-newline maxpython-underscorepseudo = \"\"backslash-newline maxpython-underscorelikes = -1backslash-newline for pseudo in likes:backslash-newline if likes[pseudo] > maxpython-underscorelikes:backslash-newline maxpython-underscorepseudo = pseudobackslash-newline maxpython-underscorelikes = likes[pseudo]backslash-newline elif likes[pseudo] == maxpython-underscorelikes and pseudo < maxpython-underscorepseudo:backslash-newline maxpython-underscorepseudo = pseudobackslash-newline maxpython-underscorelikes = likes[pseudo]backslash-newline return (maxpython-underscorepseudo, maxpython-underscorelikes)backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert toppython-underscorelikes({'Bob': 102, 'Ada': 201, 'Alice': 103,backslash-newline 'Tim': 50}) == ('Ada', 201)backslash-newlineassert toppython-underscorelikes({'Alan': 222, 'Ada': 201, 'Eve': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newlineassert toppython-underscorelikes({'David': 222, 'Ada': 201, 'Alan': 222,backslash-newline 'Tim': 50}) == ('Alan', 222)backslash-newline A","title":"Top-Likes !"},{"location":"1-facile/1500-top_like/sujet/#commentaires","text":"{{ py('exo_corr', 0, '# TESTS') }} Il s'agit d'une recherche de maximum. On initialise le pseudo ayant le plus de \u00ab like \u00bb \u00e0 \"\" et la variable max_likes \u00e0 -1 . On prend soin d\u00e8s la premi\u00e8re it\u00e9ration de la boucle de remplacer ces valeurs par celle associ\u00e9es au premier pseudo contenu dans le dictionnaire. Lors du parcours de pseudos, on compare le nombre de \u00ab like \u00bb associ\u00e9 \u00e0 la valeur conserv\u00e9e jusqu'\u00e0 maintenant. Si elle est plus importante on met \u00e0 jour. Si les nombres de \u00ab like \u00bb sont \u00e9gaux, on ne met \u00e0 jour que si l'on a aussi pseudo < max_pseudo . Z","title":"Commentaires"},{"location":"1-facile/1600-aplatir/exo_REM/","text":"Cet exercice demande de coder une fonction approchant la m\u00e9thode flatten du module numpy . Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : for valeur in ligne : resultat . append ( valeur ) return resultat Dans la fonction aplatir on parcourt l'ensemble des lignes et des valeurs de tableau en l'on ajoute les valeurs au fur et \u00e0 mesure dans une liste resultat . On aurait pu aussi utiliser la m\u00e9thode extend de Python : \ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : resultat . extend ( ligne ) return resultat","title":"exo REM"},{"location":"1-facile/1600-aplatir/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : for valeur in ligne : resultat . append ( valeur ) return resultat Dans la fonction aplatir on parcourt l'ensemble des lignes et des valeurs de tableau en l'on ajoute les valeurs au fur et \u00e0 mesure dans une liste resultat . On aurait pu aussi utiliser la m\u00e9thode extend de Python : \ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : resultat . extend ( ligne ) return resultat","title":"Commentaires"},{"location":"1-facile/1600-aplatir/sujet/","tags":["grille"],"text":"Aplatir un tableau \u2693\ufe0e On consid\u00e8re un tableau \u00e0 deux dimensions, non vide, rempli de nombres, une matrice dit-on aussi, et l'on souhaite l' aplatir , c'est \u00e0 dire le transformer en un tableau sur une seule ligne. Par exemple, le tableau de dimensions \\(3 \\times 4\\) : \\[ \\begin{array}{|c|c|c|c|} \\hline 1&2&3&4\\\\ \\hline 5&6&7&8\\\\ \\hline 9&10&11&12\\\\ \\hline \\end{array} \\] pourra \u00eatre transform\u00e9 en un nouveau tableau de dimensions \\(1 \\times 12\\) \\[ \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline 1&2&3&4&5&6&7&8&9&10&11&12\\\\ \\hline \\end{array} \\] Les tableaux de d\u00e9part seront repr\u00e9sent\u00e9s par des listes de listes Python. Ainsi le premier tableau ci-dessus sera repr\u00e9sent\u00e9 par : \ud83d\udc0d Script Python tab1 = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] Les tableaux \"aplatis\", sur une seule ligne, seront repr\u00e9sent\u00e9s par une simple liste Python. Le second tableau ci-dessus sera repr\u00e9sent\u00e9 par : \ud83d\udc0d Script Python tab2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] \u00c9crire la fonction aplatir prenant en argument une liste de listes tableau et renvoyant une liste dans laquelle toutes les valeurs de tableau sont donn\u00e9es \u00e0 la suite les unes des autres. Exemples \ud83d\udc0d Console Python >>> aplatir ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> aplatir ([[ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ]]) [1, 2, 3, 4, 5, 6] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert aplatir([[8, 7], [6, 5], [4, 3]]) == [8, 7, 6, 5, 4, 3]backslash-newlineassert aplatir([[1], [2], [3]]) == [1, 2, 3]backslash-newlineassert aplatir([[1, 1], [2, 2], [3, 3]]) == [1, 1, 2, 2, 3, 3]backslash-newlineassert aplatir([[1, 1]]) == [1, 1]backslash-newline Valider 5/5 def aplatir(tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline def aplatir(tableau):backslash-newline resultat = []backslash-newline for ligne in tableau:backslash-newline for valeur in ligne:backslash-newline resultat.append(valeur)backslash-newlinebackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline A Cet exercice demande de coder une fonction approchant la m\u00e9thode flatten du module numpy . Commentaires \u2693\ufe0e {{ py('exo_corr', 0, \"# TESTS\") }} Dans la fonction aplatir on parcourt l'ensemble des lignes et des valeurs de tableau en l'on ajoute les valeurs au fur et \u00e0 mesure dans une liste resultat . On aurait pu aussi utiliser la m\u00e9thode extend de Python : \ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : resultat . extend ( ligne ) return resultat Z","title":"Aplatir"},{"location":"1-facile/1600-aplatir/sujet/#aplatir-un-tableau","text":"On consid\u00e8re un tableau \u00e0 deux dimensions, non vide, rempli de nombres, une matrice dit-on aussi, et l'on souhaite l' aplatir , c'est \u00e0 dire le transformer en un tableau sur une seule ligne. Par exemple, le tableau de dimensions \\(3 \\times 4\\) : \\[ \\begin{array}{|c|c|c|c|} \\hline 1&2&3&4\\\\ \\hline 5&6&7&8\\\\ \\hline 9&10&11&12\\\\ \\hline \\end{array} \\] pourra \u00eatre transform\u00e9 en un nouveau tableau de dimensions \\(1 \\times 12\\) \\[ \\begin{array}{|c|c|c|c|c|c|c|c|c|c|c|c|} \\hline 1&2&3&4&5&6&7&8&9&10&11&12\\\\ \\hline \\end{array} \\] Les tableaux de d\u00e9part seront repr\u00e9sent\u00e9s par des listes de listes Python. Ainsi le premier tableau ci-dessus sera repr\u00e9sent\u00e9 par : \ud83d\udc0d Script Python tab1 = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] Les tableaux \"aplatis\", sur une seule ligne, seront repr\u00e9sent\u00e9s par une simple liste Python. Le second tableau ci-dessus sera repr\u00e9sent\u00e9 par : \ud83d\udc0d Script Python tab2 = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 ] \u00c9crire la fonction aplatir prenant en argument une liste de listes tableau et renvoyant une liste dans laquelle toutes les valeurs de tableau sont donn\u00e9es \u00e0 la suite les unes des autres. Exemples \ud83d\udc0d Console Python >>> aplatir ([[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ]]) [1, 2, 3, 4, 5, 6, 7, 8] >>> aplatir ([[ 1 ], [ 2 ], [ 3 ], [ 4 ], [ 5 ], [ 6 ]]) [1, 2, 3, 4, 5, 6] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert aplatir([[8, 7], [6, 5], [4, 3]]) == [8, 7, 6, 5, 4, 3]backslash-newlineassert aplatir([[1], [2], [3]]) == [1, 2, 3]backslash-newlineassert aplatir([[1, 1], [2, 2], [3, 3]]) == [1, 1, 2, 2, 3, 3]backslash-newlineassert aplatir([[1, 1]]) == [1, 1]backslash-newline Valider 5/5 def aplatir(tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline def aplatir(tableau):backslash-newline resultat = []backslash-newline for ligne in tableau:backslash-newline for valeur in ligne:backslash-newline resultat.append(valeur)backslash-newlinebackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert aplatir([[1, 2, 3, 4], [5, 6, 7, 8]]) == [1, 2, 3, 4, 5, 6, 7, 8]backslash-newlineassert aplatir([[1, 2, 3], [4, 5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1, 2], [3, 4], [5, 6]]) == [1, 2, 3, 4, 5, 6]backslash-newlineassert aplatir([[1], [2], [3], [4], [5], [6]]) == [1, 2, 3, 4, 5, 6]backslash-newlinebackslash-newline A Cet exercice demande de coder une fonction approchant la m\u00e9thode flatten du module numpy .","title":"Aplatir un tableau"},{"location":"1-facile/1600-aplatir/sujet/#commentaires","text":"{{ py('exo_corr', 0, \"# TESTS\") }} Dans la fonction aplatir on parcourt l'ensemble des lignes et des valeurs de tableau en l'on ajoute les valeurs au fur et \u00e0 mesure dans une liste resultat . On aurait pu aussi utiliser la m\u00e9thode extend de Python : \ud83d\udc0d Script Python def aplatir ( tableau ): resultat = [] for ligne in tableau : resultat . extend ( ligne ) return resultat Z","title":"Commentaires"},{"location":"1-facile/1600-occurrences_du_mini/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i in range ( len ( donnees )): valeur = donnees [ i ] if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) On pourrait \u00e9crire un code avec un style plus fonctionnel \ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i , valeur in enumerate ( donnees ): if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) enumerate est utile lorsqu'on a besoin de l'indice et de la valeur.","title":"Commentaires"},{"location":"1-facile/1600-occurrences_du_mini/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i in range ( len ( donnees )): valeur = donnees [ i ] if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) On pourrait \u00e9crire un code avec un style plus fonctionnel \ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i , valeur in enumerate ( donnees ): if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) enumerate est utile lorsqu'on a besoin de l'indice et de la valeur.","title":"Commentaires"},{"location":"1-facile/1600-occurrences_du_mini/sujet/","tags":["boucle"],"text":"Occurrences du minimum \u2693\ufe0e On dispose d'un tableau non vide donnees d'entiers : les mesures d'un ph\u00e9nom\u00e8ne \u00e9tudi\u00e9. \u00c9crire une fonction telle que occurrences_mini(donnees) renvoie un tuple compos\u00e9 de deux parties : la valeur minimale du ph\u00e9nom\u00e8ne \u00e9tudi\u00e9 ; la liste des indices qui sont associ\u00e9s \u00e0 la valeur minimale Exemples \ud83d\udc0d Console Python >>> donnees = [ + 13 , + 49 , + 13 , + 5 ] >>> occurrences_mini ( donnees ) (5, [3]) \ud83d\udc0d Console Python >>> donnees = [ - 84 , + 75 , - 84 , 0 , + 16 ] >>> occurrences_mini ( donnees ) (-84, [0, 2]) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedonnees = [0] python-star 4 + [1] python-star 4backslash-newlineattendu = (0, list(range(4)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [1] python-star 4 + [0] python-star 4backslash-newlineattendu = (0, list(range(4, 8)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [10] python-star 3 + [-5] python-star 4 + [1] python-star 4backslash-newlineattendu = (-5, list(range(3, 7)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [10] python-star 4 + [-5] python-star 4 + [1] python-star 3backslash-newlineattendu = (-5, list(range(4, 8)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newline Valider 5/5 def occurrencespython-underscoremini(donnees):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline def occurrencespython-underscoremini(donnees):backslash-newline mini = donnees[0]backslash-newline indices = []backslash-newline for i in range(len(donnees)):backslash-newline valeur = donnees[i]backslash-newline if valeur == mini:backslash-newline indices.append(i)backslash-newline elif valeur < mini:backslash-newline mini = valeurbackslash-newline indices = [i]backslash-newline return (mini, indices)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} On pourrait \u00e9crire un code avec un style plus fonctionnel \ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i , valeur in enumerate ( donnees ): if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) enumerate est utile lorsqu'on a besoin de l'indice et de la valeur. Z","title":"Occurrences du minimum"},{"location":"1-facile/1600-occurrences_du_mini/sujet/#occurrences-du-minimum","text":"On dispose d'un tableau non vide donnees d'entiers : les mesures d'un ph\u00e9nom\u00e8ne \u00e9tudi\u00e9. \u00c9crire une fonction telle que occurrences_mini(donnees) renvoie un tuple compos\u00e9 de deux parties : la valeur minimale du ph\u00e9nom\u00e8ne \u00e9tudi\u00e9 ; la liste des indices qui sont associ\u00e9s \u00e0 la valeur minimale Exemples \ud83d\udc0d Console Python >>> donnees = [ + 13 , + 49 , + 13 , + 5 ] >>> occurrences_mini ( donnees ) (5, [3]) \ud83d\udc0d Console Python >>> donnees = [ - 84 , + 75 , - 84 , 0 , + 16 ] >>> occurrences_mini ( donnees ) (-84, [0, 2]) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedonnees = [0] python-star 4 + [1] python-star 4backslash-newlineattendu = (0, list(range(4)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [1] python-star 4 + [0] python-star 4backslash-newlineattendu = (0, list(range(4, 8)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [10] python-star 3 + [-5] python-star 4 + [1] python-star 4backslash-newlineattendu = (-5, list(range(3, 7)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newlinedonnees = [10] python-star 4 + [-5] python-star 4 + [1] python-star 3backslash-newlineattendu = (-5, list(range(4, 8)))backslash-newlineassert occurrencespython-underscoremini(donnees) == attendu, f\"Erreur avec {donnees}\"backslash-newlinebackslash-newline Valider 5/5 def occurrencespython-underscoremini(donnees):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline def occurrencespython-underscoremini(donnees):backslash-newline mini = donnees[0]backslash-newline indices = []backslash-newline for i in range(len(donnees)):backslash-newline valeur = donnees[i]backslash-newline if valeur == mini:backslash-newline indices.append(i)backslash-newline elif valeur < mini:backslash-newline mini = valeurbackslash-newline indices = [i]backslash-newline return (mini, indices)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedonnees = [+13, +49, +13, +5]backslash-newlineassert occurrencespython-underscoremini(donnees) == (5, [3])backslash-newlinebackslash-newlinedonnees = [-84, +75, -84, 0, +16]backslash-newlineassert occurrencespython-underscoremini(donnees) == (-84, [0, 2])backslash-newlinebackslash-newline A","title":"Occurrences du minimum"},{"location":"1-facile/1600-occurrences_du_mini/sujet/#commentaires","text":"{{ py('exo_corr') }} On pourrait \u00e9crire un code avec un style plus fonctionnel \ud83d\udc0d Script Python def occurrences_mini ( donnees ): mini = donnees [ 0 ] indices = [] for i , valeur in enumerate ( donnees ): if valeur == mini : indices . append ( i ) elif valeur < mini : mini = valeur indices = [ i ] return ( mini , indices ) enumerate est utile lorsqu'on a besoin de l'indice et de la valeur. Z","title":"Commentaires"},{"location":"1-facile/1600-tous_differents/exo_REM/","text":"Une solution possible \u2693\ufe0e \ud83d\udc0d Script Python def tous_differents ( tableau ): n = len ( tableau ) for i in range ( n - 1 ): for j in range ( i + 1 , n ): if tableau [ i ] == tableau [ j ]: return False return True M\u00eame si on essaie d'\u00eatre malin en ne parcourant que les \u00e9l\u00e9ments suivants pour voir si un \u00e9l\u00e9ment appara\u00eet plusieurs fois, cette fonction a un co\u00fbt quadratique. En gros, avec un tableau de taille \\(n\\) on va faire environ \\(n^2\\) comparaisons. L'optimisation de ne regarder que les \u00e9l\u00e9ments suivants permet de diviser par 2 le nombre de tests, mais cela reste beaucoup. Avec un dictionnaire, la recherche d'un \u00e9l\u00e9ment est en co\u00fbt constant, ainsi l'exercice a un co\u00fbt lin\u00e9aire en sa taille. \ud83d\udc0d Script Python def tous_differents ( tableau ): vus = dict () for v in tableau : if v in vus : return False else : vus [ v ] = 1 return True","title":"Une solution possible"},{"location":"1-facile/1600-tous_differents/exo_REM/#une-solution-possible","text":"\ud83d\udc0d Script Python def tous_differents ( tableau ): n = len ( tableau ) for i in range ( n - 1 ): for j in range ( i + 1 , n ): if tableau [ i ] == tableau [ j ]: return False return True M\u00eame si on essaie d'\u00eatre malin en ne parcourant que les \u00e9l\u00e9ments suivants pour voir si un \u00e9l\u00e9ment appara\u00eet plusieurs fois, cette fonction a un co\u00fbt quadratique. En gros, avec un tableau de taille \\(n\\) on va faire environ \\(n^2\\) comparaisons. L'optimisation de ne regarder que les \u00e9l\u00e9ments suivants permet de diviser par 2 le nombre de tests, mais cela reste beaucoup. Avec un dictionnaire, la recherche d'un \u00e9l\u00e9ment est en co\u00fbt constant, ainsi l'exercice a un co\u00fbt lin\u00e9aire en sa taille. \ud83d\udc0d Script Python def tous_differents ( tableau ): vus = dict () for v in tableau : if v in vus : return False else : vus [ v ] = 1 return True","title":"Une solution possible"},{"location":"1-facile/1600-tous_differents/sujet/","tags":["boucle"],"text":"Tableau avec des \u00e9l\u00e9ments tous diff\u00e9rents \u2693\ufe0e Un tableau peut contenir plusieurs fois le m\u00eame \u00e9l\u00e9ment. C'est le cas du tableau tableau1 ci-dessous : \ud83d\udc0d Script Python tableau1 = [ 1 , 2 , 3 , 6 , 2 , 4 , 5 ] La valeur 2 est deux fois dans ce tableau. Au contraire, dans le tableau tableau2 , toutes les valeurs sont uniques : \ud83d\udc0d Script Python tableau2 = [ 'chien' , 'chat' , 'lion' , 'poisson' ] \u00c9crire une fonction tous_differents qui prend un tableau tableau et renvoie un bool\u00e9en indiquant si toutes les valeurs de tableau sont diff\u00e9rentes ou non. Taille des tableaux Pour limiter le temps de calcul, on se limitera \u00e0 des tests avec des tableaux de moins de 100 \u00e9l\u00e9ments. Utilisation de range(a, b) On pourra \u00e9ventuellement utiliser range(a, b) qui renvoie toutes les valeurs enti\u00e8res allant de a \u00e0 b-1 inclus. Exemples \ud83d\udc0d Console Python >>> tableau1 = [ 1 , 2 , 3 , 6 , 2 , 4 , 5 ] >>> tous_differents ( tableau1 ) False \ud83d\udc0d Console Python >>> tableau2 = [ 'chien' , 'chat' , 'lion' , 'poisson' ] >>> tous_differents ( tableau2 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newline# autres testsbackslash-newlineassert touspython-underscoredifferents([]) == Truebackslash-newlineassert touspython-underscoredifferents([1, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents([9, 6, 7, 3, 2, 1, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents(range(100)) == Truebackslash-newlineassert touspython-underscoredifferents(['v', 'o', 'i', 't', 'u', 'r', 'e']) == Truebackslash-newlineassert touspython-underscoredifferents(['a', 'a', 'b', 'c', 'd', 'e']) == Falsebackslash-newlineassert touspython-underscoredifferents([1, 2, 3, 4, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents([5, 9, 1, 2, 1, 3, 7]) == Falsebackslash-newlineassert touspython-underscoredifferents([1, 2, 3, 4, 3, 2, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents(['a', 'a', 1, 1, \"truc\", \"truc\"]) == Falsebackslash-newlineassert touspython-underscoredifferents([\"bob\"]) == Truebackslash-newlinebackslash-newline Valider 5/5 def touspython-underscoredifferents(tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newlinebackslash-newline def touspython-underscoredifferents(tableau):backslash-newline n = len(tableau)backslash-newline for i in range(n - 1):backslash-newline for j in range(i + 1, n):backslash-newline if tableau[i] == tableau[j]:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newlinebackslash-newline A Une solution possible \u2693\ufe0e {{ py('exo_corr', 0, '# TESTS') }} M\u00eame si on essaie d'\u00eatre malin en ne parcourant que les \u00e9l\u00e9ments suivants pour voir si un \u00e9l\u00e9ment appara\u00eet plusieurs fois, cette fonction a un co\u00fbt quadratique. En gros, avec un tableau de taille \\(n\\) on va faire environ \\(n^2\\) comparaisons. L'optimisation de ne regarder que les \u00e9l\u00e9ments suivants permet de diviser par 2 le nombre de tests, mais cela reste beaucoup. Avec un dictionnaire, la recherche d'un \u00e9l\u00e9ment est en co\u00fbt constant, ainsi l'exercice a un co\u00fbt lin\u00e9aire en sa taille. \ud83d\udc0d Script Python def tous_differents ( tableau ): vus = dict () for v in tableau : if v in vus : return False else : vus [ v ] = 1 return True Z","title":"Tous diff\u00e9rents"},{"location":"1-facile/1600-tous_differents/sujet/#tableau-avec-des-elements-tous-differents","text":"Un tableau peut contenir plusieurs fois le m\u00eame \u00e9l\u00e9ment. C'est le cas du tableau tableau1 ci-dessous : \ud83d\udc0d Script Python tableau1 = [ 1 , 2 , 3 , 6 , 2 , 4 , 5 ] La valeur 2 est deux fois dans ce tableau. Au contraire, dans le tableau tableau2 , toutes les valeurs sont uniques : \ud83d\udc0d Script Python tableau2 = [ 'chien' , 'chat' , 'lion' , 'poisson' ] \u00c9crire une fonction tous_differents qui prend un tableau tableau et renvoie un bool\u00e9en indiquant si toutes les valeurs de tableau sont diff\u00e9rentes ou non. Taille des tableaux Pour limiter le temps de calcul, on se limitera \u00e0 des tests avec des tableaux de moins de 100 \u00e9l\u00e9ments. Utilisation de range(a, b) On pourra \u00e9ventuellement utiliser range(a, b) qui renvoie toutes les valeurs enti\u00e8res allant de a \u00e0 b-1 inclus. Exemples \ud83d\udc0d Console Python >>> tableau1 = [ 1 , 2 , 3 , 6 , 2 , 4 , 5 ] >>> tous_differents ( tableau1 ) False \ud83d\udc0d Console Python >>> tableau2 = [ 'chien' , 'chat' , 'lion' , 'poisson' ] >>> tous_differents ( tableau2 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newline# autres testsbackslash-newlineassert touspython-underscoredifferents([]) == Truebackslash-newlineassert touspython-underscoredifferents([1, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents([9, 6, 7, 3, 2, 1, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents(range(100)) == Truebackslash-newlineassert touspython-underscoredifferents(['v', 'o', 'i', 't', 'u', 'r', 'e']) == Truebackslash-newlineassert touspython-underscoredifferents(['a', 'a', 'b', 'c', 'd', 'e']) == Falsebackslash-newlineassert touspython-underscoredifferents([1, 2, 3, 4, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents([5, 9, 1, 2, 1, 3, 7]) == Falsebackslash-newlineassert touspython-underscoredifferents([1, 2, 3, 4, 3, 2, 1]) == Falsebackslash-newlineassert touspython-underscoredifferents(['a', 'a', 1, 1, \"truc\", \"truc\"]) == Falsebackslash-newlineassert touspython-underscoredifferents([\"bob\"]) == Truebackslash-newlinebackslash-newline Valider 5/5 def touspython-underscoredifferents(tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newlinebackslash-newline def touspython-underscoredifferents(tableau):backslash-newline n = len(tableau)backslash-newline for i in range(n - 1):backslash-newline for j in range(i + 1, n):backslash-newline if tableau[i] == tableau[j]:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [1, 2, 3, 6, 2, 4, 5]backslash-newlineassert touspython-underscoredifferents(tableau1) == Falsebackslash-newlinebackslash-newlinetableau2 = ['chien', 'chat', 'lion', 'poisson']backslash-newlineassert touspython-underscoredifferents(tableau2) == Truebackslash-newlinebackslash-newlinebackslash-newline A","title":"Tableau avec des \u00e9l\u00e9ments tous diff\u00e9rents"},{"location":"1-facile/1600-tous_differents/sujet/#une-solution-possible","text":"{{ py('exo_corr', 0, '# TESTS') }} M\u00eame si on essaie d'\u00eatre malin en ne parcourant que les \u00e9l\u00e9ments suivants pour voir si un \u00e9l\u00e9ment appara\u00eet plusieurs fois, cette fonction a un co\u00fbt quadratique. En gros, avec un tableau de taille \\(n\\) on va faire environ \\(n^2\\) comparaisons. L'optimisation de ne regarder que les \u00e9l\u00e9ments suivants permet de diviser par 2 le nombre de tests, mais cela reste beaucoup. Avec un dictionnaire, la recherche d'un \u00e9l\u00e9ment est en co\u00fbt constant, ainsi l'exercice a un co\u00fbt lin\u00e9aire en sa taille. \ud83d\udc0d Script Python def tous_differents ( tableau ): vus = dict () for v in tableau : if v in vus : return False else : vus [ v ] = 1 return True Z","title":"Une solution possible"},{"location":"1-facile/1650-couleurs/sujet/","tags":["string","dictionnaire"],"text":"Des couleurs en HTML \u2693\ufe0e Deux repr\u00e9sentations des couleurs \u2693\ufe0e Une couleur en HTML est repr\u00e9sent\u00e9e par une chaine de caract\u00e8res de sept caract\u00e8res dont le premier est '#' ; les six autres, group\u00e9s 2 par 2 forment 3 entiers en hexad\u00e9cimal (base 16). Le premier entier est la quantit\u00e9 de rouge ; le deuxi\u00e8me la quantit\u00e9 de vert et le troisi\u00e8me est la quantit\u00e9 de bleu. Ces trois valeurs hexad\u00e9cimales sont comprises entre \"00\" et \"FF\" . Exemples Voici quelques couleurs en HTML : \"#C0392B\" (une sorte de brun rouge ), \"#00FF00\" du vert uniquement, \"#000000\" du noir. Une autre fa\u00e7on de repr\u00e9senter une couleur est par un triplet \\((r, v, b)\\) de valeurs d\u00e9cimales comprises entre \\(0\\) et \\(255\\) : \\(r\\) est la quantit\u00e9 de rouge, \\(v\\) la quantit\u00e9 de vert et \\(b\\) la quantit\u00e9 de bleu. On souhaite \u00e9crire une fonction html_vers_rvb qui prend une chaine de caract\u00e8res repr\u00e9sentant une couleur HTML en param\u00e8tre et qui renvoie le triplet de d\u00e9cimaux \\((r, v, b)\\) repr\u00e9sentant la m\u00eame couleur. On rappelle les valeurs d\u00e9cimales des 16 chiffres hexad\u00e9cimaux sont : '0' vaut \\(0\\) , jusqu'\u00e0 '9' qui vaut \\(9\\) , puis 'A' vaut \\(10\\) , 'B' vaut \\(11\\) ainsi de suite jusqu'\u00e0 'F' qui vaut \\(15\\) . Pour calculer la valeur d\u00e9cimale d'un nombre hexad\u00e9cimal de deux chiffres \\((ab)_{16}\\) , on fera le produit de la valeur d\u00e9cimale du chiffre des seizaines \\(a\\) par \\(16\\) plus la valeur d\u00e9cimale du chiffre des unit\u00e9s \\(b\\) . Exemples le nombre hexad\u00e9cimal \"B5\" vaut \\(11\\times 16 + 5\\) soit \\(181\\) en d\u00e9cimal, \"00\" vaut \\(0\\times 16 + 0\\) soit \\(0\\) , Indication \ud83d\udc0d Console Python >>> couleur = \"#F307D6\" >>> couleur [ 1 ] 'F' >>> couleur [ 2 ] '3' Questions \u2693\ufe0e Compl\u00e9ter le dictionnaire HEX_DEC qui donne les valeurs d\u00e9cimales des chiffres hexad\u00e9cimaux \u00c9crire la d\u00e9finition de la fonction hex_int qui prend deux chaines d'un caract\u00e8re en param\u00e8tres a et b ; de sorte que \\((ab)_{16}\\) est un entier en hexad\u00e9cimal et renvoie la valeur d\u00e9cimale associ\u00e9e : \ud83d\udc0d Console Python >>> hex_int ( 'B' , '5' ) 181 >>> hex_int ( '0' , '0' ) 0 \u00c9crire la d\u00e9finition de la fonction html_vers_rvb en vous servant de la fonction pr\u00e9c\u00e9dente. \ud83d\udc0d Console Python >>> html_vers_rvb ( \"#C0392B\" ) (192, 57, 43) >>> html_vers_rvb ( \"#00FF00\" ) (0, 255, 0) >>> html_vers_rvb ( \"#000000\" ) (0, 0, 0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert hexpython-underscoreint('B', '5') == 181, \"\u00c3\u2030chec hexpython-underscoreint exemple 1 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlineassert hexpython-underscoreint('0', '0') == 0, \"\u00c3\u2030chec hexpython-underscoreint exemple 2 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlinebackslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#C0392B'\") == (192, 57, 43), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#00FF00\") == (0, 255, 0), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#000000\") == (0, 0, 0), '\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 3'backslash-newlinebackslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#FFFFFF\") == (255, 255, 255), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#888888\") == (136, 136, 136), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#760017\") == (118, 0, 23), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 3\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 HEXpython-underscoreDEC = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, backslash-newline '9':9, 'A':10, 'B':11,backslash-newline # ...backslash-newline}backslash-newlinebackslash-newlinedef hexpython-underscoreint(seizaine, unite):backslash-newline ...backslash-newlinebackslash-newlinedef htmlpython-underscoreverspython-underscorervb(html):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testbackslash-newlinebackslash-newlineassert hexpython-underscoreint('B', '5') == 181, \"\u00c3\u2030chec hexpython-underscoreint exemple 1 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlineassert hexpython-underscoreint('0', '0') == 0, \"\u00c3\u2030chec hexpython-underscoreint exemple 2 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#C0392B\") == (192, 57, 43), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#00FF00\") == (0, 255, 0), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#000000\") == (0, 0, 0), '\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 3'backslash-newlinebackslash-newlinebackslash-newline HEXpython-underscoreDEC = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9,backslash-newline 'A':10, 'B':11, 'C':12, 'D':13, 'E':14, 'F':15}backslash-newlinebackslash-newlinedef hexpython-underscoreint(seizaine, unite):backslash-newline \"\"\"seizaine et unite sont les chiffres de l'\u00c3\u00a9criture d'un backslash-newline nombre en base 16 \u00c3 2 chiffres. Renvoie la valeur int en base 10\"\"\"backslash-newline return HEXpython-underscoreDEC[seizaine] python-star 16 + HEXpython-underscoreDEC[unite]backslash-newlinebackslash-newlinedef htmlpython-underscoreverspython-underscorervb(html):backslash-newline \"\"\"html: str repr\u00c3\u00a9sente une couleur HTMLbackslash-newline renvoie le triplet repr\u00c3\u00a9sentant la couleur en RVB\"\"\"backslash-newline return hexpython-underscoreint(html[1], html[2]), hexpython-underscoreint(html[3], html[4]), hexpython-underscoreint(html[5], html[6])backslash-newline backslash-newline A Z","title":"Couleurs"},{"location":"1-facile/1650-couleurs/sujet/#des-couleurs-en-html","text":"","title":"Des couleurs en HTML"},{"location":"1-facile/1650-couleurs/sujet/#deux-representations-des-couleurs","text":"Une couleur en HTML est repr\u00e9sent\u00e9e par une chaine de caract\u00e8res de sept caract\u00e8res dont le premier est '#' ; les six autres, group\u00e9s 2 par 2 forment 3 entiers en hexad\u00e9cimal (base 16). Le premier entier est la quantit\u00e9 de rouge ; le deuxi\u00e8me la quantit\u00e9 de vert et le troisi\u00e8me est la quantit\u00e9 de bleu. Ces trois valeurs hexad\u00e9cimales sont comprises entre \"00\" et \"FF\" . Exemples Voici quelques couleurs en HTML : \"#C0392B\" (une sorte de brun rouge ), \"#00FF00\" du vert uniquement, \"#000000\" du noir. Une autre fa\u00e7on de repr\u00e9senter une couleur est par un triplet \\((r, v, b)\\) de valeurs d\u00e9cimales comprises entre \\(0\\) et \\(255\\) : \\(r\\) est la quantit\u00e9 de rouge, \\(v\\) la quantit\u00e9 de vert et \\(b\\) la quantit\u00e9 de bleu. On souhaite \u00e9crire une fonction html_vers_rvb qui prend une chaine de caract\u00e8res repr\u00e9sentant une couleur HTML en param\u00e8tre et qui renvoie le triplet de d\u00e9cimaux \\((r, v, b)\\) repr\u00e9sentant la m\u00eame couleur. On rappelle les valeurs d\u00e9cimales des 16 chiffres hexad\u00e9cimaux sont : '0' vaut \\(0\\) , jusqu'\u00e0 '9' qui vaut \\(9\\) , puis 'A' vaut \\(10\\) , 'B' vaut \\(11\\) ainsi de suite jusqu'\u00e0 'F' qui vaut \\(15\\) . Pour calculer la valeur d\u00e9cimale d'un nombre hexad\u00e9cimal de deux chiffres \\((ab)_{16}\\) , on fera le produit de la valeur d\u00e9cimale du chiffre des seizaines \\(a\\) par \\(16\\) plus la valeur d\u00e9cimale du chiffre des unit\u00e9s \\(b\\) . Exemples le nombre hexad\u00e9cimal \"B5\" vaut \\(11\\times 16 + 5\\) soit \\(181\\) en d\u00e9cimal, \"00\" vaut \\(0\\times 16 + 0\\) soit \\(0\\) , Indication \ud83d\udc0d Console Python >>> couleur = \"#F307D6\" >>> couleur [ 1 ] 'F' >>> couleur [ 2 ] '3'","title":"Deux repr\u00e9sentations des couleurs"},{"location":"1-facile/1650-couleurs/sujet/#questions","text":"Compl\u00e9ter le dictionnaire HEX_DEC qui donne les valeurs d\u00e9cimales des chiffres hexad\u00e9cimaux \u00c9crire la d\u00e9finition de la fonction hex_int qui prend deux chaines d'un caract\u00e8re en param\u00e8tres a et b ; de sorte que \\((ab)_{16}\\) est un entier en hexad\u00e9cimal et renvoie la valeur d\u00e9cimale associ\u00e9e : \ud83d\udc0d Console Python >>> hex_int ( 'B' , '5' ) 181 >>> hex_int ( '0' , '0' ) 0 \u00c9crire la d\u00e9finition de la fonction html_vers_rvb en vous servant de la fonction pr\u00e9c\u00e9dente. \ud83d\udc0d Console Python >>> html_vers_rvb ( \"#C0392B\" ) (192, 57, 43) >>> html_vers_rvb ( \"#00FF00\" ) (0, 255, 0) >>> html_vers_rvb ( \"#000000\" ) (0, 0, 0) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser assert hexpython-underscoreint('B', '5') == 181, \"\u00c3\u2030chec hexpython-underscoreint exemple 1 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlineassert hexpython-underscoreint('0', '0') == 0, \"\u00c3\u2030chec hexpython-underscoreint exemple 2 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlinebackslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#C0392B'\") == (192, 57, 43), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#00FF00\") == (0, 255, 0), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#000000\") == (0, 0, 0), '\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 3'backslash-newlinebackslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#FFFFFF\") == (255, 255, 255), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#888888\") == (136, 136, 136), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#760017\") == (118, 0, 23), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb autre exemple 3\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 HEXpython-underscoreDEC = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, backslash-newline '9':9, 'A':10, 'B':11,backslash-newline # ...backslash-newline}backslash-newlinebackslash-newlinedef hexpython-underscoreint(seizaine, unite):backslash-newline ...backslash-newlinebackslash-newlinedef htmlpython-underscoreverspython-underscorervb(html):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testbackslash-newlinebackslash-newlineassert hexpython-underscoreint('B', '5') == 181, \"\u00c3\u2030chec hexpython-underscoreint exemple 1 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlineassert hexpython-underscoreint('0', '0') == 0, \"\u00c3\u2030chec hexpython-underscoreint exemple 2 de l'\u00c3\u00a9nonc\u00c3\u00a9\"backslash-newlinebackslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#C0392B\") == (192, 57, 43), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 1\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#00FF00\") == (0, 255, 0), \"\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 2\"backslash-newlineassert htmlpython-underscoreverspython-underscorervb(\"#000000\") == (0, 0, 0), '\u00c3\u2030chec htmlpython-underscoreverspython-underscorervb exemple 3'backslash-newlinebackslash-newlinebackslash-newline HEXpython-underscoreDEC = {'0':0, '1':1, '2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9,backslash-newline 'A':10, 'B':11, 'C':12, 'D':13, 'E':14, 'F':15}backslash-newlinebackslash-newlinedef hexpython-underscoreint(seizaine, unite):backslash-newline \"\"\"seizaine et unite sont les chiffres de l'\u00c3\u00a9criture d'un backslash-newline nombre en base 16 \u00c3 2 chiffres. Renvoie la valeur int en base 10\"\"\"backslash-newline return HEXpython-underscoreDEC[seizaine] python-star 16 + HEXpython-underscoreDEC[unite]backslash-newlinebackslash-newlinedef htmlpython-underscoreverspython-underscorervb(html):backslash-newline \"\"\"html: str repr\u00c3\u00a9sente une couleur HTMLbackslash-newline renvoie le triplet repr\u00c3\u00a9sentant la couleur en RVB\"\"\"backslash-newline return hexpython-underscoreint(html[1], html[2]), hexpython-underscoreint(html[3], html[4]), hexpython-underscoreint(html[5], html[6])backslash-newline backslash-newline A Z","title":"Questions"},{"location":"1-facile/1650-dict_extremes/sujet/","tags":["dictionnaire","boucle"],"text":"Dictionnaire de valeurs extr\u00eames \u2693\ufe0e \u00c9crire une fonction extremes qui prend en param\u00e8tre un tableau valeurs de nombres non tri\u00e9s, et qui renvoie la plus petite ainsi que la plus grande valeur du tableau sous la forme d'un dictionnaire \u00e0 deux cl\u00e9s 'min' et 'max' . Si les extr\u00eames n'existent pas, on utilisera None pour chacun. On n'utilisera pas les fonctions min et max fournies par le langage. Exemples \ud83d\udc0d Console Python >>> valeurs = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = extremes ( valeurs ) >>> resultat {'min': -2, 'max': 9} \ud83d\udc0d Console Python >>> valeurs = [ 37 , 37 ] >>> resultat = extremes ( valeurs ) >>> resultat {'min': 37, 'max': 37} \ud83d\udc0d Console Python >>> valeurs = [] >>> resultat = extremes ( valeurs ) >>> resultat {'min': None, 'max': None} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([37, 37]) == {'min': 37, 'max': 37}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert extremes([42]) == {'min': 42, 'max': 42}backslash-newlineassert extremes([-42]) == {'min': -42, 'max': -42}backslash-newlineassert extremes([10, -10]) == {'min': -10, 'max': 10}backslash-newlineassert extremes([-10, 10]) == {'min': -10, 'max': 10}backslash-newlineassert extremes([-10, 100, 10]) == {'min': -10, 'max': 100}backslash-newlineassert extremes([-10, -100, 10]) == {'min': -100, 'max': 10}backslash-newlineassert extremes([10, 100, -10]) == {'min': -10, 'max': 100}backslash-newlineassert extremes([10, -100, -10]) == {'min': -100, 'max': 10}backslash-newlinebackslash-newline Valider 5/5 def extremes(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([37, 37]) == {'min': 37, 'max': 37}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newline def extremes(valeurs):backslash-newline if valeurs == []:backslash-newline return {'min': None, 'max': None}backslash-newline else:backslash-newline mini = valeurs[0]backslash-newline maxi = valeurs[0]backslash-newline for x in valeurs:backslash-newline if x < mini:backslash-newline mini = xbackslash-newline if x > maxi:backslash-newline maxi = xbackslash-newline return {'min': mini, 'max': maxi}backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newline A Z","title":"Valeurs extr\u00eames"},{"location":"1-facile/1650-dict_extremes/sujet/#dictionnaire-de-valeurs-extremes","text":"\u00c9crire une fonction extremes qui prend en param\u00e8tre un tableau valeurs de nombres non tri\u00e9s, et qui renvoie la plus petite ainsi que la plus grande valeur du tableau sous la forme d'un dictionnaire \u00e0 deux cl\u00e9s 'min' et 'max' . Si les extr\u00eames n'existent pas, on utilisera None pour chacun. On n'utilisera pas les fonctions min et max fournies par le langage. Exemples \ud83d\udc0d Console Python >>> valeurs = [ 0 , 1 , 4 , 2 , - 2 , 9 , 3 , 1 , 7 , 1 ] >>> resultat = extremes ( valeurs ) >>> resultat {'min': -2, 'max': 9} \ud83d\udc0d Console Python >>> valeurs = [ 37 , 37 ] >>> resultat = extremes ( valeurs ) >>> resultat {'min': 37, 'max': 37} \ud83d\udc0d Console Python >>> valeurs = [] >>> resultat = extremes ( valeurs ) >>> resultat {'min': None, 'max': None} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([37, 37]) == {'min': 37, 'max': 37}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert extremes([42]) == {'min': 42, 'max': 42}backslash-newlineassert extremes([-42]) == {'min': -42, 'max': -42}backslash-newlineassert extremes([10, -10]) == {'min': -10, 'max': 10}backslash-newlineassert extremes([-10, 10]) == {'min': -10, 'max': 10}backslash-newlineassert extremes([-10, 100, 10]) == {'min': -10, 'max': 100}backslash-newlineassert extremes([-10, -100, 10]) == {'min': -100, 'max': 10}backslash-newlineassert extremes([10, 100, -10]) == {'min': -10, 'max': 100}backslash-newlineassert extremes([10, -100, -10]) == {'min': -100, 'max': 10}backslash-newlinebackslash-newline Valider 5/5 def extremes(valeurs):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([37, 37]) == {'min': 37, 'max': 37}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newline def extremes(valeurs):backslash-newline if valeurs == []:backslash-newline return {'min': None, 'max': None}backslash-newline else:backslash-newline mini = valeurs[0]backslash-newline maxi = valeurs[0]backslash-newline for x in valeurs:backslash-newline if x < mini:backslash-newline mini = xbackslash-newline if x > maxi:backslash-newline maxi = xbackslash-newline return {'min': mini, 'max': maxi}backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert extremes([0, 1, 4, 2, -2, 9, 3, 1, 7, 1]) == {'min': -2, 'max': 9}backslash-newlineassert extremes([]) == {'min': None, 'max': None}backslash-newlinebackslash-newline A Z","title":"Dictionnaire de valeurs extr\u00eames"},{"location":"1-facile/1700-dico_occurrences/sujet/","tags":["dictionnaire","boucle","string"],"text":"Dictionnaire des nombres d'occurrences dans une phrase \u2693\ufe0e Occurrence d'un caract\u00e8re dans une phrase D'apr\u00e8s Le Larousse : \u00ab En logique, place occup\u00e9e par un symbole dans une formule. \u00bb Le nombre d'occurrences du caract\u00e8re \"o\" dans \"bonjour\" est 2 ; le nombre d'occurrences du caract\u00e8re \"b\" dans \"bonjour\" est 1 ; le nombre d'occurrences du caract\u00e8re \"B\" dans \"bonjour\" est 0 ; le nombre d'occurrences du caract\u00e8re \" \" dans \"Bonjour \u00e0 tous !\" est 3. On souhaite stocker les nombres d'occurrences dans un dictionnaire dont les cl\u00e9s sont les caract\u00e8res de la phrase et les valeurs le nombre d'occurrences du caract\u00e8re. \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une chaine de caract\u00e8res phrase . Cette fonction doit renvoyer un dictionnaire des nombres d'occurrences des caract\u00e8res pr\u00e9sents dans phrase . Exemples \ud83d\udc0d Console Python >>> occurrence_lettres ( \"Bonjour \u00e0 tous !\" ) == { 'B' : 1 , 'o' : 3 , 'n' : 1 , 'j' : 1 , 'u' : 2 , 'r' : 1 , ' ' : 3 , '\u00e0' : 1 , 't' : 1 , 's' : 1 , '!' : 1 } True \ud83d\udc0d Console Python >>> occurrence_lettres ( \"ababbab\" ) == { \"a\" : 3 , \"b\" : 4 } True On rappelle que l'ordre des cl\u00e9s n'a pas d'importance pour comparer deux dictionnaires. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"\") == dict()backslash-newlineassert occurrencepython-underscorelettres(\"d\") == {'d': 1}backslash-newlineassert occurrencepython-underscorelettres(\"d\" python-star 100) == {'d': 100}backslash-newlineassert occurrencepython-underscorelettres(\"d\" python-star 100 + \"r\" python-star 50) == {'d': 100, 'r': 50}backslash-newlinebackslash-newline Valider 5/5 def occurrencepython-underscorelettres(phrase):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newline def occurrencepython-underscorelettres(phrase):backslash-newline occurrences = dict()backslash-newline for caractere in phrase:backslash-newline if caractere in occurrences:backslash-newline occurrences[caractere] += 1backslash-newline else:backslash-newline occurrences[caractere] = 1backslash-newline return occurrencesbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newline A Z","title":"Dictionnaire d'occurrences"},{"location":"1-facile/1700-dico_occurrences/sujet/#dictionnaire-des-nombres-doccurrences-dans-une-phrase","text":"Occurrence d'un caract\u00e8re dans une phrase D'apr\u00e8s Le Larousse : \u00ab En logique, place occup\u00e9e par un symbole dans une formule. \u00bb Le nombre d'occurrences du caract\u00e8re \"o\" dans \"bonjour\" est 2 ; le nombre d'occurrences du caract\u00e8re \"b\" dans \"bonjour\" est 1 ; le nombre d'occurrences du caract\u00e8re \"B\" dans \"bonjour\" est 0 ; le nombre d'occurrences du caract\u00e8re \" \" dans \"Bonjour \u00e0 tous !\" est 3. On souhaite stocker les nombres d'occurrences dans un dictionnaire dont les cl\u00e9s sont les caract\u00e8res de la phrase et les valeurs le nombre d'occurrences du caract\u00e8re. \u00c9crire une fonction occurrence_lettres prenant comme param\u00e8tre une chaine de caract\u00e8res phrase . Cette fonction doit renvoyer un dictionnaire des nombres d'occurrences des caract\u00e8res pr\u00e9sents dans phrase . Exemples \ud83d\udc0d Console Python >>> occurrence_lettres ( \"Bonjour \u00e0 tous !\" ) == { 'B' : 1 , 'o' : 3 , 'n' : 1 , 'j' : 1 , 'u' : 2 , 'r' : 1 , ' ' : 3 , '\u00e0' : 1 , 't' : 1 , 's' : 1 , '!' : 1 } True \ud83d\udc0d Console Python >>> occurrence_lettres ( \"ababbab\" ) == { \"a\" : 3 , \"b\" : 4 } True On rappelle que l'ordre des cl\u00e9s n'a pas d'importance pour comparer deux dictionnaires. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"\") == dict()backslash-newlineassert occurrencepython-underscorelettres(\"d\") == {'d': 1}backslash-newlineassert occurrencepython-underscorelettres(\"d\" python-star 100) == {'d': 100}backslash-newlineassert occurrencepython-underscorelettres(\"d\" python-star 100 + \"r\" python-star 50) == {'d': 100, 'r': 50}backslash-newlinebackslash-newline Valider 5/5 def occurrencepython-underscorelettres(phrase):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newline def occurrencepython-underscorelettres(phrase):backslash-newline occurrences = dict()backslash-newline for caractere in phrase:backslash-newline if caractere in occurrences:backslash-newline occurrences[caractere] += 1backslash-newline else:backslash-newline occurrences[caractere] = 1backslash-newline return occurrencesbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"Bonjour \u00c3 tous !\") == {backslash-newline 'B': 1, 'o': 3, 'n': 1, 'j': 1, 'u': 2, 'r': 1,backslash-newline ' ': 3, '\u00c3 ': 1, 't': 1, 's': 1, '!': 1backslash-newline}backslash-newlinebackslash-newlineassert occurrencepython-underscorelettres(\"ababbab\") == {\"a\": 3, \"b\": 4}backslash-newlinebackslash-newline A Z","title":"Dictionnaire des nombres d'occurrences dans une phrase"},{"location":"1-facile/1725-antecedents/exo_REM/","text":"Commentaires \u2693\ufe0e Pour chaque couple (cle, valeur) il faut tester l'absence de valeur dans le dictionnaire des ant\u00e9c\u00e9dents afin de lui associer la liste [cle] si tel est le cas, et de compl\u00e9ter la liste existante dico_antecedents[valeur] en invoquant la m\u00e9thode append dans le cas contraire. Voici une variante qui initialise une liste vide et proc\u00e8de syst\u00e9matiquement \u00e0 l'ajout de cle . \ud83d\udc0d Script Python def antecedents ( dico ): dico_antecedents = {} for cle , valeur in dico . items (): if valeur not in dico_antecedents : dico_antecedents [ valeur ] = [] dico_antecedents [ valeur ] . append ( cle ) return dico_antecedents","title":"Commentaires"},{"location":"1-facile/1725-antecedents/exo_REM/#commentaires","text":"Pour chaque couple (cle, valeur) il faut tester l'absence de valeur dans le dictionnaire des ant\u00e9c\u00e9dents afin de lui associer la liste [cle] si tel est le cas, et de compl\u00e9ter la liste existante dico_antecedents[valeur] en invoquant la m\u00e9thode append dans le cas contraire. Voici une variante qui initialise une liste vide et proc\u00e8de syst\u00e9matiquement \u00e0 l'ajout de cle . \ud83d\udc0d Script Python def antecedents ( dico ): dico_antecedents = {} for cle , valeur in dico . items (): if valeur not in dico_antecedents : dico_antecedents [ valeur ] = [] dico_antecedents [ valeur ] . append ( cle ) return dico_antecedents","title":"Commentaires"},{"location":"1-facile/1725-antecedents/sujet/","tags":["dictionnaire","boucle"],"text":"Dictionnaire des ant\u00e9c\u00e9dents \u2693\ufe0e Un dictionnaire associe des valeurs \u00e0 des cl\u00e9s, comme par exemple {\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"} qui associe \"P\" \u00e0 la cl\u00e9 \"Paris\" . Suivant les cas, une m\u00eame valeur peut \u00eatre associ\u00e9e \u00e0 une ou plusieurs cl\u00e9s. Dans l'exemple pr\u00e9c\u00e9dent, la valeur \"L\" est associ\u00e9e aux cl\u00e9s \"Lyon\" et \"Lille\" , on les appelle les ant\u00e9c\u00e9dents de \"L\" , tandis que \"P\" a la cl\u00e9 \"Paris\" pour seul et unique ant\u00e9c\u00e9dent. On peut ainsi construire le dictionnaire des ant\u00e9c\u00e9dents {\"P\": [\"Paris\"], \"L\": [\"Lyon\", \"Lille\"], \"N\": [\"Nantes\"]} . Vous devez \u00e9crire une fonction antecedents de param\u00e8tre dico qui renvoie le dictionnaire associant les valeurs de dico \u00e0 la liste de leurs ant\u00e9c\u00e9dents dans dico . Note : Puisqu'aucun ordre ne vous est impos\u00e9 dans la construction des listes, une \u00e9tape suppl\u00e9mentaire de tri est r\u00e9alis\u00e9e lors des tests de validation. Exemples \ud83d\udc0d Console Python >>> antecedents ({ 'a' : 5 , 'b' : 7 }) {5: ['a'], 7: ['b']} >>> antecedents ({ 'a' : 5 , 'b' : 7 , 'c' : 5 }) {5: ['a', 'c'], 7: ['b']} >>> antecedents ({ \"Paris\" : \"P\" , \"Lyon\" : \"L\" , \"Nantes\" : \"N\" , \"Lille\" : \"L\" }) {\"P\": [\"Paris\"], \"L\": [\"Lyon\", \"Lille\"], \"N\": [\"Nantes\"]} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert trier(antecedents({\"Paris\": \"Tour Eiffel\", \"Rome\": \"Colis\u00c3\u00a9e\", \"Berlin\": \"Reichtag\", \"Londres\": \"Big Ben\"})) == \\backslash-newline {'Tour Eiffel': ['Paris'], 'Colis\u00c3\u00a9e': ['Rome'], 'Reichtag': ['Berlin'], 'Big Ben': ['Londres']}, \\backslash-newline \"test 4\"backslash-newlineassert trier(antecedents({})) == {}, \"test 5\"backslash-newlineassert trier(antecedents({'a': 'a'})) == {'a': ['a']}, \"test 6\"backslash-newlineassert trier(antecedents({c:0 for c in \"abcdef\"})) == {0: list(\"abcdef\")}, \"test 7\"backslash-newlinebackslash-newline Valider 5/5 def antecedents(dico):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline def antecedents(dico):backslash-newline dicopython-underscoreantecedents = {}backslash-newline for cle, valeur in dico.items():backslash-newline if valeur not in dicopython-underscoreantecedents:backslash-newline dicopython-underscoreantecedents[valeur] = [cle]backslash-newline else:backslash-newline dicopython-underscoreantecedents[valeur].append(cle)backslash-newline return dicopython-underscoreantecedentsbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Pour chaque couple (cle, valeur) il faut tester l'absence de valeur dans le dictionnaire des ant\u00e9c\u00e9dents afin de lui associer la liste [cle] si tel est le cas, et de compl\u00e9ter la liste existante dico_antecedents[valeur] en invoquant la m\u00e9thode append dans le cas contraire. Voici une variante qui initialise une liste vide et proc\u00e8de syst\u00e9matiquement \u00e0 l'ajout de cle . \ud83d\udc0d Script Python def antecedents ( dico ): dico_antecedents = {} for cle , valeur in dico . items (): if valeur not in dico_antecedents : dico_antecedents [ valeur ] = [] dico_antecedents [ valeur ] . append ( cle ) return dico_antecedents Z","title":"Dictionnaire des ant\u00e9c\u00e9dents"},{"location":"1-facile/1725-antecedents/sujet/#dictionnaire-des-antecedents","text":"Un dictionnaire associe des valeurs \u00e0 des cl\u00e9s, comme par exemple {\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"} qui associe \"P\" \u00e0 la cl\u00e9 \"Paris\" . Suivant les cas, une m\u00eame valeur peut \u00eatre associ\u00e9e \u00e0 une ou plusieurs cl\u00e9s. Dans l'exemple pr\u00e9c\u00e9dent, la valeur \"L\" est associ\u00e9e aux cl\u00e9s \"Lyon\" et \"Lille\" , on les appelle les ant\u00e9c\u00e9dents de \"L\" , tandis que \"P\" a la cl\u00e9 \"Paris\" pour seul et unique ant\u00e9c\u00e9dent. On peut ainsi construire le dictionnaire des ant\u00e9c\u00e9dents {\"P\": [\"Paris\"], \"L\": [\"Lyon\", \"Lille\"], \"N\": [\"Nantes\"]} . Vous devez \u00e9crire une fonction antecedents de param\u00e8tre dico qui renvoie le dictionnaire associant les valeurs de dico \u00e0 la liste de leurs ant\u00e9c\u00e9dents dans dico . Note : Puisqu'aucun ordre ne vous est impos\u00e9 dans la construction des listes, une \u00e9tape suppl\u00e9mentaire de tri est r\u00e9alis\u00e9e lors des tests de validation. Exemples \ud83d\udc0d Console Python >>> antecedents ({ 'a' : 5 , 'b' : 7 }) {5: ['a'], 7: ['b']} >>> antecedents ({ 'a' : 5 , 'b' : 7 , 'c' : 5 }) {5: ['a', 'c'], 7: ['b']} >>> antecedents ({ \"Paris\" : \"P\" , \"Lyon\" : \"L\" , \"Nantes\" : \"N\" , \"Lille\" : \"L\" }) {\"P\": [\"Paris\"], \"L\": [\"Lyon\", \"Lille\"], \"N\": [\"Nantes\"]} Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert trier(antecedents({\"Paris\": \"Tour Eiffel\", \"Rome\": \"Colis\u00c3\u00a9e\", \"Berlin\": \"Reichtag\", \"Londres\": \"Big Ben\"})) == \\backslash-newline {'Tour Eiffel': ['Paris'], 'Colis\u00c3\u00a9e': ['Rome'], 'Reichtag': ['Berlin'], 'Big Ben': ['Londres']}, \\backslash-newline \"test 4\"backslash-newlineassert trier(antecedents({})) == {}, \"test 5\"backslash-newlineassert trier(antecedents({'a': 'a'})) == {'a': ['a']}, \"test 6\"backslash-newlineassert trier(antecedents({c:0 for c in \"abcdef\"})) == {0: list(\"abcdef\")}, \"test 7\"backslash-newlinebackslash-newline Valider 5/5 def antecedents(dico):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline def antecedents(dico):backslash-newline dicopython-underscoreantecedents = {}backslash-newline for cle, valeur in dico.items():backslash-newline if valeur not in dicopython-underscoreantecedents:backslash-newline dicopython-underscoreantecedents[valeur] = [cle]backslash-newline else:backslash-newline dicopython-underscoreantecedents[valeur].append(cle)backslash-newline return dicopython-underscoreantecedentsbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinedef trier(d): return {k: list(sorted(d[k])) for k in d}backslash-newlinebackslash-newlineassert trier(antecedents({'a': 5, 'b': 7})) == {5: ['a'], 7: ['b']}, \"exemple 1\"backslash-newlineassert trier(antecedents({'a': 5, 'b': 7, 'c': 5})) == {5: ['a', 'c'], 7: ['b']}, \"exemple 2\"backslash-newlineassert trier(antecedents({\"Paris\": \"P\", \"Lyon\": \"L\", \"Nantes\": \"N\", \"Lille\": \"L\"})) == \\backslash-newline {\"P\": [\"Paris\"], \"L\": [\"Lille\", \"Lyon\"], \"N\": [\"Nantes\"]}, \"exemple 3\"backslash-newlinebackslash-newline A","title":"Dictionnaire des ant\u00e9c\u00e9dents"},{"location":"1-facile/1725-antecedents/sujet/#commentaires","text":"Pour chaque couple (cle, valeur) il faut tester l'absence de valeur dans le dictionnaire des ant\u00e9c\u00e9dents afin de lui associer la liste [cle] si tel est le cas, et de compl\u00e9ter la liste existante dico_antecedents[valeur] en invoquant la m\u00e9thode append dans le cas contraire. Voici une variante qui initialise une liste vide et proc\u00e8de syst\u00e9matiquement \u00e0 l'ajout de cle . \ud83d\udc0d Script Python def antecedents ( dico ): dico_antecedents = {} for cle , valeur in dico . items (): if valeur not in dico_antecedents : dico_antecedents [ valeur ] = [] dico_antecedents [ valeur ] . append ( cle ) return dico_antecedents Z","title":"Commentaires"},{"location":"1-facile/1750-syracuse/sujet/","tags":["maths","boucle"],"text":"La suite de Syracuse d'un entier \u2693\ufe0e Pour construire la suite de Syracuse d'un entier \\(n\\) : On cr\u00e9e une liste avec \\(n\\) comme premier \u00e9l\u00e9ment, On r\u00e9p\u00e8te en boucle tant que \\(n \\neq 1\\) : Si \\(n\\) est pair, on le divise par \\(2\\) , Sinon \\(n\\) devient \\(3n+1\\) . On ajoute \\(n\\) \u00e0 la liste. On admet que, quel que soit l'entier \\(n\\) choisi au d\u00e9part, la suite finit toujours par atteindre la valeur \\(1\\) . \u00c9crire une fonction syracuse prenant en param\u00e8tres un entier n strictement positif et qui renvoie la suite de Syracuse de l'entier n . On rappelle que n % 2 renvoie le reste dans la division de n par 2 , et que s'il est nul, c'est que n est un nombre pair. Exemple \ud83d\udc0d Console Python >>> syracuse ( 7 ) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] >>> syracuse ( 3 ) [3, 10, 5, 16, 8, 4, 2, 1] >>> syracuse ( 1 ) [1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef solution(n):backslash-newline suite = [n]backslash-newline while n != 1:backslash-newline if n % 2 == 0:backslash-newline n = n // 2backslash-newline else:backslash-newline n = 3 python-star n + 1backslash-newline suite.append(n)backslash-newline return suitebackslash-newlinebackslash-newlinefor n in range(1, 200):backslash-newline resultat = solution(n)backslash-newline assert syracuse(n) == resultat, f\"Erreur avec {n}\"backslash-newlinebackslash-newline Valider 5/5 def syracuse(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newline def syracuse(n):backslash-newline suite = [n]backslash-newline while n != 1:backslash-newline if n % 2 == 0:backslash-newline n = n // 2backslash-newline else:backslash-newline n = 3 python-star n + 1backslash-newline suite.append(n)backslash-newline return suitebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newline A Z","title":"Suite de Syracuse"},{"location":"1-facile/1750-syracuse/sujet/#la-suite-de-syracuse-dun-entier","text":"Pour construire la suite de Syracuse d'un entier \\(n\\) : On cr\u00e9e une liste avec \\(n\\) comme premier \u00e9l\u00e9ment, On r\u00e9p\u00e8te en boucle tant que \\(n \\neq 1\\) : Si \\(n\\) est pair, on le divise par \\(2\\) , Sinon \\(n\\) devient \\(3n+1\\) . On ajoute \\(n\\) \u00e0 la liste. On admet que, quel que soit l'entier \\(n\\) choisi au d\u00e9part, la suite finit toujours par atteindre la valeur \\(1\\) . \u00c9crire une fonction syracuse prenant en param\u00e8tres un entier n strictement positif et qui renvoie la suite de Syracuse de l'entier n . On rappelle que n % 2 renvoie le reste dans la division de n par 2 , et que s'il est nul, c'est que n est un nombre pair. Exemple \ud83d\udc0d Console Python >>> syracuse ( 7 ) [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1] >>> syracuse ( 3 ) [3, 10, 5, 16, 8, 4, 2, 1] >>> syracuse ( 1 ) [1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef solution(n):backslash-newline suite = [n]backslash-newline while n != 1:backslash-newline if n % 2 == 0:backslash-newline n = n // 2backslash-newline else:backslash-newline n = 3 python-star n + 1backslash-newline suite.append(n)backslash-newline return suitebackslash-newlinebackslash-newlinefor n in range(1, 200):backslash-newline resultat = solution(n)backslash-newline assert syracuse(n) == resultat, f\"Erreur avec {n}\"backslash-newlinebackslash-newline Valider 5/5 def syracuse(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newline def syracuse(n):backslash-newline suite = [n]backslash-newline while n != 1:backslash-newline if n % 2 == 0:backslash-newline n = n // 2backslash-newline else:backslash-newline n = 3 python-star n + 1backslash-newline suite.append(n)backslash-newline return suitebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert syracuse(7) == [backslash-newline 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(3) == [3, 10, 5, 16, 8, 4, 2, 1]backslash-newlineassert syracuse(1) == [1]backslash-newlinebackslash-newline A Z","title":"La suite de Syracuse d'un entier"},{"location":"1-facile/1800-additionneur_binaire/sujet/","text":"Additionner deux nombres binaires \u2693\ufe0e Dans cet exercice, les nombres binaires sont repr\u00e9sent\u00e9s par des listes o\u00f9 les bits de poids forts sont situ\u00e9s en t\u00eate et les bits de poids faibles \u00e0 la fin. Ainsi la liste [1, 0, 1, 1] repr\u00e9sente l'entier \\(1\u00d72^3 + 0\u00d72^2 + 1\u00d72^2 + 1\u00d72^0 = 11\\) . On ne demande pas de convertir les nombres dans cet exercice. On rappelle que l'addition de nombres binaires se fait chiffre \u00e0 chiffre (ici bit \u00e0 bit), sans oublier l'\u00e9ventuelle retenue. Ainsi la somme de 1 et 1 renvoie 0 et conserve 1 en retenue. On peut par exemple \u00e9crire : \ud83d\udccb Texte retenues : 1 1 1 ----------- 1 0 1 0 1 1 0 1 + 0 0 1 0 1 1 1 0 --------------- 1 1 0 1 1 0 1 1 \u00c9crire une fonction addition_binaire qui prends deux listes de bits en entr\u00e9e et qui renvoie une liste de bits en sortie, correspondant \u00e0 l'addition binaire des deux nombres. On n'utilisera ni la fonction bin ni les op\u00e9rateurs + , // ou % . Une fonction additionneur est fournie. Elle prend en entr\u00e9e trois valeurs et renvoie deux nombres, le premier \u00e9tant le chiffre de poids fort de la somme et le second le chiffre de poids faible. Le premier chiffre peut-\u00eatre interpr\u00e9t\u00e9 comme une retenue. Cette fonction simule les circuits \u00e9lectroniques usuellement pr\u00e9sents dans un additionneur binaire. Ces circuits sont habituellement cod\u00e9s avec des portes logiques correspondant aux op\u00e9rateurs xor (ou exclusif), or (ou), and (et) et nand (non et) Exemples \ud83d\udc0d Console Python >>> additionneur ( 1 , 1 , 0 ) (1, 0) >>> addition_binaire ([ 1 , 1 , 1 ], [ 1 , 1 , 1 ]) [1, 1, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 ]) [1, 0, 1, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 ]) [1, 1, 0, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 , 0 ]) [1, 0, 0, 0, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 0 ]) [1, 0, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 ]) [1, 0, 1, 0, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 0 ]) [1, 1, 0, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 1 ]) [1, 0, 1, 0, 0, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [1, 1, 0, 1, 1, 0, 1, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # test de la fonction donn\u00c3\u00a9ebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newline# test de l'exemplebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline# test basiquebackslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlinebackslash-newline# test ordre des nombresbackslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlinebackslash-newline Valider 5/5 def additionneur(a, b, c):backslash-newline return (a & b) | (a & c) | (b & c), a ^ b ^ cbackslash-newlinebackslash-newlinebackslash-newlinedef additionpython-underscorebinaire(n1, n2):backslash-newline passbackslash-newlinebackslash-newlinebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline def additionneur(a, b, c):backslash-newline return (a & b) | (a & c) | (b & c), a ^ b ^ cbackslash-newlinebackslash-newlinebackslash-newlinedef additionpython-underscorebinaire(n1, n2):backslash-newline difference = len(n1) - len(n2)backslash-newline if difference > 0:backslash-newline n2 = [0] python-star difference + n2backslash-newline else:backslash-newline n1 = [0] python-star (-difference) + n1backslash-newline retenue: int = 0backslash-newline resultat: list[int] = []backslash-newline for i in range(len(n1)):backslash-newline retenue, bit = additionneur(n1[len(n1) - 1 - i], n2[len(n1) - 1 - i], retenue)backslash-newline resultat = [bit] + resultatbackslash-newline if retenue == 1:backslash-newline resultat = [retenue] + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newlinebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline A Z Aide On peut afficher la liste des retenues pour s'aider dans le d\u00e9veloppement de la fonction.","title":"Additionneur binaire"},{"location":"1-facile/1800-additionneur_binaire/sujet/#additionner-deux-nombres-binaires","text":"Dans cet exercice, les nombres binaires sont repr\u00e9sent\u00e9s par des listes o\u00f9 les bits de poids forts sont situ\u00e9s en t\u00eate et les bits de poids faibles \u00e0 la fin. Ainsi la liste [1, 0, 1, 1] repr\u00e9sente l'entier \\(1\u00d72^3 + 0\u00d72^2 + 1\u00d72^2 + 1\u00d72^0 = 11\\) . On ne demande pas de convertir les nombres dans cet exercice. On rappelle que l'addition de nombres binaires se fait chiffre \u00e0 chiffre (ici bit \u00e0 bit), sans oublier l'\u00e9ventuelle retenue. Ainsi la somme de 1 et 1 renvoie 0 et conserve 1 en retenue. On peut par exemple \u00e9crire : \ud83d\udccb Texte retenues : 1 1 1 ----------- 1 0 1 0 1 1 0 1 + 0 0 1 0 1 1 1 0 --------------- 1 1 0 1 1 0 1 1 \u00c9crire une fonction addition_binaire qui prends deux listes de bits en entr\u00e9e et qui renvoie une liste de bits en sortie, correspondant \u00e0 l'addition binaire des deux nombres. On n'utilisera ni la fonction bin ni les op\u00e9rateurs + , // ou % . Une fonction additionneur est fournie. Elle prend en entr\u00e9e trois valeurs et renvoie deux nombres, le premier \u00e9tant le chiffre de poids fort de la somme et le second le chiffre de poids faible. Le premier chiffre peut-\u00eatre interpr\u00e9t\u00e9 comme une retenue. Cette fonction simule les circuits \u00e9lectroniques usuellement pr\u00e9sents dans un additionneur binaire. Ces circuits sont habituellement cod\u00e9s avec des portes logiques correspondant aux op\u00e9rateurs xor (ou exclusif), or (ou), and (et) et nand (non et) Exemples \ud83d\udc0d Console Python >>> additionneur ( 1 , 1 , 0 ) (1, 0) >>> addition_binaire ([ 1 , 1 , 1 ], [ 1 , 1 , 1 ]) [1, 1, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 ]) [1, 0, 1, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 ]) [1, 1, 0, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 , 0 ]) [1, 0, 0, 0, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 0 ]) [1, 0, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 0 , 1 , 0 ]) [1, 0, 1, 0, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 0 , 0 , 0 , 0 ]) [1, 1, 0, 1, 0] >>> addition_binaire ([ 1 , 0 , 1 , 0 ], [ 1 , 1 , 1 , 1 , 1 ]) [1, 0, 1, 0, 0, 1] >>> addition_binaire ([ 1 , 0 , 1 , 0 , 1 , 1 , 0 , 1 ], [ 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 ]) [1, 1, 0, 1, 1, 0, 1, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # test de la fonction donn\u00c3\u00a9ebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newline# test de l'exemplebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline# test basiquebackslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlinebackslash-newline# test ordre des nombresbackslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlinebackslash-newline Valider 5/5 def additionneur(a, b, c):backslash-newline return (a & b) | (a & c) | (b & c), a ^ b ^ cbackslash-newlinebackslash-newlinebackslash-newlinedef additionpython-underscorebinaire(n1, n2):backslash-newline passbackslash-newlinebackslash-newlinebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline def additionneur(a, b, c):backslash-newline return (a & b) | (a & c) | (b & c), a ^ b ^ cbackslash-newlinebackslash-newlinebackslash-newlinedef additionpython-underscorebinaire(n1, n2):backslash-newline difference = len(n1) - len(n2)backslash-newline if difference > 0:backslash-newline n2 = [0] python-star difference + n2backslash-newline else:backslash-newline n1 = [0] python-star (-difference) + n1backslash-newline retenue: int = 0backslash-newline resultat: list[int] = []backslash-newline for i in range(len(n1)):backslash-newline retenue, bit = additionneur(n1[len(n1) - 1 - i], n2[len(n1) - 1 - i], retenue)backslash-newline resultat = [bit] + resultatbackslash-newline if retenue == 1:backslash-newline resultat = [retenue] + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlineassert additionneur(0, 0, 0) == (0, 0)backslash-newlineassert additionneur(1, 0, 0) == (0, 1)backslash-newlineassert additionneur(0, 1, 0) == (0, 1)backslash-newlineassert additionneur(0, 0, 1) == (0, 1)backslash-newlineassert additionneur(1, 1, 0) == (1, 0)backslash-newlineassert additionneur(0, 1, 1) == (1, 0)backslash-newlineassert additionneur(1, 0, 1) == (1, 0)backslash-newlineassert additionneur(1, 1, 1) == (1, 1)backslash-newlinebackslash-newlinebackslash-newlineassert additionpython-underscorebinaire([1, 1, 1], [1, 1, 1]) == [1, 1, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1]) == [1, 0, 1, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1]) == [1, 1, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 0]) == [1, 0, 0, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [0]) == [1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 1, 0]) == [1, 0, 1, 0, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 0, 0, 0, 0]) == [1, 1, 0, 1, 0]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0], [1, 1, 1, 1, 1]) == [1, 0, 1, 0, 0, 1]backslash-newlineassert additionpython-underscorebinaire([1, 0, 1, 0, 1, 1, 0, 1], [0, 0, 1, 0, 1, 1, 1, 0]) == [1, 1, 0, 1, 1, 0, 1, 1]backslash-newlinebackslash-newline A Z Aide On peut afficher la liste des retenues pour s'aider dans le d\u00e9veloppement de la fonction.","title":"Additionner deux nombres binaires"},{"location":"1-facile/1800-tri_selection/sujet/","tags":["tri","boucle"],"text":"\u00c9crire une fonction tri_selection qui prend en param\u00e8tre un tableau tableau de nombres entiers et qui trie ce tableau en place (c'est-\u00e0-dire que le tableau est modifi\u00e9) par ordre croissant des valeurs. On utilisera l\u2019algorithme suivant : On parcourt le tableau de gauche \u00e0 droite : on recherche le minimum du tableau entre cette position courante et la fin du tableau on \u00e9change alors les 2 valeurs Exemples \ud83d\udc0d Console Python >>> tab = [ 1 , 52 , 6 , - 9 , 12 ] >>> tri_selection ( tab ) >>> tab [-9, 1, 6, 12, 52] \ud83d\udc0d Console Python >>> tab_vide = [] >>> tri_selection ( tab_vide ) >>> tab_vide [] \ud83d\udc0d Console Python >>> singleton = [ 9 ] >>> tri_selection ( singleton ) >>> singleton [9] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetab = [1, 52, 6, -9, 12]backslash-newlinetripython-underscoreselection(tab)backslash-newlineassert tab == [-9, 1, 6, 12, 52], \"Exemple 1\"backslash-newlinebackslash-newlinetabpython-underscorevide = []backslash-newlinetripython-underscoreselection(tabpython-underscorevide)backslash-newlineassert tabpython-underscorevide == [], \"Exemple 2\"backslash-newlinebackslash-newlinesingleton = [9]backslash-newlinetripython-underscoreselection(singleton)backslash-newlineassert singleton == [9], \"Exemple 3\"backslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlinefrom random import samplebackslash-newlinefor i in range(10):backslash-newline nombres = list(sample(range(10python-starpython-star9), 100+i))backslash-newline attendu = sorted(nombres)backslash-newline tripython-underscoreselection(nombres)backslash-newline assert len(nombres) == len(attendu), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newline for a, b, in zip(nombres, attendu):backslash-newline assert a == b, \"Erreur lors du tri\"backslash-newlinebackslash-newline Valider 5/5 def tripython-underscoreselection(tableau):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetab = [1, 52, 6, -9, 12]backslash-newlinetripython-underscoreselection(tab)backslash-newlineassert tab == [-9, 1, 6, 12, 52], \"Exemple 1\"backslash-newlinebackslash-newlinetabpython-underscorevide = []backslash-newlinetripython-underscoreselection(tabpython-underscorevide)backslash-newlineassert tabpython-underscorevide == [], \"Exemple 2\"backslash-newlinebackslash-newlinesingleton = [9]backslash-newlinetripython-underscoreselection(singleton)backslash-newlineassert singleton == [9], \"Exemple 3\"backslash-newlinebackslash-newline def positionpython-underscoreminimum(tableau, i):backslash-newline \"\"\"recherche et renvoie l'indice du minimum \u00c3 partir de l'indice i\"\"\"backslash-newline indpython-underscoremini = ibackslash-newline for j in range(i + 1, len(tableau)):backslash-newline if tableau[j] < tableau[indpython-underscoremini]:backslash-newline indpython-underscoremini = jbackslash-newline return indpython-underscoreminibackslash-newlinebackslash-newlinedef echange(tableau, i, j):backslash-newline tableau[i], tableau[j] = tableau[j], tableau[i]backslash-newlinebackslash-newlinedef tripython-underscoreselection(tableau):backslash-newline for i in range(len(tableau)):backslash-newline indicepython-underscoreminimum = positionpython-underscoreminimum(tableau, i)backslash-newline echange(tableau, indicepython-underscoreminimum, i)backslash-newlinebackslash-newline A Z","title":"Tri par s\u00e9lection"},{"location":"1-facile/1850-tete_de_serie/exo_REM/","text":"Commentaires \u2693\ufe0e Le probl\u00e8me revient \u00e0 s\u00e9lectionner le minimum dans une liste. Deux subtilit\u00e9s toutefois : la liste contient les \"\u00e9tiquettes\" des donn\u00e9es \u00e0 comparer (les pr\u00e9noms des joueurs alors que l'on compare les classements) certains joueurs n'ont pas de classement : on utilise alors une valeur par d\u00e9faut sup\u00e9rieure au plus grand classement possible Une solution possible \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline meilleurpython-underscorejoueur = participants[0]backslash-newline if meilleurpython-underscorejoueur in classement:backslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newline else:backslash-newline meilleurpython-underscoreclassement = len(classement)+1backslash-newlinebackslash-newline for joueur in participants:backslash-newline if joueur in classement and classement[joueur] < meilleurpython-underscoreclassement:backslash-newline meilleurpython-underscorejoueur = joueurbackslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newlinebackslash-newline return meilleurpython-underscorejoueurbackslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline A Z On v\u00e9rifie tout d'abord que la liste comporte au moins un joueur. On initialise ensuite la recherche en consid\u00e9rant que le premier joueur participant a le meilleur classement. Si ce joueur n'est pas class\u00e9, on lui donne la note de len(classement)+1 . La suite de la fonction est construite autour d'une boucle Pour chaque . On parcourt l'ensemble des participants et pour chacun on se demande : est-il class\u00e9 ? Si non, il ne peut pas \u00eatre mieux class\u00e9 que le \"meilleur\" actuel s'il est class\u00e9, est-il mieux class\u00e9 que le \"meilleur\" actuel ? Si oui, on met \u00e0 jour les valeurs La fonction se termine en renvoyant le pr\u00e9nom du joueur le mieux class\u00e9.","title":"Commentaires"},{"location":"1-facile/1850-tete_de_serie/exo_REM/#commentaires","text":"Le probl\u00e8me revient \u00e0 s\u00e9lectionner le minimum dans une liste. Deux subtilit\u00e9s toutefois : la liste contient les \"\u00e9tiquettes\" des donn\u00e9es \u00e0 comparer (les pr\u00e9noms des joueurs alors que l'on compare les classements) certains joueurs n'ont pas de classement : on utilise alors une valeur par d\u00e9faut sup\u00e9rieure au plus grand classement possible","title":"Commentaires"},{"location":"1-facile/1850-tete_de_serie/exo_REM/#une-solution-possible","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline meilleurpython-underscorejoueur = participants[0]backslash-newline if meilleurpython-underscorejoueur in classement:backslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newline else:backslash-newline meilleurpython-underscoreclassement = len(classement)+1backslash-newlinebackslash-newline for joueur in participants:backslash-newline if joueur in classement and classement[joueur] < meilleurpython-underscoreclassement:backslash-newline meilleurpython-underscorejoueur = joueurbackslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newlinebackslash-newline return meilleurpython-underscorejoueurbackslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline A Z On v\u00e9rifie tout d'abord que la liste comporte au moins un joueur. On initialise ensuite la recherche en consid\u00e9rant que le premier joueur participant a le meilleur classement. Si ce joueur n'est pas class\u00e9, on lui donne la note de len(classement)+1 . La suite de la fonction est construite autour d'une boucle Pour chaque . On parcourt l'ensemble des participants et pour chacun on se demande : est-il class\u00e9 ? Si non, il ne peut pas \u00eatre mieux class\u00e9 que le \"meilleur\" actuel s'il est class\u00e9, est-il mieux class\u00e9 que le \"meilleur\" actuel ? Si oui, on met \u00e0 jour les valeurs La fonction se termine en renvoyant le pr\u00e9nom du joueur le mieux class\u00e9.","title":"Une solution possible"},{"location":"1-facile/1850-tete_de_serie/sujet/","tags":["dictionnaire"],"text":"T\u00eate de s\u00e9rie \u2693\ufe0e L'organisateur d'un tournoi sportif souhaite d\u00e9terminer le nom du joueur participant le mieux class\u00e9 dans le classement international. Les classements des joueurs sont des entiers tous distincts et compris entre 1 et len(classement) . Il conna\u00eet donc le nom des participants au tournoi, donn\u00e9 sous forme d'une liste, ainsi que le classement, donn\u00e9 sous forme d'un dictionnaire. Par exemple : \ud83d\udc0d Script Python participants = [ 'Stefanos' , 'Rafael' , 'David' , 'Novak' ] classement = { 'Novak' : 1 , 'Daniil' : 2 , 'Alexander' : 3 , 'Stefanos' : 4 , 'Rafael' : 5 } Comme on peut le voir dans l'exemple : tous les joueurs class\u00e9s ne sont pas obligatoirement inscrits au tournoi (ici Daniil et Alexander ne participent pas) certains participants au tournoi, invit\u00e9s d'honneur, n'ont pas de classement ( David ici)... On consid\u00e9rera donc qu'ils sont moins bien class\u00e9s que n'importe lequel des joueurs class\u00e9s Vous devez \u00e9crire une fonction tete_de_serie(participants, classement) prenant en arguments la liste des joueurs inscrits au tournoi ainsi que le classement et renvoyant le pr\u00e9nom du joueur le mieux class\u00e9. Attention Le dictionnaire classement ne devra pas \u00eatre modifi\u00e9 lors de l'ex\u00e9cution de la fonction Si le tournoi ne comporte que des joueurs non-class\u00e9s, la fonction renverra le pr\u00e9nom du premier joueur de la liste. Exemples \ud83d\udc0d Console Python >>> classement = { 'Novak' : 1 , 'Daniil' : 2 , 'Alexander' : 3 , 'Stefanos' : 4 , 'Rafael' : 5 } >>> participants = [ 'Stefanos' , 'Novak' , 'Rafael' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'Stefanos' , 'Rafael' , 'David' , 'Novak' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'David' , 'Novak' , 'Alexander' , 'Daniil' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'David' , 'Olivier' ] >>> tete_de_serie ( participants , classement ) 'David' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newline# On change de dictionnairebackslash-newlineclassement = {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Dictionnaire/classement videbackslash-newlineassert tetepython-underscoredepython-underscoreserie(['David', 'Rafael'], {}) == 'David'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['Dave', 'Oliver']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Dave'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Dave', 'Navok', 'Stephane']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Stephane'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Que des joueurs class\u00c3\u00a9sbackslash-newlineparticipants = ['Navok', 'Stephane', 'Daniil', 'Rapha\u00c3\u00abl']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Rapha\u00c3\u00abl'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newlinebackslash-newline Valider 5/5 def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline meilleurpython-underscorejoueur = participants[0]backslash-newline if meilleurpython-underscorejoueur in classement:backslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newline else:backslash-newline meilleurpython-underscoreclassement = len(classement)+1backslash-newlinebackslash-newline for joueur in participants:backslash-newline if joueur in classement and classement[joueur] < meilleurpython-underscoreclassement:backslash-newline meilleurpython-underscorejoueur = joueurbackslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newlinebackslash-newline return meilleurpython-underscorejoueurbackslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Le probl\u00e8me revient \u00e0 s\u00e9lectionner le minimum dans une liste. Deux subtilit\u00e9s toutefois : la liste contient les \"\u00e9tiquettes\" des donn\u00e9es \u00e0 comparer (les pr\u00e9noms des joueurs alors que l'on compare les classements) certains joueurs n'ont pas de classement : on utilise alors une valeur par d\u00e9faut sup\u00e9rieure au plus grand classement possible Une solution possible \u2693\ufe0e {{ IDE('exo_corr') }} On v\u00e9rifie tout d'abord que la liste comporte au moins un joueur. On initialise ensuite la recherche en consid\u00e9rant que le premier joueur participant a le meilleur classement. Si ce joueur n'est pas class\u00e9, on lui donne la note de len(classement)+1 . La suite de la fonction est construite autour d'une boucle Pour chaque . On parcourt l'ensemble des participants et pour chacun on se demande : est-il class\u00e9 ? Si non, il ne peut pas \u00eatre mieux class\u00e9 que le \"meilleur\" actuel s'il est class\u00e9, est-il mieux class\u00e9 que le \"meilleur\" actuel ? Si oui, on met \u00e0 jour les valeurs La fonction se termine en renvoyant le pr\u00e9nom du joueur le mieux class\u00e9. Z","title":"T\u00eate de s\u00e9rie"},{"location":"1-facile/1850-tete_de_serie/sujet/#tete-de-serie","text":"L'organisateur d'un tournoi sportif souhaite d\u00e9terminer le nom du joueur participant le mieux class\u00e9 dans le classement international. Les classements des joueurs sont des entiers tous distincts et compris entre 1 et len(classement) . Il conna\u00eet donc le nom des participants au tournoi, donn\u00e9 sous forme d'une liste, ainsi que le classement, donn\u00e9 sous forme d'un dictionnaire. Par exemple : \ud83d\udc0d Script Python participants = [ 'Stefanos' , 'Rafael' , 'David' , 'Novak' ] classement = { 'Novak' : 1 , 'Daniil' : 2 , 'Alexander' : 3 , 'Stefanos' : 4 , 'Rafael' : 5 } Comme on peut le voir dans l'exemple : tous les joueurs class\u00e9s ne sont pas obligatoirement inscrits au tournoi (ici Daniil et Alexander ne participent pas) certains participants au tournoi, invit\u00e9s d'honneur, n'ont pas de classement ( David ici)... On consid\u00e9rera donc qu'ils sont moins bien class\u00e9s que n'importe lequel des joueurs class\u00e9s Vous devez \u00e9crire une fonction tete_de_serie(participants, classement) prenant en arguments la liste des joueurs inscrits au tournoi ainsi que le classement et renvoyant le pr\u00e9nom du joueur le mieux class\u00e9. Attention Le dictionnaire classement ne devra pas \u00eatre modifi\u00e9 lors de l'ex\u00e9cution de la fonction Si le tournoi ne comporte que des joueurs non-class\u00e9s, la fonction renverra le pr\u00e9nom du premier joueur de la liste. Exemples \ud83d\udc0d Console Python >>> classement = { 'Novak' : 1 , 'Daniil' : 2 , 'Alexander' : 3 , 'Stefanos' : 4 , 'Rafael' : 5 } >>> participants = [ 'Stefanos' , 'Novak' , 'Rafael' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'Stefanos' , 'Rafael' , 'David' , 'Novak' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'David' , 'Novak' , 'Alexander' , 'Daniil' ] >>> tete_de_serie ( participants , classement ) 'Novak' >>> participants = [ 'David' , 'Olivier' ] >>> tete_de_serie ( participants , classement ) 'David' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newline# On change de dictionnairebackslash-newlineclassement = {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Dictionnaire/classement videbackslash-newlineassert tetepython-underscoredepython-underscoreserie(['David', 'Rafael'], {}) == 'David'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['Dave', 'Oliver']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Dave'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Dave', 'Navok', 'Stephane']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Stephane'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newline# Tests - Que des joueurs class\u00c3\u00a9sbackslash-newlineparticipants = ['Navok', 'Stephane', 'Daniil', 'Rapha\u00c3\u00abl']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Rapha\u00c3\u00abl'backslash-newlineassert classement == {'Navok': 4, 'Dinaal': 5,backslash-newline 'Alexandre': 2, 'Stephane': 3, 'Rapha\u00c3\u00abl': 1}backslash-newlinebackslash-newline Valider 5/5 def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newline backslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline def tetepython-underscoredepython-underscoreserie(participants, classement):backslash-newline assert len(participants) > 0backslash-newlinebackslash-newline meilleurpython-underscorejoueur = participants[0]backslash-newline if meilleurpython-underscorejoueur in classement:backslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newline else:backslash-newline meilleurpython-underscoreclassement = len(classement)+1backslash-newlinebackslash-newline for joueur in participants:backslash-newline if joueur in classement and classement[joueur] < meilleurpython-underscoreclassement:backslash-newline meilleurpython-underscorejoueur = joueurbackslash-newline meilleurpython-underscoreclassement = classement[meilleurpython-underscorejoueur]backslash-newlinebackslash-newline return meilleurpython-underscorejoueurbackslash-newlinebackslash-newlinebackslash-newline# Tests - Joueurs class\u00c3\u00a9sbackslash-newlineclassement = {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlineparticipants = ['Stefanos', 'Novak', 'Rafael']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9backslash-newlineparticipants = ['Stefanos', 'Rafael', 'David', 'Novak']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Un joueur non-class\u00c3\u00a9 (bis)backslash-newlineparticipants = ['David', 'Novak', 'Alexander', 'Daniil']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'Novak'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline# Tests - Que des joueurs non-class\u00c3\u00a9sbackslash-newlineparticipants = ['David', 'Olivier']backslash-newlineassert tetepython-underscoredepython-underscoreserie(participants, classement) == 'David'backslash-newlineassert classement == {'Novak': 1, 'Daniil': 2,backslash-newline 'Alexander': 3, 'Stefanos': 4, 'Rafael': 5}backslash-newlinebackslash-newline A","title":"T\u00eate de s\u00e9rie"},{"location":"1-facile/1850-tete_de_serie/sujet/#commentaires","text":"Le probl\u00e8me revient \u00e0 s\u00e9lectionner le minimum dans une liste. Deux subtilit\u00e9s toutefois : la liste contient les \"\u00e9tiquettes\" des donn\u00e9es \u00e0 comparer (les pr\u00e9noms des joueurs alors que l'on compare les classements) certains joueurs n'ont pas de classement : on utilise alors une valeur par d\u00e9faut sup\u00e9rieure au plus grand classement possible","title":"Commentaires"},{"location":"1-facile/1850-tete_de_serie/sujet/#une-solution-possible","text":"{{ IDE('exo_corr') }} On v\u00e9rifie tout d'abord que la liste comporte au moins un joueur. On initialise ensuite la recherche en consid\u00e9rant que le premier joueur participant a le meilleur classement. Si ce joueur n'est pas class\u00e9, on lui donne la note de len(classement)+1 . La suite de la fonction est construite autour d'une boucle Pour chaque . On parcourt l'ensemble des participants et pour chacun on se demande : est-il class\u00e9 ? Si non, il ne peut pas \u00eatre mieux class\u00e9 que le \"meilleur\" actuel s'il est class\u00e9, est-il mieux class\u00e9 que le \"meilleur\" actuel ? Si oui, on met \u00e0 jour les valeurs La fonction se termine en renvoyant le pr\u00e9nom du joueur le mieux class\u00e9. Z","title":"Une solution possible"},{"location":"1-facile/1900-arbre_enracine/sujet/","tags":["arbre","boucle","r\u00e9cursivit\u00e9"],"text":"Hauteur et taille d'un arbre \u2693\ufe0e Dans tout le sujet, ici, arbre d\u00e9signe un arbre enracin\u00e9 . On rappelle que les arbres binaires ne sont pas des arbres enracin\u00e9s. On rappelle la d\u00e9finition d'un arbre : il s'agit d'une racine qui poss\u00e8de une \u00e9tiquette et \\(0\\) , \\(1\\) ou plusieurs sous-arbres qui sont des arbres. Un arbre enracin\u00e9 qui ne poss\u00e8de pas de sous-arbre est appel\u00e9 feuille. On mod\u00e9lise ici des arbres enracin\u00e9s sans \u00e9tiquette par des listes Python : la liste des sous-arbres. Utilisation Cette mod\u00e9lisation permet d'\u00e9crire des constructions du genre \ud83d\udc0d Script Python for sous_arbre in arbre : action ( sous_arbre ) Ou alors des listes en compr\u00e9hension \ud83d\udc0d Script Python [ action ( sous_arbre ) for sous_arbre in arbre ] Dans cet exercice , la d\u00e9finition de la hauteur d'un arbre est le nombre maximal de filiation pour rejoindre la racine \u00e0 une feuille. Une feuille est donc mod\u00e9lis\u00e9e par [] ; sa hauteur est z\u00e9ro. L'arbre repr\u00e9sent\u00e9 par [[], [], [[]]] se dessine ainsi ; sa hauteur est \\(2\\) : graph TD R{ } --> N1{ } R --> N2{ } R --> N3{ } N3 --> N4{ } \u00c9crire deux fonctions telles que : hauteur(arbre) renvoie la hauteur de l'arbre enracin\u00e9 donn\u00e9 en param\u00e8tre. taille(arbre) renvoie la taille de l'arbre enracin\u00e9 donn\u00e9 en param\u00e8tre. Dans cet exercice, on pourra utiliser les fonctions pr\u00e9d\u00e9finies max et sum . Exemples \ud83d\udc0d Console Python >>> hauteur ([]) 0 >>> hauteur ([[], [], [[]]]) 2 \ud83d\udc0d Console Python >>> taille ([]) 1 >>> taille ([[], [], [[]]]) 5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def hauteur(arbre):backslash-newline if arbre == []:backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(hauteur(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline if arbre == []:backslash-newline return 1backslash-newline else:backslash-newline return 1 + sum(taille(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert hauteur([[]]) == 1backslash-newlineassert hauteur([[], []]) == 1backslash-newlineassert hauteur([[], [], []]) == 1backslash-newlinebackslash-newlineassert hauteur([[], [[]], [[]], [], []]) == 2backslash-newlineassert hauteur([[], [[]], []]) == 2backslash-newlineassert hauteur([[[]], []]) == 2backslash-newlineassert hauteur([[], [[]]]) == 2backslash-newlineassert hauteur([[[]]]) == 2backslash-newlinebackslash-newlinebackslash-newlinebranche = [[], [[[], []]]]backslash-newlinearbre = [[branche], [[branche], [[branche]]]]backslash-newlineassert hauteur(arbre) == 7backslash-newlinebackslash-newlinebackslash-newlineassert taille([[]]) == 2backslash-newlineassert taille([[], []]) == 3backslash-newlineassert taille([[], [], []]) == 4backslash-newlinebackslash-newlineassert taille([[], [[]], [[]], [], []]) == 8backslash-newlineassert taille([[], [[]], []]) == 5backslash-newlineassert taille([[[]], []]) == 4backslash-newlineassert taille([[], [[]]]) == 4backslash-newlineassert taille([[[]]]) == 3backslash-newlinebackslash-newline Valider 5/5 def hauteur(arbre):backslash-newline ...backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline def hauteur(arbre):backslash-newline if arbre == []:backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(hauteur(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline if arbre == []:backslash-newline return 1backslash-newline else:backslash-newline return 1 + sum(taille(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline A Z","title":"Hauteur et taille d'un arbre"},{"location":"1-facile/1900-arbre_enracine/sujet/#hauteur-et-taille-dun-arbre","text":"Dans tout le sujet, ici, arbre d\u00e9signe un arbre enracin\u00e9 . On rappelle que les arbres binaires ne sont pas des arbres enracin\u00e9s. On rappelle la d\u00e9finition d'un arbre : il s'agit d'une racine qui poss\u00e8de une \u00e9tiquette et \\(0\\) , \\(1\\) ou plusieurs sous-arbres qui sont des arbres. Un arbre enracin\u00e9 qui ne poss\u00e8de pas de sous-arbre est appel\u00e9 feuille. On mod\u00e9lise ici des arbres enracin\u00e9s sans \u00e9tiquette par des listes Python : la liste des sous-arbres. Utilisation Cette mod\u00e9lisation permet d'\u00e9crire des constructions du genre \ud83d\udc0d Script Python for sous_arbre in arbre : action ( sous_arbre ) Ou alors des listes en compr\u00e9hension \ud83d\udc0d Script Python [ action ( sous_arbre ) for sous_arbre in arbre ] Dans cet exercice , la d\u00e9finition de la hauteur d'un arbre est le nombre maximal de filiation pour rejoindre la racine \u00e0 une feuille. Une feuille est donc mod\u00e9lis\u00e9e par [] ; sa hauteur est z\u00e9ro. L'arbre repr\u00e9sent\u00e9 par [[], [], [[]]] se dessine ainsi ; sa hauteur est \\(2\\) : graph TD R{ } --> N1{ } R --> N2{ } R --> N3{ } N3 --> N4{ } \u00c9crire deux fonctions telles que : hauteur(arbre) renvoie la hauteur de l'arbre enracin\u00e9 donn\u00e9 en param\u00e8tre. taille(arbre) renvoie la taille de l'arbre enracin\u00e9 donn\u00e9 en param\u00e8tre. Dans cet exercice, on pourra utiliser les fonctions pr\u00e9d\u00e9finies max et sum . Exemples \ud83d\udc0d Console Python >>> hauteur ([]) 0 >>> hauteur ([[], [], [[]]]) 2 \ud83d\udc0d Console Python >>> taille ([]) 1 >>> taille ([[], [], [[]]]) 5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def hauteur(arbre):backslash-newline if arbre == []:backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(hauteur(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline if arbre == []:backslash-newline return 1backslash-newline else:backslash-newline return 1 + sum(taille(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert hauteur([[]]) == 1backslash-newlineassert hauteur([[], []]) == 1backslash-newlineassert hauteur([[], [], []]) == 1backslash-newlinebackslash-newlineassert hauteur([[], [[]], [[]], [], []]) == 2backslash-newlineassert hauteur([[], [[]], []]) == 2backslash-newlineassert hauteur([[[]], []]) == 2backslash-newlineassert hauteur([[], [[]]]) == 2backslash-newlineassert hauteur([[[]]]) == 2backslash-newlinebackslash-newlinebackslash-newlinebranche = [[], [[[], []]]]backslash-newlinearbre = [[branche], [[branche], [[branche]]]]backslash-newlineassert hauteur(arbre) == 7backslash-newlinebackslash-newlinebackslash-newlineassert taille([[]]) == 2backslash-newlineassert taille([[], []]) == 3backslash-newlineassert taille([[], [], []]) == 4backslash-newlinebackslash-newlineassert taille([[], [[]], [[]], [], []]) == 8backslash-newlineassert taille([[], [[]], []]) == 5backslash-newlineassert taille([[[]], []]) == 4backslash-newlineassert taille([[], [[]]]) == 4backslash-newlineassert taille([[[]]]) == 3backslash-newlinebackslash-newline Valider 5/5 def hauteur(arbre):backslash-newline ...backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline def hauteur(arbre):backslash-newline if arbre == []:backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(hauteur(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinedef taille(arbre):backslash-newline if arbre == []:backslash-newline return 1backslash-newline else:backslash-newline return 1 + sum(taille(souspython-underscorearbre) for souspython-underscorearbre in arbre)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hauteur([]) == 0backslash-newlineassert hauteur([[], [], [[]]]) == 2backslash-newlinebackslash-newlineassert taille([]) == 1backslash-newlineassert taille([[], [], [[]]]) == 5backslash-newlinebackslash-newline A Z","title":"Hauteur et taille d'un arbre"},{"location":"2-moyen/ABR/sujet/","tags":["arbre","boucle","r\u00e9cursivit\u00e9","POO"],"text":"Arbre binaire de recherche \u2693\ufe0e On donne une partie de la classe ABR pour impl\u00e9menter les arbres binaires de recherche sans doublon : un ensemble fini de n\u0153uds, \u00e9ventuellement vide, organis\u00e9s de mani\u00e8re hi\u00e9rarchique. C'est une arborescence d'\u00e9l\u00e9ments comparables. Un ABR est une structure de nature r\u00e9cursive : soit c'est un ABR vide, soit il poss\u00e8de un n\u0153ud racine qui a les attributs : gauche : un sous-ABR \u00e0 gauche element : un \u00e9l\u00e9ment comparable aux autres droite : un sous-ABR \u00e0 droite l'\u00e9l\u00e9ment de la racine est strictement sup\u00e9rieure \u00e0 celui du sous-ABR gauche (s'il est non vide) l'\u00e9l\u00e9ment de la racine est strictement inf\u00e9rieure \u00e0 celui du sous-ABR droite (s'il est non vide) Dans l'impl\u00e9mentation suivante : ABR () initialise un ABR vide. Un ABR, vide ou non , poss\u00e8de les m\u00e9thodes dont le nom est explicite : est_vide(self) qui renvoie un bool\u00e9en insere(self, element) qui agit sur l'ABR est_present(self, element) qui renvoie un bool\u00e9en affichage_infixe(self) qui renvoie une chaine de caract\u00e8re compos\u00e9e des affichages des \u00e9l\u00e9ments et d'un s\u00e9parateur, suite \u00e0 un parcours infixe. On compl\u00e8tera le code suivant : \ud83d\udc0d Script Python class Noeud : def __init__ ( self , gauche , element , droite ): self . gauche = gauche self . element = element self . droite = droite class ABR : \"\"\"Classe ABR ; sans doublon \"\"\" def __init__ ( self ): self . racine = None def est_vide ( self ): return self . racine is None def insere ( self , element ): if self . est_vide (): self . racine = Noeud ( ABR (), element , ABR ()) elif element < self . racine . element : self . racine . gauche . insere ( element ) elif element > self . racine . element : ... else : # cas d'\u00c3\u00a9galit\u00c3\u00a9 pass # donc pas de doublon ! def est_present ( self , element ): if self . est_vide (): return ... elif element < self . racine . element : return self . racine . gauche . est_present ( element ) elif ... : ... else : # cas d'\u00c3\u00a9galit\u00c3\u00a9 return True def affichage_infixe ( self ): if self . est_vide (): return \"|\" else : return ( self . racine . gauche . affichage_infixe () + str ( self . racine . ... ) + self . racine . ... ) Exemples \ud83d\udc0d Console Python >>> nombres = ABR () >>> nombres . est_vide () True >>> for x in [ 1 , 3 , 7 , 9 , 9 ]: nombres . insere ( x ) >>> not nombres . est_vide () False >>> nombres . affichage_infixe () '|1|3|7|9|' >>> nombres . est_present ( 7 ) True >>> nombres . est_present ( 8 ) False \ud83d\udc0d Console Python >>> fruits_ranges = ABR () >>> fruits_ranges . est_vide () True >>> panier = [ \"kiwi\" , \"pomme\" , \"abricot\" , \"mangue\" , \"poire\" ] >>> for fruit in panier : fruits_ranges . insere ( fruit ) >>> fruits_ranges . est_vide () False >>> fruits_ranges . affichage_infixe () '|abricot|kiwi|mangue|poire|pomme|' >>> fruits_ranges . est_present ( \"pomme\" ) True >>> fruits_ranges . est_present ( \"cerise\" ) False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef permutations(objets):backslash-newline n = len(objets)backslash-newline if n == 0:backslash-newline return [[]]backslash-newline resultat = []backslash-newline for i in range(n):backslash-newline objetspython-underscoresanspython-underscorei = [objets[j] for j in range(n) if i != j]backslash-newline for perm in permutations(objetspython-underscoresanspython-underscorei):backslash-newline perm.append(objets[i])backslash-newline resultat.append(perm)backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinefor perm in permutations([1, 2, 3, 4, 5]):backslash-newline abr = ABR()backslash-newline assert abr.estpython-underscorevide()backslash-newline for x in perm: abr.insere(x)backslash-newline for x in range(-5, 10):backslash-newline attendu = 1 < = x < 6backslash-newline assert abr.estpython-underscorepresent(x) == attendubackslash-newline assert abr.affichagepython-underscoreinfixe() == '|1|2|3|4|5|'backslash-newlinebackslash-newline Valider 5/5 class Noeud:backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, element, droite):backslash-newline self.gauche = gauchebackslash-newline self.element = elementbackslash-newline self.droite = droitebackslash-newlinebackslash-newlineclass ABR:backslash-newline \"\"\"Classe ABR ; sans doublonbackslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self):backslash-newline self.racine = Nonebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.racine is Nonebackslash-newline backslash-newline def insere(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline self.racine = Noeud(ABR(), element, ABR())backslash-newline elif element < self.racine.element:backslash-newline self.racine.gauche.insere(element)backslash-newline elif element > self.racine.element:backslash-newline ...backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline pass # donc pas de doublon !backslash-newline backslash-newline def estpython-underscorepresent(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline return ...backslash-newline elif element < self.racine.element:backslash-newline return self.racine.gauche.estpython-underscorepresent(element)backslash-newline elif ...:backslash-newline ...backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline return Truebackslash-newline backslash-newline def affichagepython-underscoreinfixe(self):backslash-newline if self.estpython-underscorevide():backslash-newline return \"|\"backslash-newline else:backslash-newline return (backslash-newline self.racine.gauche.affichagepython-underscoreinfixe()backslash-newline + str(self.racine. ...)backslash-newline + self.racine. ...backslash-newline )backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newline class Noeud:backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, element, droite):backslash-newline self.gauche = gauchebackslash-newline self.element = elementbackslash-newline self.droite = droitebackslash-newlinebackslash-newlineclass ABR:backslash-newline \"\"\"Classe ABR ; sans doublonbackslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self):backslash-newline self.racine = Nonebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.racine is Nonebackslash-newline backslash-newline def insere(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline self.racine = Noeud(ABR(), element, ABR())backslash-newline elif element < self.racine.element:backslash-newline self.racine.gauche.insere(element)backslash-newline elif element > self.racine.element:backslash-newline self.racine.droite.insere(element)backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline pass # donc pas de doublon !backslash-newline backslash-newline def estpython-underscorepresent(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline return Falsebackslash-newline elif element < self.racine.element:backslash-newline return self.racine.gauche.estpython-underscorepresent(element)backslash-newline elif element > self.racine.element:backslash-newline return self.racine.droite.estpython-underscorepresent(element)backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline return Truebackslash-newline backslash-newline def affichagepython-underscoreinfixe(self):backslash-newline if self.estpython-underscorevide():backslash-newline return \"|\"backslash-newline else:backslash-newline return (backslash-newline self.racine.gauche.affichagepython-underscoreinfixe()backslash-newline + str(self.racine.element)backslash-newline + self.racine.droite.affichagepython-underscoreinfixe()backslash-newline )backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newline A Z","title":"Arbre binaire de recherche"},{"location":"2-moyen/ABR/sujet/#arbre-binaire-de-recherche","text":"On donne une partie de la classe ABR pour impl\u00e9menter les arbres binaires de recherche sans doublon : un ensemble fini de n\u0153uds, \u00e9ventuellement vide, organis\u00e9s de mani\u00e8re hi\u00e9rarchique. C'est une arborescence d'\u00e9l\u00e9ments comparables. Un ABR est une structure de nature r\u00e9cursive : soit c'est un ABR vide, soit il poss\u00e8de un n\u0153ud racine qui a les attributs : gauche : un sous-ABR \u00e0 gauche element : un \u00e9l\u00e9ment comparable aux autres droite : un sous-ABR \u00e0 droite l'\u00e9l\u00e9ment de la racine est strictement sup\u00e9rieure \u00e0 celui du sous-ABR gauche (s'il est non vide) l'\u00e9l\u00e9ment de la racine est strictement inf\u00e9rieure \u00e0 celui du sous-ABR droite (s'il est non vide) Dans l'impl\u00e9mentation suivante : ABR () initialise un ABR vide. Un ABR, vide ou non , poss\u00e8de les m\u00e9thodes dont le nom est explicite : est_vide(self) qui renvoie un bool\u00e9en insere(self, element) qui agit sur l'ABR est_present(self, element) qui renvoie un bool\u00e9en affichage_infixe(self) qui renvoie une chaine de caract\u00e8re compos\u00e9e des affichages des \u00e9l\u00e9ments et d'un s\u00e9parateur, suite \u00e0 un parcours infixe. On compl\u00e8tera le code suivant : \ud83d\udc0d Script Python class Noeud : def __init__ ( self , gauche , element , droite ): self . gauche = gauche self . element = element self . droite = droite class ABR : \"\"\"Classe ABR ; sans doublon \"\"\" def __init__ ( self ): self . racine = None def est_vide ( self ): return self . racine is None def insere ( self , element ): if self . est_vide (): self . racine = Noeud ( ABR (), element , ABR ()) elif element < self . racine . element : self . racine . gauche . insere ( element ) elif element > self . racine . element : ... else : # cas d'\u00c3\u00a9galit\u00c3\u00a9 pass # donc pas de doublon ! def est_present ( self , element ): if self . est_vide (): return ... elif element < self . racine . element : return self . racine . gauche . est_present ( element ) elif ... : ... else : # cas d'\u00c3\u00a9galit\u00c3\u00a9 return True def affichage_infixe ( self ): if self . est_vide (): return \"|\" else : return ( self . racine . gauche . affichage_infixe () + str ( self . racine . ... ) + self . racine . ... ) Exemples \ud83d\udc0d Console Python >>> nombres = ABR () >>> nombres . est_vide () True >>> for x in [ 1 , 3 , 7 , 9 , 9 ]: nombres . insere ( x ) >>> not nombres . est_vide () False >>> nombres . affichage_infixe () '|1|3|7|9|' >>> nombres . est_present ( 7 ) True >>> nombres . est_present ( 8 ) False \ud83d\udc0d Console Python >>> fruits_ranges = ABR () >>> fruits_ranges . est_vide () True >>> panier = [ \"kiwi\" , \"pomme\" , \"abricot\" , \"mangue\" , \"poire\" ] >>> for fruit in panier : fruits_ranges . insere ( fruit ) >>> fruits_ranges . est_vide () False >>> fruits_ranges . affichage_infixe () '|abricot|kiwi|mangue|poire|pomme|' >>> fruits_ranges . est_present ( \"pomme\" ) True >>> fruits_ranges . est_present ( \"cerise\" ) False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef permutations(objets):backslash-newline n = len(objets)backslash-newline if n == 0:backslash-newline return [[]]backslash-newline resultat = []backslash-newline for i in range(n):backslash-newline objetspython-underscoresanspython-underscorei = [objets[j] for j in range(n) if i != j]backslash-newline for perm in permutations(objetspython-underscoresanspython-underscorei):backslash-newline perm.append(objets[i])backslash-newline resultat.append(perm)backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinefor perm in permutations([1, 2, 3, 4, 5]):backslash-newline abr = ABR()backslash-newline assert abr.estpython-underscorevide()backslash-newline for x in perm: abr.insere(x)backslash-newline for x in range(-5, 10):backslash-newline attendu = 1 < = x < 6backslash-newline assert abr.estpython-underscorepresent(x) == attendubackslash-newline assert abr.affichagepython-underscoreinfixe() == '|1|2|3|4|5|'backslash-newlinebackslash-newline Valider 5/5 class Noeud:backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, element, droite):backslash-newline self.gauche = gauchebackslash-newline self.element = elementbackslash-newline self.droite = droitebackslash-newlinebackslash-newlineclass ABR:backslash-newline \"\"\"Classe ABR ; sans doublonbackslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self):backslash-newline self.racine = Nonebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.racine is Nonebackslash-newline backslash-newline def insere(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline self.racine = Noeud(ABR(), element, ABR())backslash-newline elif element < self.racine.element:backslash-newline self.racine.gauche.insere(element)backslash-newline elif element > self.racine.element:backslash-newline ...backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline pass # donc pas de doublon !backslash-newline backslash-newline def estpython-underscorepresent(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline return ...backslash-newline elif element < self.racine.element:backslash-newline return self.racine.gauche.estpython-underscorepresent(element)backslash-newline elif ...:backslash-newline ...backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline return Truebackslash-newline backslash-newline def affichagepython-underscoreinfixe(self):backslash-newline if self.estpython-underscorevide():backslash-newline return \"|\"backslash-newline else:backslash-newline return (backslash-newline self.racine.gauche.affichagepython-underscoreinfixe()backslash-newline + str(self.racine. ...)backslash-newline + self.racine. ...backslash-newline )backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newline class Noeud:backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, element, droite):backslash-newline self.gauche = gauchebackslash-newline self.element = elementbackslash-newline self.droite = droitebackslash-newlinebackslash-newlineclass ABR:backslash-newline \"\"\"Classe ABR ; sans doublonbackslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self):backslash-newline self.racine = Nonebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.racine is Nonebackslash-newline backslash-newline def insere(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline self.racine = Noeud(ABR(), element, ABR())backslash-newline elif element < self.racine.element:backslash-newline self.racine.gauche.insere(element)backslash-newline elif element > self.racine.element:backslash-newline self.racine.droite.insere(element)backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline pass # donc pas de doublon !backslash-newline backslash-newline def estpython-underscorepresent(self, element):backslash-newline if self.estpython-underscorevide():backslash-newline return Falsebackslash-newline elif element < self.racine.element:backslash-newline return self.racine.gauche.estpython-underscorepresent(element)backslash-newline elif element > self.racine.element:backslash-newline return self.racine.droite.estpython-underscorepresent(element)backslash-newline else:backslash-newline # cas d'\u00c3\u00a9galit\u00c3\u00a9backslash-newline return Truebackslash-newline backslash-newline def affichagepython-underscoreinfixe(self):backslash-newline if self.estpython-underscorevide():backslash-newline return \"|\"backslash-newline else:backslash-newline return (backslash-newline self.racine.gauche.affichagepython-underscoreinfixe()backslash-newline + str(self.racine.element)backslash-newline + self.racine.droite.affichagepython-underscoreinfixe()backslash-newline )backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = ABR()backslash-newlineassert nombres.estpython-underscorevide()backslash-newlinefor x in [1, 3, 7, 9, 9]:backslash-newline nombres.insere(x)backslash-newlineassert not nombres.estpython-underscorevide()backslash-newlinebackslash-newlineassert nombres.affichagepython-underscoreinfixe() == '|1|3|7|9|'backslash-newlinebackslash-newlineassert nombres.estpython-underscorepresent(7)backslash-newlineassert not nombres.estpython-underscorepresent(8)backslash-newlinebackslash-newline#2backslash-newlinefruitspython-underscoreranges = ABR()backslash-newlineassert fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlinepanier = [\"kiwi\", \"pomme\", \"abricot\", \"mangue\", \"poire\"]backslash-newlinefor fruit in panier:backslash-newline fruitspython-underscoreranges.insere(fruit)backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorevide()backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.affichagepython-underscoreinfixe() == '|abricot|kiwi|mangue|poire|pomme|'backslash-newlinebackslash-newlineassert fruitspython-underscoreranges.estpython-underscorepresent(\"pomme\")backslash-newlineassert not fruitspython-underscoreranges.estpython-underscorepresent(\"cerise\")backslash-newlinebackslash-newline A Z","title":"Arbre binaire de recherche"},{"location":"2-moyen/anagrammes/exo_REM/","text":"Commentaires \u2693\ufe0e Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def supprimepython-underscorepremier(chaine: str, cible: str) -> str:backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline resultat = \"\"backslash-newline present = Falsebackslash-newline for caractere in chaine:backslash-newline if caractere != cible:backslash-newline resultat += caracterebackslash-newline elif not present:backslash-newline present = Truebackslash-newline else:backslash-newline resultat += caracterebackslash-newlinebackslash-newline return (present, resultat)backslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1: str, chaine2: str) -> bool:backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline if len(chaine1) == 1:backslash-newline return chaine1 == chaine2backslash-newline else:backslash-newline cible = chaine1[0]backslash-newline vrai, chaine1python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine1, cible)backslash-newline ciblepython-underscoredanspython-underscore2, chaine2python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine2, cible)backslash-newline if ciblepython-underscoredanspython-underscore2:backslash-newline return anagrammes(chaine1python-underscoresanspython-underscorecible, chaine2python-underscoresanspython-underscorecible)backslash-newline else:backslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline A Z La fonction supprime_premier n\u00e9cessite de distinguer plusieurs cas de figure : le caract\u00e8re lu est diff\u00e9rent du caract\u00e8re cherch\u00e9 : on le recopie le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il n'a pas encore \u00e9t\u00e9 trouv\u00e9 ( present toujours \u00e0 False ) : on ne le recopie pas mais on indique qu'on l'a trouv\u00e9 et supprim\u00e9 ( present = True ) le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il a d\u00e9j\u00e0 \u00e9t\u00e9 trouv\u00e9/supprim\u00e9 : on le recopie on renvoie pour finir le couple (present, resultat) Pour la fonction anagrammes : si les deux cha\u00eenes sont de longueur 1, on renvoie le r\u00e9sultat de leur comparaison (cas de base de la r\u00e9cursivit\u00e9) sinon, on supprime le premier caract\u00e8re de chaine1 dans les deux cha\u00eenes chacun des appels supprime_premier(chaine, cible) renvoie la cha\u00eene r\u00e9duite mais aussi un bool\u00e9en indiquant si la cible \u00e9tait pr\u00e9sente dans la cha\u00eene on se demande alors si cible \u00e9tait dans chaine2 (le premier caract\u00e8re de chaine1 est n\u00e9cessairement dans chaine1 ). On teste donc le bool\u00e9en renvoy\u00e9 par supprime_premier(chaine2, cible) : si c'est le cas, on appelle la fonction sur ces cha\u00eenes \"r\u00e9duites\" si ce n'est pas le cas, on renvoie False directement","title":"Commentaires"},{"location":"2-moyen/anagrammes/exo_REM/#commentaires","text":"Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def supprimepython-underscorepremier(chaine: str, cible: str) -> str:backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline resultat = \"\"backslash-newline present = Falsebackslash-newline for caractere in chaine:backslash-newline if caractere != cible:backslash-newline resultat += caracterebackslash-newline elif not present:backslash-newline present = Truebackslash-newline else:backslash-newline resultat += caracterebackslash-newlinebackslash-newline return (present, resultat)backslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1: str, chaine2: str) -> bool:backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline if len(chaine1) == 1:backslash-newline return chaine1 == chaine2backslash-newline else:backslash-newline cible = chaine1[0]backslash-newline vrai, chaine1python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine1, cible)backslash-newline ciblepython-underscoredanspython-underscore2, chaine2python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine2, cible)backslash-newline if ciblepython-underscoredanspython-underscore2:backslash-newline return anagrammes(chaine1python-underscoresanspython-underscorecible, chaine2python-underscoresanspython-underscorecible)backslash-newline else:backslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline A Z La fonction supprime_premier n\u00e9cessite de distinguer plusieurs cas de figure : le caract\u00e8re lu est diff\u00e9rent du caract\u00e8re cherch\u00e9 : on le recopie le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il n'a pas encore \u00e9t\u00e9 trouv\u00e9 ( present toujours \u00e0 False ) : on ne le recopie pas mais on indique qu'on l'a trouv\u00e9 et supprim\u00e9 ( present = True ) le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il a d\u00e9j\u00e0 \u00e9t\u00e9 trouv\u00e9/supprim\u00e9 : on le recopie on renvoie pour finir le couple (present, resultat) Pour la fonction anagrammes : si les deux cha\u00eenes sont de longueur 1, on renvoie le r\u00e9sultat de leur comparaison (cas de base de la r\u00e9cursivit\u00e9) sinon, on supprime le premier caract\u00e8re de chaine1 dans les deux cha\u00eenes chacun des appels supprime_premier(chaine, cible) renvoie la cha\u00eene r\u00e9duite mais aussi un bool\u00e9en indiquant si la cible \u00e9tait pr\u00e9sente dans la cha\u00eene on se demande alors si cible \u00e9tait dans chaine2 (le premier caract\u00e8re de chaine1 est n\u00e9cessairement dans chaine1 ). On teste donc le bool\u00e9en renvoy\u00e9 par supprime_premier(chaine2, cible) : si c'est le cas, on appelle la fonction sur ces cha\u00eenes \"r\u00e9duites\" si ce n'est pas le cas, on renvoie False directement","title":"Commentaires"},{"location":"2-moyen/anagrammes/sujet/","text":"Anagrammes \u2693\ufe0e Deux cha\u00eenes de caract\u00e8res de m\u00eames longueurs sont des anagrammes s'il est possible d'\u00e9crire l'une en utilisant tous les caract\u00e8res de l'autre, quitte \u00e0 les d\u00e9placer. Par exemple les cha\u00eenes chien et niche sont des anagrammes, alors que louve et poule ne le sont pas. D\u00e9terminer si deux cha\u00eenes de caract\u00e8res sont des anagrammes peut se faire en les comparant apr\u00e8s les avoir tri\u00e9es. On utilise ici une autre approche, r\u00e9cursive : si les deux cha\u00eenes sont de longueur 1, on renvoie True ou False selon qu'elles sont \u00e9gales ou non sinon, on teste si le premier caract\u00e8re de la premi\u00e8re se trouve aussi dans la seconde : si oui, on recommence le test sur les deux cha\u00eenes dans lesquelles on a retir\u00e9 la premi\u00e8re apparition du caract\u00e8re test\u00e9 si non, on renvoie False Exemple Pour tester si chien et niche sont des anagrammes : on observe que c est bien dans niche on teste si hien et nihe sont des anagrammes on observe que h est bien dans nihe on teste si ien et nie sont des anagrammes ... on observe que n et n sont \u00e9gales : on renvoie True Vous devez \u00e9crire deux fonctions : supprime_premier(chaine, cible) renvoie un couple (present, chaine_sans_cible) dans lequel present est un bool\u00e9en indiquant si le caract\u00e8re cible est pr\u00e9sent dans chaine et chaine_sans_cible la m\u00eame cha\u00eene sans la premi\u00e8re occurrence de cible anagramme(chaine1, chaine2) renvoie True si les deux cha\u00eenes sont des anagrammes, False sinon On garantit que les deux cha\u00eenes sont non vides. Exemples \ud83d\udc0d Console Python >>> supprime_premier ( 'ukul\u00e9l\u00e9' , 'u' ) (True, 'kul\u00e9l\u00e9') >>> supprime_premier ( 'ukul\u00e9l\u00e9' , '\u00e9' ) (True, 'ukull\u00e9') >>> supprime_premier ( 'ukul\u00e9l\u00e9' , 'a' ) (False, 'ukul\u00e9l\u00e9') >>> anagrammes ( 'chien' , 'niche' ) True >>> anagrammes ( '\u00e9nergie noire' , 'reine ignor\u00e9e' ) True >>> anagrammes ( 'louve' , 'poule' ) False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline Valider 5/5 def supprimepython-underscorepremier(chaine, cible):backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline passbackslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1, chaine2):backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline passbackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline def supprimepython-underscorepremier(chaine: str, cible: str) -> str:backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline resultat = \"\"backslash-newline present = Falsebackslash-newline for caractere in chaine:backslash-newline if caractere != cible:backslash-newline resultat += caracterebackslash-newline elif not present:backslash-newline present = Truebackslash-newline else:backslash-newline resultat += caracterebackslash-newlinebackslash-newline return (present, resultat)backslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1: str, chaine2: str) -> bool:backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline if len(chaine1) == 1:backslash-newline return chaine1 == chaine2backslash-newline else:backslash-newline cible = chaine1[0]backslash-newline vrai, chaine1python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine1, cible)backslash-newline ciblepython-underscoredanspython-underscore2, chaine2python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine2, cible)backslash-newline if ciblepython-underscoredanspython-underscore2:backslash-newline return anagrammes(chaine1python-underscoresanspython-underscorecible, chaine2python-underscoresanspython-underscorecible)backslash-newline else:backslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ IDE('exo_corr') }} La fonction supprime_premier n\u00e9cessite de distinguer plusieurs cas de figure : le caract\u00e8re lu est diff\u00e9rent du caract\u00e8re cherch\u00e9 : on le recopie le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il n'a pas encore \u00e9t\u00e9 trouv\u00e9 ( present toujours \u00e0 False ) : on ne le recopie pas mais on indique qu'on l'a trouv\u00e9 et supprim\u00e9 ( present = True ) le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il a d\u00e9j\u00e0 \u00e9t\u00e9 trouv\u00e9/supprim\u00e9 : on le recopie on renvoie pour finir le couple (present, resultat) Pour la fonction anagrammes : si les deux cha\u00eenes sont de longueur 1, on renvoie le r\u00e9sultat de leur comparaison (cas de base de la r\u00e9cursivit\u00e9) sinon, on supprime le premier caract\u00e8re de chaine1 dans les deux cha\u00eenes chacun des appels supprime_premier(chaine, cible) renvoie la cha\u00eene r\u00e9duite mais aussi un bool\u00e9en indiquant si la cible \u00e9tait pr\u00e9sente dans la cha\u00eene on se demande alors si cible \u00e9tait dans chaine2 (le premier caract\u00e8re de chaine1 est n\u00e9cessairement dans chaine1 ). On teste donc le bool\u00e9en renvoy\u00e9 par supprime_premier(chaine2, cible) : si c'est le cas, on appelle la fonction sur ces cha\u00eenes \"r\u00e9duites\" si ce n'est pas le cas, on renvoie False directement Z","title":"Anagrammes"},{"location":"2-moyen/anagrammes/sujet/#anagrammes","text":"Deux cha\u00eenes de caract\u00e8res de m\u00eames longueurs sont des anagrammes s'il est possible d'\u00e9crire l'une en utilisant tous les caract\u00e8res de l'autre, quitte \u00e0 les d\u00e9placer. Par exemple les cha\u00eenes chien et niche sont des anagrammes, alors que louve et poule ne le sont pas. D\u00e9terminer si deux cha\u00eenes de caract\u00e8res sont des anagrammes peut se faire en les comparant apr\u00e8s les avoir tri\u00e9es. On utilise ici une autre approche, r\u00e9cursive : si les deux cha\u00eenes sont de longueur 1, on renvoie True ou False selon qu'elles sont \u00e9gales ou non sinon, on teste si le premier caract\u00e8re de la premi\u00e8re se trouve aussi dans la seconde : si oui, on recommence le test sur les deux cha\u00eenes dans lesquelles on a retir\u00e9 la premi\u00e8re apparition du caract\u00e8re test\u00e9 si non, on renvoie False Exemple Pour tester si chien et niche sont des anagrammes : on observe que c est bien dans niche on teste si hien et nihe sont des anagrammes on observe que h est bien dans nihe on teste si ien et nie sont des anagrammes ... on observe que n et n sont \u00e9gales : on renvoie True Vous devez \u00e9crire deux fonctions : supprime_premier(chaine, cible) renvoie un couple (present, chaine_sans_cible) dans lequel present est un bool\u00e9en indiquant si le caract\u00e8re cible est pr\u00e9sent dans chaine et chaine_sans_cible la m\u00eame cha\u00eene sans la premi\u00e8re occurrence de cible anagramme(chaine1, chaine2) renvoie True si les deux cha\u00eenes sont des anagrammes, False sinon On garantit que les deux cha\u00eenes sont non vides. Exemples \ud83d\udc0d Console Python >>> supprime_premier ( 'ukul\u00e9l\u00e9' , 'u' ) (True, 'kul\u00e9l\u00e9') >>> supprime_premier ( 'ukul\u00e9l\u00e9' , '\u00e9' ) (True, 'ukull\u00e9') >>> supprime_premier ( 'ukul\u00e9l\u00e9' , 'a' ) (False, 'ukul\u00e9l\u00e9') >>> anagrammes ( 'chien' , 'niche' ) True >>> anagrammes ( '\u00e9nergie noire' , 'reine ignor\u00e9e' ) True >>> anagrammes ( 'louve' , 'poule' ) False Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline Valider 5/5 def supprimepython-underscorepremier(chaine, cible):backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline passbackslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1, chaine2):backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline passbackslash-newlinebackslash-newline# Testsbackslash-newlinebackslash-newlinebackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline def supprimepython-underscorepremier(chaine: str, cible: str) -> str:backslash-newline assert len(cible) == 1, \"caractere doit \u00c3\u00aatre une cha\u00c3\u00aene de longueur 1\"backslash-newlinebackslash-newline resultat = \"\"backslash-newline present = Falsebackslash-newline for caractere in chaine:backslash-newline if caractere != cible:backslash-newline resultat += caracterebackslash-newline elif not present:backslash-newline present = Truebackslash-newline else:backslash-newline resultat += caracterebackslash-newlinebackslash-newline return (present, resultat)backslash-newlinebackslash-newlinebackslash-newlinedef anagrammes(chaine1: str, chaine2: str) -> bool:backslash-newline assert len(chaine1) == len(backslash-newline chaine2), \"Les deux cha\u00c3\u00aenes doivent avoir la m\u00c3\u00aame taille\"backslash-newlinebackslash-newline if len(chaine1) == 1:backslash-newline return chaine1 == chaine2backslash-newline else:backslash-newline cible = chaine1[0]backslash-newline vrai, chaine1python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine1, cible)backslash-newline ciblepython-underscoredanspython-underscore2, chaine2python-underscoresanspython-underscorecible = supprimepython-underscorepremier(chaine2, cible)backslash-newline if ciblepython-underscoredanspython-underscore2:backslash-newline return anagrammes(chaine1python-underscoresanspython-underscorecible, chaine2python-underscoresanspython-underscorecible)backslash-newline else:backslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'u') == (True, 'kul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', '\u00c3\u00a9') == (True, 'ukull\u00c3\u00a9')backslash-newlineassert supprimepython-underscorepremier('ukul\u00c3\u00a9l\u00c3\u00a9', 'a') == (False, 'ukul\u00c3\u00a9l\u00c3\u00a9')backslash-newlineassert anagrammes('chien', 'niche')backslash-newlineassert anagrammes('\u00c3\u00a9nergie noire', 'reine ignor\u00c3\u00a9e')backslash-newlineassert not anagrammes('louve', 'poule')backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineassert supprimepython-underscorepremier('mississippi', 'm') == (True, 'ississippi')backslash-newlineassert supprimepython-underscorepremier('mississippi', 'a') == (False, 'mississippi')backslash-newlineassert anagrammes('nsi', 'isn')backslash-newlineassert not anagrammes('nsi', 'snt')backslash-newlineassert anagrammes('clint eastwood', 'old west action')backslash-newlineassert anagrammes('astronomers ', 'moon starers')backslash-newlineassert not anagrammes('astronome', 'metronome')backslash-newlinebackslash-newline A","title":"Anagrammes"},{"location":"2-moyen/anagrammes/sujet/#commentaires","text":"{{ IDE('exo_corr') }} La fonction supprime_premier n\u00e9cessite de distinguer plusieurs cas de figure : le caract\u00e8re lu est diff\u00e9rent du caract\u00e8re cherch\u00e9 : on le recopie le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il n'a pas encore \u00e9t\u00e9 trouv\u00e9 ( present toujours \u00e0 False ) : on ne le recopie pas mais on indique qu'on l'a trouv\u00e9 et supprim\u00e9 ( present = True ) le caract\u00e8re lu est \u00e9gal au caract\u00e8re cherch\u00e9 et il a d\u00e9j\u00e0 \u00e9t\u00e9 trouv\u00e9/supprim\u00e9 : on le recopie on renvoie pour finir le couple (present, resultat) Pour la fonction anagrammes : si les deux cha\u00eenes sont de longueur 1, on renvoie le r\u00e9sultat de leur comparaison (cas de base de la r\u00e9cursivit\u00e9) sinon, on supprime le premier caract\u00e8re de chaine1 dans les deux cha\u00eenes chacun des appels supprime_premier(chaine, cible) renvoie la cha\u00eene r\u00e9duite mais aussi un bool\u00e9en indiquant si la cible \u00e9tait pr\u00e9sente dans la cha\u00eene on se demande alors si cible \u00e9tait dans chaine2 (le premier caract\u00e8re de chaine1 est n\u00e9cessairement dans chaine1 ). On teste donc le bool\u00e9en renvoy\u00e9 par supprime_premier(chaine2, cible) : si c'est le cas, on appelle la fonction sur ces cha\u00eenes \"r\u00e9duites\" si ce n'est pas le cas, on renvoie False directement Z","title":"Commentaires"},{"location":"2-moyen/arbre_bin/sujet/","tags":["arbre","boucle","r\u00e9cursivit\u00e9","POO"],"text":"Arbre binaire \u2693\ufe0e On rappelle qu'il existe parfois des variations dans les d\u00e9finitions des structures arborescentes, et que pendant un exercice, il faut suivre celles donn\u00e9es dans l'\u00e9nonc\u00e9. On peut d\u00e9finir un arbre binaire par : Soit un arbre binaire vide (souvent appel\u00e9 nil ). Soit c'est un n\u0153ud qui poss\u00e8de une \u00e9tiquette et deux sous-arbres binaires, un \u00e0 gauche, un \u00e0 droite, possiblement vides l'un et/ou l'autre. Les arbres binaires sont ici mod\u00e9lis\u00e9s dans Python avec un style POO (Programmation Orient\u00e9e Objet), et on vous demande de compl\u00e9ter la classe ArbreBinaire pour disposer des m\u00e9thodes taille et hauteur . Dans cet exercice, la d\u00e9finition de la hauteur de l' arbre binaire vide est 0. Exemple graph TD A2{A2} --> A1{A1} A2 --> N3{3} A1 --> N1{1} A1 --> N2{2} N3 --> x3( ) N3 --> y3( ) N2 --> x2( ) N2 --> y2( ) N1 --> x1( ) N1 --> y1( ) Un arbre binaire de hauteur 3 et de taille 5. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"machin\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"chose\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore2, \"AA1\", noeudpython-underscore1)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(noeudpython-underscore3, \"AA2\", arbrepython-underscoreA1)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 class ArbreBinaire():backslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche=None, etiquette=None, droite=None):backslash-newline self.gauche = gauchebackslash-newline self.etiquette = etiquettebackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.etiquette is Nonebackslash-newline backslash-newline def hauteur(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return ...backslash-newline backslash-newline def taille(self):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newline class ArbreBinaire():backslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche=None, etiquette=None, droite=None):backslash-newline self.gauche = gauchebackslash-newline self.etiquette = etiquettebackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.etiquette is Nonebackslash-newline backslash-newline def hauteur(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(self.gauche.hauteur(), self.droite.hauteur())backslash-newline backslash-newline def taille(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return 1 + self.gauche.taille() + self.droite.taille()backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newline A Z","title":"Arbre binaire"},{"location":"2-moyen/arbre_bin/sujet/#arbre-binaire","text":"On rappelle qu'il existe parfois des variations dans les d\u00e9finitions des structures arborescentes, et que pendant un exercice, il faut suivre celles donn\u00e9es dans l'\u00e9nonc\u00e9. On peut d\u00e9finir un arbre binaire par : Soit un arbre binaire vide (souvent appel\u00e9 nil ). Soit c'est un n\u0153ud qui poss\u00e8de une \u00e9tiquette et deux sous-arbres binaires, un \u00e0 gauche, un \u00e0 droite, possiblement vides l'un et/ou l'autre. Les arbres binaires sont ici mod\u00e9lis\u00e9s dans Python avec un style POO (Programmation Orient\u00e9e Objet), et on vous demande de compl\u00e9ter la classe ArbreBinaire pour disposer des m\u00e9thodes taille et hauteur . Dans cet exercice, la d\u00e9finition de la hauteur de l' arbre binaire vide est 0. Exemple graph TD A2{A2} --> A1{A1} A2 --> N3{3} A1 --> N1{1} A1 --> N2{2} N3 --> x3( ) N3 --> y3( ) N2 --> x2( ) N2 --> y2( ) N1 --> x1( ) N1 --> y1( ) Un arbre binaire de hauteur 3 et de taille 5. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"machin\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"chose\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore2, \"AA1\", noeudpython-underscore1)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(noeudpython-underscore3, \"AA2\", arbrepython-underscoreA1)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 class ArbreBinaire():backslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche=None, etiquette=None, droite=None):backslash-newline self.gauche = gauchebackslash-newline self.etiquette = etiquettebackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.etiquette is Nonebackslash-newline backslash-newline def hauteur(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return ...backslash-newline backslash-newline def taille(self):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newline class ArbreBinaire():backslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche=None, etiquette=None, droite=None):backslash-newline self.gauche = gauchebackslash-newline self.etiquette = etiquettebackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorevide(self):backslash-newline return self.etiquette is Nonebackslash-newline backslash-newline def hauteur(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return 1 + max(self.gauche.hauteur(), self.droite.hauteur())backslash-newline backslash-newline def taille(self):backslash-newline if self.estpython-underscorevide():backslash-newline return 0backslash-newline else:backslash-newline return 1 + self.gauche.taille() + self.droite.taille()backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenil = ArbreBinaire()backslash-newlineassert nil.estpython-underscorevide()backslash-newlineassert nil.taille() == 0backslash-newlineassert nil.hauteur() == 0backslash-newlinebackslash-newlinenoeudpython-underscore1 = ArbreBinaire(nil, \"1\", nil)backslash-newlineassert not noeudpython-underscore1.estpython-underscorevide()backslash-newlineassert noeudpython-underscore1.taille() == 1backslash-newlineassert noeudpython-underscore1.hauteur() == 1backslash-newlinebackslash-newlinenoeudpython-underscore2 = ArbreBinaire(nil, \"2\", nil)backslash-newlinebackslash-newlinearbrepython-underscoreA1 = ArbreBinaire(noeudpython-underscore1, \"A1\", noeudpython-underscore2)backslash-newlinenoeudpython-underscore3 = ArbreBinaire(nil, \"3\", nil)backslash-newlinearbrepython-underscoreA2 = ArbreBinaire(arbrepython-underscoreA1, \"A2\", noeudpython-underscore3)backslash-newlineassert not arbrepython-underscoreA2.estpython-underscorevide()backslash-newlinebackslash-newlineassert arbrepython-underscoreA1.taille() == 3, f\"{arbrepython-underscoreA1.taille()}\"backslash-newlineassert arbrepython-underscoreA1.hauteur() == 2, f\"{arbrepython-underscoreA1.hauteur()}\"backslash-newlinebackslash-newlineassert arbrepython-underscoreA2.taille() == 5, f\"{arbrepython-underscoreA2.taille()}\"backslash-newlineassert arbrepython-underscoreA2.hauteur() == 3, f\"{arbrepython-underscoreA2.hauteur()}\"backslash-newlinebackslash-newline A Z","title":"Arbre binaire"},{"location":"2-moyen/cesar/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def position_lettre ( lettre ): return ord ( lettre ) - ord ( 'A' ) def nouvelle_lettre ( indice ): return chr ( ord ( 'A' ) + indice ) def cesar ( message , decalage ): resultat = '' for caractere in message : if 'A' <= caractere <= 'Z' : indice = ( position_lettre ( caractere ) + decalage ) % 26 resultat = resultat + nouvelle_lettre ( indice ) else : resultat = resultat + caractere return resultat Modulo 26 \u2693\ufe0e Lorsqu'on calcule l'indice de la nouvelle lettre, on prend le reste de la division par 26 pour obtenir une valeur entre 0 inclus et 26 exclu, ce qui garantit que l'indice correspond bien \u00e0 une lettre entre 'A' et 'Z' . On dit qu'on fait le calcul modulo 26. Plus g\u00e9n\u00e9ralement pour un texte ou un tableau, si on veut \u00eatre s\u00fbr que l'indice est valide, on peut rajouter un modulo len(texte) ou len(tableau) . Pas si s\u00e9curis\u00e9 \u2693\ufe0e Cette m\u00e9thode de chiffrement n'est pas du tout s\u00e9curis\u00e9e et tr\u00e8s facile \u00e0 casser en tentant tous les d\u00e9calages possibles ou en faisant une analyse des fr\u00e9quences des lettres. Pour aller au-del\u00e0, vous pouvez regarder du c\u00f4t\u00e9 du chiffrement affine ou du chiffre de Vigen\u00e8re.","title":"Commentaires"},{"location":"2-moyen/cesar/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def position_lettre ( lettre ): return ord ( lettre ) - ord ( 'A' ) def nouvelle_lettre ( indice ): return chr ( ord ( 'A' ) + indice ) def cesar ( message , decalage ): resultat = '' for caractere in message : if 'A' <= caractere <= 'Z' : indice = ( position_lettre ( caractere ) + decalage ) % 26 resultat = resultat + nouvelle_lettre ( indice ) else : resultat = resultat + caractere return resultat","title":"Commentaires"},{"location":"2-moyen/cesar/exo_REM/#modulo-26","text":"Lorsqu'on calcule l'indice de la nouvelle lettre, on prend le reste de la division par 26 pour obtenir une valeur entre 0 inclus et 26 exclu, ce qui garantit que l'indice correspond bien \u00e0 une lettre entre 'A' et 'Z' . On dit qu'on fait le calcul modulo 26. Plus g\u00e9n\u00e9ralement pour un texte ou un tableau, si on veut \u00eatre s\u00fbr que l'indice est valide, on peut rajouter un modulo len(texte) ou len(tableau) .","title":"Modulo 26"},{"location":"2-moyen/cesar/exo_REM/#pas-si-securise","text":"Cette m\u00e9thode de chiffrement n'est pas du tout s\u00e9curis\u00e9e et tr\u00e8s facile \u00e0 casser en tentant tous les d\u00e9calages possibles ou en faisant une analyse des fr\u00e9quences des lettres. Pour aller au-del\u00e0, vous pouvez regarder du c\u00f4t\u00e9 du chiffrement affine ou du chiffre de Vigen\u00e8re.","title":"Pas si s\u00e9curis\u00e9"},{"location":"2-moyen/cesar/sujet/","tags":["boucle","string","a_trou"],"text":"Le code de C\u00e9sar \u2693\ufe0e Le codage de C\u00e9sar transforme un message en changeant chaque lettre par une autre obtenue par d\u00e9calage dans l'alphabet de la lettre d'origine. Par exemple, avec un d\u00e9calage de 3, le 'A' se transforme en 'D' , le 'B' en 'E' , ..., le 'X' en 'A' , le 'Y' en 'B' et le 'Z' en 'C' . Les autres caract\u00e8res ( '!' , '?' ...) ne sont pas cod\u00e9s. La fonction position_lettre ci-dessous prend en param\u00e8tre une cha\u00eene de caract\u00e8res de longueur 1 lettre et renvoie la position de lettre dans l'alphabet \u00e0 partir de celle de la lettre 'A' . On n'utilisera cette fonction que lorsque 'A' <= lettre <= 'Z' . La fonction nouvelle_lettre prend un entier indice , compris entre 0 inclus et 26 exclu, et renvoie la lettre de l'alphabet correspondant. Ainsi, nouvelle_lettre(0) revoie 'A' et nouvelle_lettre(25) renvoie 'Z' . La fonction cesar prend en param\u00e8tres une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant ce decalage . Exemples \ud83d\udc0d Console Python >>> position_lettre ( 'A' ) 0 >>> position_lettre ( 'B' ) 1 >>> position_lettre ( 'D' ) 3 >>> position_lettre ( 'Z' ) 25 \ud83d\udc0d Console Python >>> nouvelle_lettre ( 0 ) 'A' >>> nouvelle_lettre ( 1 ) 'B' >>> nouvelle_lettre ( 12 ) 'M' >>> nouvelle_lettre ( 25 ) 'Z' \ud83d\udc0d Console Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !', \"Erreur sur ce test\"backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !', \"Erreur sur ce test\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'backslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", -2) == 'YZABCDEFGHIJKLMNOPQRSTUVWX'backslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'backslash-newlineassert cesar(\"\", 7) == ''backslash-newlineassert cesar(\"!?.:\", 7) == '!?.:'backslash-newlineassert cesar(\"CESAR\", 139) == 'LNBJA'backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def positionpython-underscorelettre(lettre):backslash-newline return ord(lettre) - ord('A')backslash-newlinebackslash-newlinedef nouvellepython-underscorelettre(indice):backslash-newline return chr(ord('A') + indice)backslash-newlinebackslash-newlinedef cesar(message, decalage):backslash-newline resultat = ''backslash-newline for ... in message:backslash-newline if 'A' <= caractere <= 'Z':backslash-newline indice = ( ... ) % 26backslash-newline resultat = resultat + ...backslash-newline else:backslash-newline resultat = ...backslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !'backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'backslash-newlinebackslash-newline def positionpython-underscorelettre(lettre):backslash-newline return ord(lettre) - ord('A')backslash-newlinebackslash-newlinedef nouvellepython-underscorelettre(indice):backslash-newline return chr(ord('A') + indice)backslash-newlinebackslash-newlinedef cesar(message, decalage):backslash-newline resultat = ''backslash-newline for caractere in message:backslash-newline if 'A' <= caractere <= 'Z':backslash-newline indice = (positionpython-underscorelettre(caractere) + decalage) % 26backslash-newline resultat = resultat + nouvellepython-underscorelettre(indice)backslash-newline else:backslash-newline resultat = resultat + caracterebackslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !'backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr', 0, '# TESTS') }} Modulo 26 \u2693\ufe0e Lorsqu'on calcule l'indice de la nouvelle lettre, on prend le reste de la division par 26 pour obtenir une valeur entre 0 inclus et 26 exclu, ce qui garantit que l'indice correspond bien \u00e0 une lettre entre 'A' et 'Z' . On dit qu'on fait le calcul modulo 26. Plus g\u00e9n\u00e9ralement pour un texte ou un tableau, si on veut \u00eatre s\u00fbr que l'indice est valide, on peut rajouter un modulo len(texte) ou len(tableau) . Pas si s\u00e9curis\u00e9 \u2693\ufe0e Cette m\u00e9thode de chiffrement n'est pas du tout s\u00e9curis\u00e9e et tr\u00e8s facile \u00e0 casser en tentant tous les d\u00e9calages possibles ou en faisant une analyse des fr\u00e9quences des lettres. Pour aller au-del\u00e0, vous pouvez regarder du c\u00f4t\u00e9 du chiffrement affine ou du chiffre de Vigen\u00e8re. Z","title":"Code de C\u00e9sar"},{"location":"2-moyen/cesar/sujet/#le-code-de-cesar","text":"Le codage de C\u00e9sar transforme un message en changeant chaque lettre par une autre obtenue par d\u00e9calage dans l'alphabet de la lettre d'origine. Par exemple, avec un d\u00e9calage de 3, le 'A' se transforme en 'D' , le 'B' en 'E' , ..., le 'X' en 'A' , le 'Y' en 'B' et le 'Z' en 'C' . Les autres caract\u00e8res ( '!' , '?' ...) ne sont pas cod\u00e9s. La fonction position_lettre ci-dessous prend en param\u00e8tre une cha\u00eene de caract\u00e8res de longueur 1 lettre et renvoie la position de lettre dans l'alphabet \u00e0 partir de celle de la lettre 'A' . On n'utilisera cette fonction que lorsque 'A' <= lettre <= 'Z' . La fonction nouvelle_lettre prend un entier indice , compris entre 0 inclus et 26 exclu, et renvoie la lettre de l'alphabet correspondant. Ainsi, nouvelle_lettre(0) revoie 'A' et nouvelle_lettre(25) renvoie 'Z' . La fonction cesar prend en param\u00e8tres une cha\u00eene de caract\u00e8res message et un nombre entier decalage et renvoie le nouveau message cod\u00e9 avec le codage de C\u00e9sar utilisant ce decalage . Exemples \ud83d\udc0d Console Python >>> position_lettre ( 'A' ) 0 >>> position_lettre ( 'B' ) 1 >>> position_lettre ( 'D' ) 3 >>> position_lettre ( 'Z' ) 25 \ud83d\udc0d Console Python >>> nouvelle_lettre ( 0 ) 'A' >>> nouvelle_lettre ( 1 ) 'B' >>> nouvelle_lettre ( 12 ) 'M' >>> nouvelle_lettre ( 25 ) 'Z' \ud83d\udc0d Console Python >>> cesar ( 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' , 4 ) 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !' >>> cesar ( 'GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !' , - 5 ) 'BONJOUR A TOUS. VIVE LA MATIERE NSI !' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !', \"Erreur sur ce test\"backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !', \"Erreur sur ce test\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 1) == 'BCDEFGHIJKLMNOPQRSTUVWXYZA'backslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", -2) == 'YZABCDEFGHIJKLMNOPQRSTUVWX'backslash-newlineassert cesar(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", 0) == 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'backslash-newlineassert cesar(\"\", 7) == ''backslash-newlineassert cesar(\"!?.:\", 7) == '!?.:'backslash-newlineassert cesar(\"CESAR\", 139) == 'LNBJA'backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def positionpython-underscorelettre(lettre):backslash-newline return ord(lettre) - ord('A')backslash-newlinebackslash-newlinedef nouvellepython-underscorelettre(indice):backslash-newline return chr(ord('A') + indice)backslash-newlinebackslash-newlinedef cesar(message, decalage):backslash-newline resultat = ''backslash-newline for ... in message:backslash-newline if 'A' <= caractere <= 'Z':backslash-newline indice = ( ... ) % 26backslash-newline resultat = resultat + ...backslash-newline else:backslash-newline resultat = ...backslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !'backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'backslash-newlinebackslash-newline def positionpython-underscorelettre(lettre):backslash-newline return ord(lettre) - ord('A')backslash-newlinebackslash-newlinedef nouvellepython-underscorelettre(indice):backslash-newline return chr(ord('A') + indice)backslash-newlinebackslash-newlinedef cesar(message, decalage):backslash-newline resultat = ''backslash-newline for caractere in message:backslash-newline if 'A' <= caractere <= 'Z':backslash-newline indice = (positionpython-underscorelettre(caractere) + decalage) % 26backslash-newline resultat = resultat + nouvellepython-underscorelettre(indice)backslash-newline else:backslash-newline resultat = resultat + caracterebackslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert cesar('BONJOUR A TOUS. VIVE LA MATIERE NSI !', 4) == 'FSRNSYV E XSYW. ZMZI PE QEXMIVI RWM !'backslash-newlineassert cesar('GTSOTZW F YTZX. ANAJ QF RFYNJWJ SXN !', -5) == 'BONJOUR A TOUS. VIVE LA MATIERE NSI !'backslash-newlinebackslash-newline A","title":"Le code de C\u00e9sar"},{"location":"2-moyen/cesar/sujet/#commentaires","text":"{{ py('exo_corr', 0, '# TESTS') }}","title":"Commentaires"},{"location":"2-moyen/cesar/sujet/#modulo-26","text":"Lorsqu'on calcule l'indice de la nouvelle lettre, on prend le reste de la division par 26 pour obtenir une valeur entre 0 inclus et 26 exclu, ce qui garantit que l'indice correspond bien \u00e0 une lettre entre 'A' et 'Z' . On dit qu'on fait le calcul modulo 26. Plus g\u00e9n\u00e9ralement pour un texte ou un tableau, si on veut \u00eatre s\u00fbr que l'indice est valide, on peut rajouter un modulo len(texte) ou len(tableau) .","title":"Modulo 26"},{"location":"2-moyen/cesar/sujet/#pas-si-securise","text":"Cette m\u00e9thode de chiffrement n'est pas du tout s\u00e9curis\u00e9e et tr\u00e8s facile \u00e0 casser en tentant tous les d\u00e9calages possibles ou en faisant une analyse des fr\u00e9quences des lettres. Pour aller au-del\u00e0, vous pouvez regarder du c\u00f4t\u00e9 du chiffrement affine ou du chiffre de Vigen\u00e8re. Z","title":"Pas si s\u00e9curis\u00e9"},{"location":"2-moyen/conway/exo_REM/","text":"Commentaires \u2693\ufe0e Version classique \u2693\ufe0e \ud83d\udc0d Script Python def conway_suivante ( ligne ): precedent = ligne [ 0 ] nb_consecutifs = 0 resultat = [] for chiffre in ligne : if chiffre == precedent : nb_consecutifs += 1 else : resultat . append ( nb_consecutifs ) resultat . append ( precedent ) precedent = chiffre nb_consecutifs = 1 resultat . append ( nb_consecutifs ) resultat . append ( precedent ) return resultat On compl\u00e8te return resultat \u00e0 la fin, ligne 15, c'est la liste des nouveaux chiffres. Elle se construit par accumulation, et elle est initialis\u00e9e vide \u00e0 la ligne 4 resultat = [] . \u00c0 chaque changement de chiffre, on ajoute \u00e0 la liste d'abord la quantit\u00e9 nb_consecutifs , puis le chiffre precedent . En sortie de boucle, on agit comme s'il y avait changement. On met \u00e0 jour precedent = chiffre , et nb_consecutifs = 1 en comptant ce chiffre juste vu. On remarque qu'\u00e0 la ligne 3, on n'avait pas encore vu le premier chiffre, donc l'initialisation \u00e9tait \u00e0 0. Si le chiffre est le m\u00eame, on incr\u00e9mente nb_consecutifs de 1. Version fonctionnelle \u2693\ufe0e Dans le module itertools , il y a une fonction groupby qui permet de regrouper par lot, dans un it\u00e9rable, les termes cons\u00e9cutifs identiques. \ud83d\udc0d Script Python from itertools import groupby def conway_suivante ( ligne ): resultat = [] for motif , iterable in groupby ( ligne ): resultat . append ( sum ( 1 for chiffre in iterable )) resultat . append ( motif ) return resultat","title":"Commentaires"},{"location":"2-moyen/conway/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/conway/exo_REM/#version-classique","text":"\ud83d\udc0d Script Python def conway_suivante ( ligne ): precedent = ligne [ 0 ] nb_consecutifs = 0 resultat = [] for chiffre in ligne : if chiffre == precedent : nb_consecutifs += 1 else : resultat . append ( nb_consecutifs ) resultat . append ( precedent ) precedent = chiffre nb_consecutifs = 1 resultat . append ( nb_consecutifs ) resultat . append ( precedent ) return resultat On compl\u00e8te return resultat \u00e0 la fin, ligne 15, c'est la liste des nouveaux chiffres. Elle se construit par accumulation, et elle est initialis\u00e9e vide \u00e0 la ligne 4 resultat = [] . \u00c0 chaque changement de chiffre, on ajoute \u00e0 la liste d'abord la quantit\u00e9 nb_consecutifs , puis le chiffre precedent . En sortie de boucle, on agit comme s'il y avait changement. On met \u00e0 jour precedent = chiffre , et nb_consecutifs = 1 en comptant ce chiffre juste vu. On remarque qu'\u00e0 la ligne 3, on n'avait pas encore vu le premier chiffre, donc l'initialisation \u00e9tait \u00e0 0. Si le chiffre est le m\u00eame, on incr\u00e9mente nb_consecutifs de 1.","title":"Version classique"},{"location":"2-moyen/conway/exo_REM/#version-fonctionnelle","text":"Dans le module itertools , il y a une fonction groupby qui permet de regrouper par lot, dans un it\u00e9rable, les termes cons\u00e9cutifs identiques. \ud83d\udc0d Script Python from itertools import groupby def conway_suivante ( ligne ): resultat = [] for motif , iterable in groupby ( ligne ): resultat . append ( sum ( 1 for chiffre in iterable )) resultat . append ( motif ) return resultat","title":"Version fonctionnelle"},{"location":"2-moyen/conway/sujet/","tags":["boucle","adhoc","a_trou"],"text":"Suite audioactive de Conway \u2693\ufe0e Dans la suite math\u00e9matique Look and say , invent\u00e9e en 1986 par le math\u00e9maticien John Horton Conway, un terme se d\u00e9termine en annon\u00e7ant les chiffres formant le terme pr\u00e9c\u00e9dent. \\[\\begin{matrix}1\\\\11\\\\21\\\\1211\\\\111221\\\\312211\\end{matrix}\\] Explication : \u00e0 partir de \\(111221\\) , on lit \\(111\\,22\\,1\\) , soit trois \\(1\\) , puis deux \\(2\\) , et un \\(1\\) , d'o\u00f9 \\(31\\,22\\,11\\) pour la ligne suivante. On peut v\u00e9rifier que la ligne suivante est \\(13112221\\) . Pour simplifier le code, on va mod\u00e9liser cette suite par la liste des chiffres. \ud83d\udc0d Script Python LIGNE_1 = [ 1 ] LIGNE_2 = [ 1 , 1 ] LIGNE_3 = [ 2 , 1 ] LIGNE_4 = [ 1 , 2 , 1 , 1 ] LIGNE_5 = [ 1 , 1 , 1 , 2 , 2 , 1 ] LIGNE_6 = [ 3 , 1 , 2 , 2 , 1 , 1 ] LIGNE_7 = [ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ] \u00c9crire une fonction telle que conway_suivante(ligne) renvoie, sous forme de liste, la ligne suivante apr\u00e8s ligne . Ceci pourrait permettre de faire des appels r\u00e9cursifs. Code \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def conway_suivante ( ligne ): precedent = ligne [ 0 ] nb_consecutifs = 0 resultat = ... for chiffre in ligne : if chiffre == precedent : nb_consecutifs = ... else : resultat . append ( ... ) resultat . append ( ... ) precedent = ... nb_consecutifs = ... resultat . append ( ... ) resultat . append ( ... ) return ... Exemples \ud83d\udc0d Script Python >>> conway_suivante ([ 3 , 1 , 2 , 2 , 1 , 1 ]) [ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ] >>> conway_suivante ([ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ]) [ 1 , 1 , 1 , 3 , 2 , 1 , 3 , 2 , 1 , 1 ] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlineCONWAY = [backslash-newline [1],backslash-newline [1, 1],backslash-newline [2, 1],backslash-newline [1, 2, 1, 1],backslash-newline [1, 1, 1, 2, 2, 1],backslash-newline [3, 1, 2, 2, 1, 1],backslash-newline [1, 3, 1, 1, 2, 2, 2, 1],backslash-newline [1, 1, 1, 3, 2, 1, 3, 2, 1, 1],backslash-newline [3, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1],backslash-newline [1, 3, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 2, 2, 2, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 1, 1, 3, 2, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 3, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 3, 2, 2, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 2, 3, 2, 2, 2, 1, 1, 3, 3, 1, 2, 2, 2, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 2, 1, 3, 3, 2, 2, 1, 2, 3, 1, 1, 3, 2, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 2, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 2, 2, 1, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline]backslash-newlinebackslash-newlinesecret = all(conwaypython-underscoresuivante(CONWAY[i-1]) == CONWAY[i]backslash-newline for i in range(1, len(CONWAY)))backslash-newlineassert secret, \"Erreur \u00c3 un test secret\"backslash-newlinebackslash-newline Valider 5/5 def conwaypython-underscoresuivante(ligne):backslash-newline precedent = ligne[0]backslash-newline nbpython-underscoreconsecutifs = 0backslash-newline resultat = ...backslash-newline for chiffre in ligne:backslash-newline if chiffre == precedent:backslash-newline nbpython-underscoreconsecutifs = ...backslash-newline else:backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline precedent = ...backslash-newline nbpython-underscoreconsecutifs = ...backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newline def conwaypython-underscoresuivante(ligne):backslash-newline precedent = ligne[0]backslash-newline nbpython-underscoreconsecutifs = 0backslash-newline resultat = []backslash-newline for chiffre in ligne:backslash-newline if chiffre == precedent:backslash-newline nbpython-underscoreconsecutifs += 1backslash-newline else:backslash-newline resultat.append(nbpython-underscoreconsecutifs)backslash-newline resultat.append(precedent)backslash-newline precedent = chiffrebackslash-newline nbpython-underscoreconsecutifs = 1backslash-newline resultat.append(nbpython-underscoreconsecutifs)backslash-newline resultat.append(precedent)backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version classique \u2693\ufe0e {{ py('exo_corr') }} On compl\u00e8te return resultat \u00e0 la fin, ligne 15, c'est la liste des nouveaux chiffres. Elle se construit par accumulation, et elle est initialis\u00e9e vide \u00e0 la ligne 4 resultat = [] . \u00c0 chaque changement de chiffre, on ajoute \u00e0 la liste d'abord la quantit\u00e9 nb_consecutifs , puis le chiffre precedent . En sortie de boucle, on agit comme s'il y avait changement. On met \u00e0 jour precedent = chiffre , et nb_consecutifs = 1 en comptant ce chiffre juste vu. On remarque qu'\u00e0 la ligne 3, on n'avait pas encore vu le premier chiffre, donc l'initialisation \u00e9tait \u00e0 0. Si le chiffre est le m\u00eame, on incr\u00e9mente nb_consecutifs de 1. Version fonctionnelle \u2693\ufe0e Dans le module itertools , il y a une fonction groupby qui permet de regrouper par lot, dans un it\u00e9rable, les termes cons\u00e9cutifs identiques. \ud83d\udc0d Script Python from itertools import groupby def conway_suivante ( ligne ): resultat = [] for motif , iterable in groupby ( ligne ): resultat . append ( sum ( 1 for chiffre in iterable )) resultat . append ( motif ) return resultat Z","title":"Suite de Conway"},{"location":"2-moyen/conway/sujet/#suite-audioactive-de-conway","text":"Dans la suite math\u00e9matique Look and say , invent\u00e9e en 1986 par le math\u00e9maticien John Horton Conway, un terme se d\u00e9termine en annon\u00e7ant les chiffres formant le terme pr\u00e9c\u00e9dent. \\[\\begin{matrix}1\\\\11\\\\21\\\\1211\\\\111221\\\\312211\\end{matrix}\\] Explication : \u00e0 partir de \\(111221\\) , on lit \\(111\\,22\\,1\\) , soit trois \\(1\\) , puis deux \\(2\\) , et un \\(1\\) , d'o\u00f9 \\(31\\,22\\,11\\) pour la ligne suivante. On peut v\u00e9rifier que la ligne suivante est \\(13112221\\) . Pour simplifier le code, on va mod\u00e9liser cette suite par la liste des chiffres. \ud83d\udc0d Script Python LIGNE_1 = [ 1 ] LIGNE_2 = [ 1 , 1 ] LIGNE_3 = [ 2 , 1 ] LIGNE_4 = [ 1 , 2 , 1 , 1 ] LIGNE_5 = [ 1 , 1 , 1 , 2 , 2 , 1 ] LIGNE_6 = [ 3 , 1 , 2 , 2 , 1 , 1 ] LIGNE_7 = [ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ] \u00c9crire une fonction telle que conway_suivante(ligne) renvoie, sous forme de liste, la ligne suivante apr\u00e8s ligne . Ceci pourrait permettre de faire des appels r\u00e9cursifs. Code \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def conway_suivante ( ligne ): precedent = ligne [ 0 ] nb_consecutifs = 0 resultat = ... for chiffre in ligne : if chiffre == precedent : nb_consecutifs = ... else : resultat . append ( ... ) resultat . append ( ... ) precedent = ... nb_consecutifs = ... resultat . append ( ... ) resultat . append ( ... ) return ... Exemples \ud83d\udc0d Script Python >>> conway_suivante ([ 3 , 1 , 2 , 2 , 1 , 1 ]) [ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ] >>> conway_suivante ([ 1 , 3 , 1 , 1 , 2 , 2 , 2 , 1 ]) [ 1 , 1 , 1 , 3 , 2 , 1 , 3 , 2 , 1 , 1 ] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlineCONWAY = [backslash-newline [1],backslash-newline [1, 1],backslash-newline [2, 1],backslash-newline [1, 2, 1, 1],backslash-newline [1, 1, 1, 2, 2, 1],backslash-newline [3, 1, 2, 2, 1, 1],backslash-newline [1, 3, 1, 1, 2, 2, 2, 1],backslash-newline [1, 1, 1, 3, 2, 1, 3, 2, 1, 1],backslash-newline [3, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1],backslash-newline [1, 3, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 2, 2, 2, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 1, 1, 3, 2, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 3, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 2, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 3, 2, 2, 1, 1, 3, 1, 1, 1, 2, 2, 1, 1, 3, 1, 2, 2, 1],backslash-newline [3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 2, 3, 2, 2, 2, 1, 1, 3, 3, 1, 2, 2, 2, 1, 1, 3, 1, 1, 2, 2, 1, 1],backslash-newline [1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 2, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 3, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 1, 1, 1, 2, 1, 3, 3, 2, 2, 1, 2, 3, 1, 1, 3, 2, 2, 1, 1, 3, 2, 1, 2, 2, 2, 1],backslash-newline [1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 2, 1, 2, 3, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 1, 1, 1, 2, 1, 3, 1, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 2, 2, 1, 3, 2, 1, 1, 2, 3, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 3, 3, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 2, 2, 1, 1, 1, 2, 1, 3, 1, 2, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 1, 3, 2, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 3, 2, 1, 1, 3, 3, 1, 1, 2, 1, 3, 2, 1, 1, 2, 3, 1, 2, 3, 2, 1, 1, 2, 3, 1, 1, 3, 1, 1, 2, 2, 2, 1, 1, 2, 1, 1, 1, 3, 1, 2, 2, 1, 1, 3, 1, 2, 1, 1, 1, 3, 1, 2, 3, 1, 1, 2, 1, 1, 2, 3, 2, 2, 1, 1, 1, 2, 1, 3, 2, 1, 1, 3, 2, 2, 2, 1, 1, 3, 1, 2, 1, 1, 3, 2, 1, 1],backslash-newline]backslash-newlinebackslash-newlinesecret = all(conwaypython-underscoresuivante(CONWAY[i-1]) == CONWAY[i]backslash-newline for i in range(1, len(CONWAY)))backslash-newlineassert secret, \"Erreur \u00c3 un test secret\"backslash-newlinebackslash-newline Valider 5/5 def conwaypython-underscoresuivante(ligne):backslash-newline precedent = ligne[0]backslash-newline nbpython-underscoreconsecutifs = 0backslash-newline resultat = ...backslash-newline for chiffre in ligne:backslash-newline if chiffre == precedent:backslash-newline nbpython-underscoreconsecutifs = ...backslash-newline else:backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline precedent = ...backslash-newline nbpython-underscoreconsecutifs = ...backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newline def conwaypython-underscoresuivante(ligne):backslash-newline precedent = ligne[0]backslash-newline nbpython-underscoreconsecutifs = 0backslash-newline resultat = []backslash-newline for chiffre in ligne:backslash-newline if chiffre == precedent:backslash-newline nbpython-underscoreconsecutifs += 1backslash-newline else:backslash-newline resultat.append(nbpython-underscoreconsecutifs)backslash-newline resultat.append(precedent)backslash-newline precedent = chiffrebackslash-newline nbpython-underscoreconsecutifs = 1backslash-newline resultat.append(nbpython-underscoreconsecutifs)backslash-newline resultat.append(precedent)backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineLIGNEpython-underscore6 = [3, 1, 2, 2, 1, 1]backslash-newlineLIGNEpython-underscore7 = [1, 3, 1, 1, 2, 2, 2, 1]backslash-newlineLIGNEpython-underscore8 = [1, 1, 1, 3, 2, 1, 3, 2, 1, 1]backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore6) == LIGNEpython-underscore7backslash-newlineassert conwaypython-underscoresuivante(LIGNEpython-underscore7) == LIGNEpython-underscore8backslash-newlinebackslash-newline A","title":"Suite audioactive de Conway"},{"location":"2-moyen/conway/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/conway/sujet/#version-classique","text":"{{ py('exo_corr') }} On compl\u00e8te return resultat \u00e0 la fin, ligne 15, c'est la liste des nouveaux chiffres. Elle se construit par accumulation, et elle est initialis\u00e9e vide \u00e0 la ligne 4 resultat = [] . \u00c0 chaque changement de chiffre, on ajoute \u00e0 la liste d'abord la quantit\u00e9 nb_consecutifs , puis le chiffre precedent . En sortie de boucle, on agit comme s'il y avait changement. On met \u00e0 jour precedent = chiffre , et nb_consecutifs = 1 en comptant ce chiffre juste vu. On remarque qu'\u00e0 la ligne 3, on n'avait pas encore vu le premier chiffre, donc l'initialisation \u00e9tait \u00e0 0. Si le chiffre est le m\u00eame, on incr\u00e9mente nb_consecutifs de 1.","title":"Version classique"},{"location":"2-moyen/conway/sujet/#version-fonctionnelle","text":"Dans le module itertools , il y a une fonction groupby qui permet de regrouper par lot, dans un it\u00e9rable, les termes cons\u00e9cutifs identiques. \ud83d\udc0d Script Python from itertools import groupby def conway_suivante ( ligne ): resultat = [] for motif , iterable in groupby ( ligne ): resultat . append ( sum ( 1 for chiffre in iterable )) resultat . append ( motif ) return resultat Z","title":"Version fonctionnelle"},{"location":"2-moyen/erathostene/sujet/","tags":["boucle","maths"],"text":"Crible d'\u00c9ratosth\u00e8ne \u2693\ufe0e Nombres premiers \\(0\\) et \\(1\\) ne sont pas des nombres premiers, par d\u00e9finition. Pour un entier \\(n>1\\) , on dit que \\(n\\) est nombre premier s'il ne poss\u00e8de que deux diviseurs entiers \\(1\\) et \\(n\\) . Par exemple : \\(2\\) est premier ; \\(1\u00d72\\) est le seul produit d'entier \u00e9gal \u00e0 \\(2\\) . \\(3\\) est premier ; \\(1\u00d73\\) est le seul produit d'entier \u00e9gal \u00e0 \\(3\\) . \\(4\\) n'est pas premier ; il est aussi multiple de \\(2\\) , avec \\(2\u00d72 = 4\\) . \\(5\\) est premier ; \\(1\u00d75\\) est le seul produit d'entier \u00e9gal \u00e0 \\(5\\) . Propri\u00e9t\u00e9 importante : un entier \\(n>1\\) est toujours multiple d'un nombre premier, parfois lui-m\u00eame uniquement. C'est cette propri\u00e9t\u00e9 que nous allons utiliser pour justifier le fonctionnement du crible d'\u00c9ratosth\u00e8ne. On va marquer les multiples des nombres premiers, le plus petit entier non marqu\u00e9 sera donc un nombre premier. Le crible d'\u00c9ratosth\u00e8ne Un crible est une technique qui permet de r\u00e9pondre sur les caract\u00e9ristiques d'entiers, non pas un \u00e0 la fois, mais sur une tranche. Par exemple, savoir si un nombre est premier, on pourrait le v\u00e9rifier individuellement, \u00e7a a un cout important. On peut aussi le v\u00e9rifier globalement sur une tranche de \\(0\\) \u00e0 \\(n\\) , avec un bon algorithme, c'est plus efficace que le travail individuel. En r\u00e9sum\u00e9, on donne une r\u00e9ponse globale plus efficacement que de nombreuses r\u00e9ponses locales. Le crible d'\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petits qu'un certain nombre \\(n\\) fix\u00e9. La d\u00e9marche avec un papier et un crayon est la suivante : On \u00e9crit tous les nombres plus petit que \\(n\\) . On raye \\(0\\) et \\(1\\) qui ne sont pas premiers. On r\u00e9p\u00e8te jusqu'\u00e0 avoir trait\u00e9 tous les nombres : Le prochain nombre non trait\u00e9 est un nombre premier ; on l'entoure. On raye tous les autres multiples de ce nombre. Avec Python, si l'on cherche les nombres premiers strictement inf\u00e9rieurs \u00e0 n : On construit un tableau de \\(n\\) bool\u00e9ens crible , initialement tous \u00e9gaux \u00e0 True . On modifie crible[0] et crible[1] \u00e0 False ; \\(0\\) et \\(1\\) ne sont pas premiers. On parcourt ce tableau de gauche \u00e0 droite. Pour chaque indice p : Si crible[p] vaut True : le nombre \\(p\\) est premier. On donne la valeur False \u00e0 toutes les cellules de crible dont l'indice est un multiple de p , on commence avec 2*p , puis 3*p etc jusqu'\u00e0 la fin du tableau. Sinon, crible[p] vaut False : le nombre \\(p\\) n'est pas premier. On n'effectue aucun changement sur le tableau. Utilisation : On peut \u00e9tablir ensuite la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(n\\) en filtrant les indices des cellules de crible valant True . Astuce L'expression Python range ( 2 * p , n , p ) permet d'it\u00e9rer sur tous les multiples de p , de 2*p inclus \u00e0 n exclu. Compl\u00e9ter la fonction eratosthene : prenant en param\u00e8tre un entier n positif, renvoyant le tableau crible de taille \\(n\\) contenant des bool\u00e9ens, crible[p] indique si p est premier. Compl\u00e9ter la fonction premiers_inferieurs_a : prenant en param\u00e8tre un entier n positif, renvoyant la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> eratosthene ( 5 ) [False, False, True, True, False] >>> eratosthene ( 6 ) [False, False, True, True, False, True] >>> premiers_inferieurs_a ( 5 ) [2, 3] >>> premiers_inferieurs_a ( 7 ) [2, 3, 5] >>> premiers_inferieurs_a ( 20 ) [2, 3, 5, 7, 11, 13, 17, 19] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef estpython-underscorepremier(n):backslash-newline if n < 2: return Falsebackslash-newline for d in range(2, n):backslash-newline if n%d == 0: return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinefor n in range(37):backslash-newline attendu = [estpython-underscorepremier(p) for p in range(n)]backslash-newline assert eratosthene(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinefor n in range(100):backslash-newline attendu = [p for p in range(n) if estpython-underscorepremier(p)]backslash-newline assert premierspython-underscoreinferieurspython-underscorea(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = ...backslash-newline if n > 1:backslash-newline crible[1] = ...backslash-newline for p in range(...):backslash-newline if crible[p] == ...:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline crible[...] = ...backslash-newline return criblebackslash-newlinebackslash-newlinedef premierspython-underscoreinferieurspython-underscorea(n):backslash-newline crible = eratosthene(...)backslash-newline premiers = ...backslash-newline return premiersbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline def eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = Falsebackslash-newline if n > 1:backslash-newline crible[1] = Falsebackslash-newline for p in range(n):backslash-newline if crible[p] == True:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef premierspython-underscoreinferieurspython-underscorea(n):backslash-newline crible = eratosthene(n)backslash-newline premiers = [p for p in range(n) if crible[p]]backslash-newline return premiersbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Crible d'\u00c9ratosth\u00e8ne"},{"location":"2-moyen/erathostene/sujet/#crible-deratosthene","text":"Nombres premiers \\(0\\) et \\(1\\) ne sont pas des nombres premiers, par d\u00e9finition. Pour un entier \\(n>1\\) , on dit que \\(n\\) est nombre premier s'il ne poss\u00e8de que deux diviseurs entiers \\(1\\) et \\(n\\) . Par exemple : \\(2\\) est premier ; \\(1\u00d72\\) est le seul produit d'entier \u00e9gal \u00e0 \\(2\\) . \\(3\\) est premier ; \\(1\u00d73\\) est le seul produit d'entier \u00e9gal \u00e0 \\(3\\) . \\(4\\) n'est pas premier ; il est aussi multiple de \\(2\\) , avec \\(2\u00d72 = 4\\) . \\(5\\) est premier ; \\(1\u00d75\\) est le seul produit d'entier \u00e9gal \u00e0 \\(5\\) . Propri\u00e9t\u00e9 importante : un entier \\(n>1\\) est toujours multiple d'un nombre premier, parfois lui-m\u00eame uniquement. C'est cette propri\u00e9t\u00e9 que nous allons utiliser pour justifier le fonctionnement du crible d'\u00c9ratosth\u00e8ne. On va marquer les multiples des nombres premiers, le plus petit entier non marqu\u00e9 sera donc un nombre premier. Le crible d'\u00c9ratosth\u00e8ne Un crible est une technique qui permet de r\u00e9pondre sur les caract\u00e9ristiques d'entiers, non pas un \u00e0 la fois, mais sur une tranche. Par exemple, savoir si un nombre est premier, on pourrait le v\u00e9rifier individuellement, \u00e7a a un cout important. On peut aussi le v\u00e9rifier globalement sur une tranche de \\(0\\) \u00e0 \\(n\\) , avec un bon algorithme, c'est plus efficace que le travail individuel. En r\u00e9sum\u00e9, on donne une r\u00e9ponse globale plus efficacement que de nombreuses r\u00e9ponses locales. Le crible d'\u00c9ratosth\u00e8ne permet de d\u00e9terminer les nombres premiers plus petits qu'un certain nombre \\(n\\) fix\u00e9. La d\u00e9marche avec un papier et un crayon est la suivante : On \u00e9crit tous les nombres plus petit que \\(n\\) . On raye \\(0\\) et \\(1\\) qui ne sont pas premiers. On r\u00e9p\u00e8te jusqu'\u00e0 avoir trait\u00e9 tous les nombres : Le prochain nombre non trait\u00e9 est un nombre premier ; on l'entoure. On raye tous les autres multiples de ce nombre. Avec Python, si l'on cherche les nombres premiers strictement inf\u00e9rieurs \u00e0 n : On construit un tableau de \\(n\\) bool\u00e9ens crible , initialement tous \u00e9gaux \u00e0 True . On modifie crible[0] et crible[1] \u00e0 False ; \\(0\\) et \\(1\\) ne sont pas premiers. On parcourt ce tableau de gauche \u00e0 droite. Pour chaque indice p : Si crible[p] vaut True : le nombre \\(p\\) est premier. On donne la valeur False \u00e0 toutes les cellules de crible dont l'indice est un multiple de p , on commence avec 2*p , puis 3*p etc jusqu'\u00e0 la fin du tableau. Sinon, crible[p] vaut False : le nombre \\(p\\) n'est pas premier. On n'effectue aucun changement sur le tableau. Utilisation : On peut \u00e9tablir ensuite la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(n\\) en filtrant les indices des cellules de crible valant True . Astuce L'expression Python range ( 2 * p , n , p ) permet d'it\u00e9rer sur tous les multiples de p , de 2*p inclus \u00e0 n exclu. Compl\u00e9ter la fonction eratosthene : prenant en param\u00e8tre un entier n positif, renvoyant le tableau crible de taille \\(n\\) contenant des bool\u00e9ens, crible[p] indique si p est premier. Compl\u00e9ter la fonction premiers_inferieurs_a : prenant en param\u00e8tre un entier n positif, renvoyant la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> eratosthene ( 5 ) [False, False, True, True, False] >>> eratosthene ( 6 ) [False, False, True, True, False, True] >>> premiers_inferieurs_a ( 5 ) [2, 3] >>> premiers_inferieurs_a ( 7 ) [2, 3, 5] >>> premiers_inferieurs_a ( 20 ) [2, 3, 5, 7, 11, 13, 17, 19] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef estpython-underscorepremier(n):backslash-newline if n < 2: return Falsebackslash-newline for d in range(2, n):backslash-newline if n%d == 0: return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinefor n in range(37):backslash-newline attendu = [estpython-underscorepremier(p) for p in range(n)]backslash-newline assert eratosthene(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinefor n in range(100):backslash-newline attendu = [p for p in range(n) if estpython-underscorepremier(p)]backslash-newline assert premierspython-underscoreinferieurspython-underscorea(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = ...backslash-newline if n > 1:backslash-newline crible[1] = ...backslash-newline for p in range(...):backslash-newline if crible[p] == ...:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline crible[...] = ...backslash-newline return criblebackslash-newlinebackslash-newlinedef premierspython-underscoreinferieurspython-underscorea(n):backslash-newline crible = eratosthene(...)backslash-newline premiers = ...backslash-newline return premiersbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline def eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = Falsebackslash-newline if n > 1:backslash-newline crible[1] = Falsebackslash-newline for p in range(n):backslash-newline if crible[p] == True:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef premierspython-underscoreinferieurspython-underscorea(n):backslash-newline crible = eratosthene(n)backslash-newline premiers = [p for p in range(n) if crible[p]]backslash-newline return premiersbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert eratosthene(5) == [False, False, True, True, False]backslash-newlineassert eratosthene(6) == [False, False, True, True, False, True]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(5) == [2, 3]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(7) == [2, 3, 5]backslash-newlineassert premierspython-underscoreinferieurspython-underscorea(20) == [2, 3, 5, 7, 11, 13, 17, 19]backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Crible d'\u00c9ratosth\u00e8ne"},{"location":"2-moyen/est_inclus/sujet/","tags":["a_trou"],"text":"Inclusion de texte \u2693\ufe0e L'ADN peut \u00eatre repr\u00e9sent\u00e9 par une s\u00e9quence de lettres dans \"ATGC\" . Un brin est un petit morceau d'ADN, que l'on retrouve parfois dans un g\u00e8ne qui est une grande s\u00e9quence d'ADN. La fonction est_inclus prend en param\u00e8tres deux chaines de caract\u00e8res brin et gene et renvoie la r\u00e9ponse, un bool\u00e9en, \u00e0 la question \u00ab Retrouve-t-on brin inclus dans gene ? \u00bb. Cette fonction utilise une fonction auxiliaire : est_inclus_a_partir_de(extrait, chaine, position) qui renvoie True si on retrouve extrait dans chaine \u00e0 partir de position dans chaine et False sinon. Compl\u00e9ter le code Python ci-dessous. \ud83d\udc0d Script Python def est_inclus_a_partir_de ( extrait , chaine , position ): if ... > len ( chaine ): return False for i in range ( len ( extrait )): if chaine [ position + ... ] != ... : return ... return True def est_inclus ( brin , gene ): l_gene = len ( gene ) l_brin = len ( brin ) for i in range ( ... - ... + 1 ): if est_inclus_a_partir_de ( ... , ... , ... ): return True return False Exemples \ud83d\udc0d Console Python >>> est_inclus ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> est_inclus ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False >>> est_inclus ( \"AGTC\" , \"GTACAAATCTTGCA\" ) False >>> est_inclus ( \"AGTC\" , \"GTACAAATCTAGTC\" ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlineassert estpython-underscoreinclus(\"AAAA\", \"AAAAGTATCTTGCC\")backslash-newlineassert estpython-underscoreinclus(\"GTAC\", \"GTACAAATCTTGCC\")backslash-newlineassert estpython-underscoreinclus(\"AAAA\", \"GTACAAATCTAAAA\")backslash-newlineassert estpython-underscoreinclus(\"AGTA\", \"GTACAAATCTAGTA\")backslash-newlineassert not estpython-underscoreinclus(\"AGTA\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline Valider 5/5 def estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(extrait, chaine, position):backslash-newline if ... > len(chaine):backslash-newline return Falsebackslash-newline for i in range(len(extrait)):backslash-newline if chaine[position + ...] != ...:backslash-newline return ...backslash-newline return Truebackslash-newlinebackslash-newlinedef estpython-underscoreinclus(brin, gene):backslash-newline lpython-underscoregene = len(gene)backslash-newline lpython-underscorebrin = len(brin)backslash-newline for i in range(... - ... + 1):backslash-newline if estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(..., ..., ...):backslash-newline return Truebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline def estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(extrait, chaine, position):backslash-newline if position + len(extrait) > len(chaine):backslash-newline return Falsebackslash-newline for i in range(len(extrait)):backslash-newline if chaine[position + i] != extrait[i]:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef estpython-underscoreinclus(brin, gene):backslash-newline lpython-underscoregene = len(gene)backslash-newline lpython-underscorebrin = len(brin)backslash-newline for i in range(lpython-underscoregene - lpython-underscorebrin + 1):backslash-newline if estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(brin, gene, i):backslash-newline return Truebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline A Z","title":"texte inclus"},{"location":"2-moyen/est_inclus/sujet/#inclusion-de-texte","text":"L'ADN peut \u00eatre repr\u00e9sent\u00e9 par une s\u00e9quence de lettres dans \"ATGC\" . Un brin est un petit morceau d'ADN, que l'on retrouve parfois dans un g\u00e8ne qui est une grande s\u00e9quence d'ADN. La fonction est_inclus prend en param\u00e8tres deux chaines de caract\u00e8res brin et gene et renvoie la r\u00e9ponse, un bool\u00e9en, \u00e0 la question \u00ab Retrouve-t-on brin inclus dans gene ? \u00bb. Cette fonction utilise une fonction auxiliaire : est_inclus_a_partir_de(extrait, chaine, position) qui renvoie True si on retrouve extrait dans chaine \u00e0 partir de position dans chaine et False sinon. Compl\u00e9ter le code Python ci-dessous. \ud83d\udc0d Script Python def est_inclus_a_partir_de ( extrait , chaine , position ): if ... > len ( chaine ): return False for i in range ( len ( extrait )): if chaine [ position + ... ] != ... : return ... return True def est_inclus ( brin , gene ): l_gene = len ( gene ) l_brin = len ( brin ) for i in range ( ... - ... + 1 ): if est_inclus_a_partir_de ( ... , ... , ... ): return True return False Exemples \ud83d\udc0d Console Python >>> est_inclus ( \"AATC\" , \"GTACAAATCTTGCC\" ) True >>> est_inclus ( \"AGTC\" , \"GTACAAATCTTGCC\" ) False >>> est_inclus ( \"AGTC\" , \"GTACAAATCTTGCA\" ) False >>> est_inclus ( \"AGTC\" , \"GTACAAATCTAGTC\" ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlineassert estpython-underscoreinclus(\"AAAA\", \"AAAAGTATCTTGCC\")backslash-newlineassert estpython-underscoreinclus(\"GTAC\", \"GTACAAATCTTGCC\")backslash-newlineassert estpython-underscoreinclus(\"AAAA\", \"GTACAAATCTAAAA\")backslash-newlineassert estpython-underscoreinclus(\"AGTA\", \"GTACAAATCTAGTA\")backslash-newlineassert not estpython-underscoreinclus(\"AGTA\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline Valider 5/5 def estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(extrait, chaine, position):backslash-newline if ... > len(chaine):backslash-newline return Falsebackslash-newline for i in range(len(extrait)):backslash-newline if chaine[position + ...] != ...:backslash-newline return ...backslash-newline return Truebackslash-newlinebackslash-newlinedef estpython-underscoreinclus(brin, gene):backslash-newline lpython-underscoregene = len(gene)backslash-newline lpython-underscorebrin = len(brin)backslash-newline for i in range(... - ... + 1):backslash-newline if estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(..., ..., ...):backslash-newline return Truebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline def estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(extrait, chaine, position):backslash-newline if position + len(extrait) > len(chaine):backslash-newline return Falsebackslash-newline for i in range(len(extrait)):backslash-newline if chaine[position + i] != extrait[i]:backslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef estpython-underscoreinclus(brin, gene):backslash-newline lpython-underscoregene = len(gene)backslash-newline lpython-underscorebrin = len(brin)backslash-newline for i in range(lpython-underscoregene - lpython-underscorebrin + 1):backslash-newline if estpython-underscoreincluspython-underscoreapython-underscorepartirpython-underscorede(brin, gene, i):backslash-newline return Truebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert estpython-underscoreinclus(\"AATC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCC\")backslash-newlineassert not estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTTGCA\")backslash-newlineassert estpython-underscoreinclus(\"AGTC\", \"GTACAAATCTAGTC\")backslash-newlinebackslash-newline A Z","title":"Inclusion de texte"},{"location":"2-moyen/est_nb_palindrome/sujet/","tags":["a_trou","string","boucle"],"text":"Tester si un nombre est un palindrome \u2693\ufe0e Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : 'esse' , 'radar' , et 'non' sont des mots palindromes. De m\u00eame certains nombres sont eux-aussi des palindromes : \\(33\\) , \\(121\\) , \\(345543\\) . L'objectif de cet exercice est d'obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci-dessous sachant que la fonction est_nbr_palindrome s'appuiera sur la fonction est_palindrome qui elle-m\u00eame s'appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une chaine de caract\u00e8res chaine et renvoie la chaine invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c'est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbr_palindrome teste si un nombre nombre est un palindrome. Elle renvoie True si c'est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): resultat = ... for caractere in chaine : resultat = ... return resultat def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbr_palindrome ( nombre ): chaine = ... return est_palindrome ( chaine ) Exemples \ud83d\udc0d Console Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbr_palindrome ( 214312 ) False >>> est_nbr_palindrome ( 213312 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def inversepython-underscorechaine(chaine):backslash-newline resultat = \"\"backslash-newline for caractere in chaine:backslash-newline resultat = caractere + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return chaine == inversebackslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = str(nombre)backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlineassert inversepython-underscorechaine('azerty') == 'ytreza'backslash-newlineassert inversepython-underscorechaine('azerty0') == '0ytreza'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('AZERTY')backslash-newlineassert not estpython-underscorepalindrome('AZERTY0')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ABCTCBA')backslash-newlineassert estpython-underscorepalindrome('ABCDDCBA')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(132213)backslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(1327213)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(122345543221)backslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(1223457543221)backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def inversepython-underscorechaine(chaine):backslash-newline resultat = ...backslash-newline for caractere in chaine:backslash-newline resultat = ...backslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return ...backslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = ...backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newline def inversepython-underscorechaine(chaine):backslash-newline resultat = \"\"backslash-newline for caractere in chaine:backslash-newline resultat = caractere + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return chaine == inversebackslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = str(nombre)backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newline A Z","title":"Nombre est-il palindrome"},{"location":"2-moyen/est_nb_palindrome/sujet/#tester-si-un-nombre-est-un-palindrome","text":"Un mot palindrome peut se lire de la m\u00eame fa\u00e7on de gauche \u00e0 droite ou de droite \u00e0 gauche : 'esse' , 'radar' , et 'non' sont des mots palindromes. De m\u00eame certains nombres sont eux-aussi des palindromes : \\(33\\) , \\(121\\) , \\(345543\\) . L'objectif de cet exercice est d'obtenir un programme Python permettant de tester si un nombre est un nombre palindrome. Pour remplir cette t\u00e2che, on vous demande de compl\u00e9ter le code des trois fonctions ci-dessous sachant que la fonction est_nbr_palindrome s'appuiera sur la fonction est_palindrome qui elle-m\u00eame s'appuiera sur la fonction inverse_chaine . La fonction inverse_chaine inverse l'ordre des caract\u00e8res d'une chaine de caract\u00e8res chaine et renvoie la chaine invers\u00e9e. La fonction est_palindrome teste si une chaine de caract\u00e8res chaine est un palindrome. Elle renvoie True si c'est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. La fonction est_nbr_palindrome teste si un nombre nombre est un palindrome. Elle renvoie True si c'est le cas et False sinon. Cette fonction s'appuie sur la fonction pr\u00e9c\u00e9dente. Compl\u00e9ter le code des trois fonctions ci-dessous. \ud83d\udc0d Script Python def inverse_chaine ( chaine ): resultat = ... for caractere in chaine : resultat = ... return resultat def est_palindrome ( chaine ): inverse = inverse_chaine ( chaine ) return ... def est_nbr_palindrome ( nombre ): chaine = ... return est_palindrome ( chaine ) Exemples \ud83d\udc0d Console Python >>> inverse_chaine ( 'bac' ) 'cab' >>> est_palindrome ( 'NSI' ) False >>> est_palindrome ( 'ISN-NSI' ) True >>> est_nbr_palindrome ( 214312 ) False >>> est_nbr_palindrome ( 213312 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def inversepython-underscorechaine(chaine):backslash-newline resultat = \"\"backslash-newline for caractere in chaine:backslash-newline resultat = caractere + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return chaine == inversebackslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = str(nombre)backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlineassert inversepython-underscorechaine('azerty') == 'ytreza'backslash-newlineassert inversepython-underscorechaine('azerty0') == '0ytreza'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('AZERTY')backslash-newlineassert not estpython-underscorepalindrome('AZERTY0')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ABCTCBA')backslash-newlineassert estpython-underscorepalindrome('ABCDDCBA')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(132213)backslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(1327213)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(122345543221)backslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(1223457543221)backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def inversepython-underscorechaine(chaine):backslash-newline resultat = ...backslash-newline for caractere in chaine:backslash-newline resultat = ...backslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return ...backslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = ...backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newline def inversepython-underscorechaine(chaine):backslash-newline resultat = \"\"backslash-newline for caractere in chaine:backslash-newline resultat = caractere + resultatbackslash-newline return resultatbackslash-newlinebackslash-newlinedef estpython-underscorepalindrome(chaine):backslash-newline inverse = inversepython-underscorechaine(chaine)backslash-newline return chaine == inversebackslash-newlinebackslash-newlinedef estpython-underscorenbrpython-underscorepalindrome(nombre):backslash-newline chaine = str(nombre)backslash-newline return estpython-underscorepalindrome(chaine)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert inversepython-underscorechaine('bac') == 'cab'backslash-newlinebackslash-newlineassert not estpython-underscorepalindrome('NSI')backslash-newlinebackslash-newlineassert estpython-underscorepalindrome('ISN-NSI')backslash-newlinebackslash-newlineassert not estpython-underscorenbrpython-underscorepalindrome(214312)backslash-newlinebackslash-newlineassert estpython-underscorenbrpython-underscorepalindrome(213312)backslash-newlinebackslash-newline A Z","title":"Tester si un nombre est un palindrome"},{"location":"2-moyen/est_parfait/sujet/","tags":["a_trou","boucle","maths","string"],"text":"La perfection d'un mot \u2693\ufe0e On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' \\(1\\) \\(2\\) \\(3\\) \\(4\\) \\(5\\) \\(6\\) \\(7\\) \\(8\\) \\(9\\) 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q' 'R' \\(10\\) \\(11\\) \\(12\\) \\(13\\) \\(14\\) \\(15\\) \\(16\\) \\(17\\) \\(18\\) 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z' \\(19\\) \\(20\\) \\(21\\) \\(22\\) \\(23\\) \\(24\\) \\(25\\) \\(26\\) Pour un mot donn\u00e9 (une chaine de caract\u00e8res non vide uniquement compos\u00e9e de lettres majuscules), on d\u00e9termine : d'une part son code alphab\u00e9tique concat\u00e9n\u00e9, obtenu par la juxtaposition du texte des codes de chacun de ses caract\u00e8res, et lu comme un unique entier, et d'autre part, son code additionn\u00e9, qui est la somme des codes de chacun de ses caract\u00e8res. On dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples Pour le mot \"PAUL\" , les codes sont \\(16, 1, 21, 12\\) . Le code concat\u00e9n\u00e9 est la chaine 1612112 , soit l'entier \\(1\\,612\\,112\\) . Son code additionn\u00e9 est l'entier \\(16 + 1 + 21 + 12\\) qui donne \\(50\\) . \\(50\\) ne divise pas l'entier \\(1\\,612\\,112\\) ; par cons\u00e9quent, le mot \"PAUL\" n'est pas parfait. Pour le mot \"ALAIN\" , les codes sont \\(1, 12, 1, 9, 14\\) . Le code concat\u00e9n\u00e9 est la chaine 1121914 , soit l'entier \\(1\\,121\\,914\\) . Le code additionn\u00e9 est l'entier \\(37\\) , car \\(1 + 12 + 1 + 9 + 14 = 37\\) . \\(37\\) divise l'entier \\(1\\,121\\,914\\) ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Rappel conversion Pour cet exercice on pourra utiliser str et int comme fonctions de conversion. D'autre part, on pourra utiliser la fonction ord qui renvoie le code ASCII d'un caract\u00e8re ASCII pass\u00e9 en param\u00e8tre. \ud83d\udc0d Console Python >>> ord ( 'A' ) 65 >>> ord ( 'B' ) 66 \ud83d\udc0d Console Python >>> str ( 12 ) '12' >>> str ( 12 ) + str ( 14 ) '1214' >>> int ( '1214' ) 1214 >>> int ( '1214' ) % 10 4 Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une chaine de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu'un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python def code ( lettre ): \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\" return ord ( lettre ) - ord ( 'A' ) + 1 def est_parfait ( mot ) : code_int_cumul = ... code_str_concatene = \"\" for lettre in mot : valeur = code ( ... ) code_int_cumul = ... code_str_concatene = ... code_concatene = ... ( code_str_concatene ) mot_est_parfait = ( ... % ... == 0 ) # un bool\u00c3\u00a9en return ( code_int_cumul , code_concatene , mot_est_parfait ) Exemples \ud83d\udc0d Console Python >>> est_parfait ( \"PAUL\" ) (50, 1612112, False) >>> est_parfait ( \"ALAIN\" ) (37, 1121914, True) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorePARFAIT(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = 0backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = ord(lettre) - ord('A') + 1backslash-newline codepython-underscoreintpython-underscorecumul += valeurbackslash-newline codepython-underscorestrpython-underscoreconcatene += str(valeur)backslash-newline codepython-underscoreconcatene = int(codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (codepython-underscoreconcatene % codepython-underscoreintpython-underscorecumul == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinefor i in range(26):backslash-newline mot = chr(ord('A') + i)backslash-newline resultat = estpython-underscoreparfait(mot)backslash-newline attendu = ESTpython-underscorePARFAIT(mot)backslash-newline assert attendu == resultat, f\"Erreur avec le mot {mot}\"backslash-newlinebackslash-newlinefor j in range(26):backslash-newline for j in range(26):backslash-newline mot = chr(ord('A') + i) + chr(ord('A') + j)backslash-newline resultat = estpython-underscoreparfait(mot)backslash-newline attendu = ESTpython-underscorePARFAIT(mot)backslash-newline assert attendu == resultat, f\"Erreur avec le mot {mot}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def code(lettre):backslash-newline \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\"backslash-newline return ord(lettre) - ord('A') + 1backslash-newlinebackslash-newlinedef estpython-underscoreparfait(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = ...backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = code(...)backslash-newline codepython-underscoreintpython-underscorecumul = ...backslash-newline codepython-underscorestrpython-underscoreconcatene = ...backslash-newline codepython-underscoreconcatene = ... (codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (... % ... == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline def code(lettre):backslash-newline \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\"backslash-newline return ord(lettre) - ord('A') + 1backslash-newlinebackslash-newlinedef estpython-underscoreparfait(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = 0backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = code(lettre)backslash-newline codepython-underscoreintpython-underscorecumul += valeurbackslash-newline codepython-underscorestrpython-underscoreconcatene += str(valeur)backslash-newline codepython-underscoreconcatene = int(codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (codepython-underscoreconcatene % codepython-underscoreintpython-underscorecumul == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline A Z","title":"Un mot est-il parfait ?"},{"location":"2-moyen/est_parfait/sujet/#la-perfection-dun-mot","text":"On affecte \u00e0 chaque lettre de l'alphabet un code selon le tableau ci-dessous : 'A' 'B' 'C' 'D' 'E' 'F' 'G' 'H' 'I' \\(1\\) \\(2\\) \\(3\\) \\(4\\) \\(5\\) \\(6\\) \\(7\\) \\(8\\) \\(9\\) 'J' 'K' 'L' 'M' 'N' 'O' 'P' 'Q' 'R' \\(10\\) \\(11\\) \\(12\\) \\(13\\) \\(14\\) \\(15\\) \\(16\\) \\(17\\) \\(18\\) 'S' 'T' 'U' 'V' 'W' 'X' 'Y' 'Z' \\(19\\) \\(20\\) \\(21\\) \\(22\\) \\(23\\) \\(24\\) \\(25\\) \\(26\\) Pour un mot donn\u00e9 (une chaine de caract\u00e8res non vide uniquement compos\u00e9e de lettres majuscules), on d\u00e9termine : d'une part son code alphab\u00e9tique concat\u00e9n\u00e9, obtenu par la juxtaposition du texte des codes de chacun de ses caract\u00e8res, et lu comme un unique entier, et d'autre part, son code additionn\u00e9, qui est la somme des codes de chacun de ses caract\u00e8res. On dit que ce mot est \u00ab parfait \u00bb si le code additionn\u00e9 divise le code concat\u00e9n\u00e9. Exemples Pour le mot \"PAUL\" , les codes sont \\(16, 1, 21, 12\\) . Le code concat\u00e9n\u00e9 est la chaine 1612112 , soit l'entier \\(1\\,612\\,112\\) . Son code additionn\u00e9 est l'entier \\(16 + 1 + 21 + 12\\) qui donne \\(50\\) . \\(50\\) ne divise pas l'entier \\(1\\,612\\,112\\) ; par cons\u00e9quent, le mot \"PAUL\" n'est pas parfait. Pour le mot \"ALAIN\" , les codes sont \\(1, 12, 1, 9, 14\\) . Le code concat\u00e9n\u00e9 est la chaine 1121914 , soit l'entier \\(1\\,121\\,914\\) . Le code additionn\u00e9 est l'entier \\(37\\) , car \\(1 + 12 + 1 + 9 + 14 = 37\\) . \\(37\\) divise l'entier \\(1\\,121\\,914\\) ; par cons\u00e9quent, le mot \"ALAIN\" est parfait. Rappel conversion Pour cet exercice on pourra utiliser str et int comme fonctions de conversion. D'autre part, on pourra utiliser la fonction ord qui renvoie le code ASCII d'un caract\u00e8re ASCII pass\u00e9 en param\u00e8tre. \ud83d\udc0d Console Python >>> ord ( 'A' ) 65 >>> ord ( 'B' ) 66 \ud83d\udc0d Console Python >>> str ( 12 ) '12' >>> str ( 12 ) + str ( 14 ) '1214' >>> int ( '1214' ) 1214 >>> int ( '1214' ) % 10 4 Compl\u00e9ter la fonction est_parfait ci-dessous qui prend comme argument une chaine de caract\u00e8res mot (en lettres majuscules) et qui renvoie le code alphab\u00e9tique concat\u00e9n\u00e9, le code additionn\u00e9 de mot , ainsi qu'un bool\u00e9en qui indique si mot est parfait ou pas. \ud83d\udc0d Script Python def code ( lettre ): \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\" return ord ( lettre ) - ord ( 'A' ) + 1 def est_parfait ( mot ) : code_int_cumul = ... code_str_concatene = \"\" for lettre in mot : valeur = code ( ... ) code_int_cumul = ... code_str_concatene = ... code_concatene = ... ( code_str_concatene ) mot_est_parfait = ( ... % ... == 0 ) # un bool\u00c3\u00a9en return ( code_int_cumul , code_concatene , mot_est_parfait ) Exemples \ud83d\udc0d Console Python >>> est_parfait ( \"PAUL\" ) (50, 1612112, False) >>> est_parfait ( \"ALAIN\" ) (37, 1121914, True) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorePARFAIT(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = 0backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = ord(lettre) - ord('A') + 1backslash-newline codepython-underscoreintpython-underscorecumul += valeurbackslash-newline codepython-underscorestrpython-underscoreconcatene += str(valeur)backslash-newline codepython-underscoreconcatene = int(codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (codepython-underscoreconcatene % codepython-underscoreintpython-underscorecumul == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinefor i in range(26):backslash-newline mot = chr(ord('A') + i)backslash-newline resultat = estpython-underscoreparfait(mot)backslash-newline attendu = ESTpython-underscorePARFAIT(mot)backslash-newline assert attendu == resultat, f\"Erreur avec le mot {mot}\"backslash-newlinebackslash-newlinefor j in range(26):backslash-newline for j in range(26):backslash-newline mot = chr(ord('A') + i) + chr(ord('A') + j)backslash-newline resultat = estpython-underscoreparfait(mot)backslash-newline attendu = ESTpython-underscorePARFAIT(mot)backslash-newline assert attendu == resultat, f\"Erreur avec le mot {mot}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def code(lettre):backslash-newline \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\"backslash-newline return ord(lettre) - ord('A') + 1backslash-newlinebackslash-newlinedef estpython-underscoreparfait(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = ...backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = code(...)backslash-newline codepython-underscoreintpython-underscorecumul = ...backslash-newline codepython-underscorestrpython-underscoreconcatene = ...backslash-newline codepython-underscoreconcatene = ... (codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (... % ... == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline def code(lettre):backslash-newline \"Renvoie le code suivant l'\u00c3\u00a9nonc\u00c3\u00a9.\"backslash-newline return ord(lettre) - ord('A') + 1backslash-newlinebackslash-newlinedef estpython-underscoreparfait(mot) :backslash-newline codepython-underscoreintpython-underscorecumul = 0backslash-newline codepython-underscorestrpython-underscoreconcatene = \"\"backslash-newline for lettre in mot:backslash-newline valeur = code(lettre)backslash-newline codepython-underscoreintpython-underscorecumul += valeurbackslash-newline codepython-underscorestrpython-underscoreconcatene += str(valeur)backslash-newline codepython-underscoreconcatene = int(codepython-underscorestrpython-underscoreconcatene)backslash-newline motpython-underscoreestpython-underscoreparfait = (codepython-underscoreconcatene % codepython-underscoreintpython-underscorecumul == 0) # un bool\u00c3\u00a9enbackslash-newline return (codepython-underscoreintpython-underscorecumul, codepython-underscoreconcatene, motpython-underscoreestpython-underscoreparfait)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert estpython-underscoreparfait(\"PAUL\") == (50, 1612112, False)backslash-newlineassert estpython-underscoreparfait(\"ALAIN\") == (37, 1121914, True)backslash-newlinebackslash-newline A Z","title":"La perfection d'un mot"},{"location":"2-moyen/expr_parenthesee/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python class Noeud : \"\"\" Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00c3\u00a9tiquette, - gauche : le sous-arbre \u00c3 gauche. - droite : le sous-arbre \u00c3 droite. \"\"\" def __init__ ( self , gauche , valeur , droite ): self . gauche = gauche self . valeur = valeur self . droite = droite def est_feuille ( self ): \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\" return self . gauche is None and self . droite is None def expression_parenthesee ( e ): if e . est_feuille (): return str ( e . valeur ) else : return '(' \\ + expression_parenthesee ( e . gauche ) \\ + e . valeur \\ + expression_parenthesee ( e . droite ) \\ + ')' Si e est une feuille, on souhaite renvoyer la valeur sans parenth\u00e8se, donc on renvoie str ( e . valeur ) une chaine de caract\u00e8res. Sinon, on concat\u00e8ne du texte avec l'op\u00e9rateur + : Une parenth\u00e8se ouvrante. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 gauche e.gauche L'op\u00e9rateur sous forme de texte. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 droite e.droite Une parenth\u00e8se fermante. On utilise ici une contre-oblique pour sauter des lignes. Si l'expression renvoy\u00e9e \u00e9tait incluse dans des parenth\u00e8ses, ou crochet, ou accolades, ces contre-obliques auraient \u00e9t\u00e9 inutiles.","title":"Commentaires"},{"location":"2-moyen/expr_parenthesee/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python class Noeud : \"\"\" Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00c3\u00a9tiquette, - gauche : le sous-arbre \u00c3 gauche. - droite : le sous-arbre \u00c3 droite. \"\"\" def __init__ ( self , gauche , valeur , droite ): self . gauche = gauche self . valeur = valeur self . droite = droite def est_feuille ( self ): \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\" return self . gauche is None and self . droite is None def expression_parenthesee ( e ): if e . est_feuille (): return str ( e . valeur ) else : return '(' \\ + expression_parenthesee ( e . gauche ) \\ + e . valeur \\ + expression_parenthesee ( e . droite ) \\ + ')' Si e est une feuille, on souhaite renvoyer la valeur sans parenth\u00e8se, donc on renvoie str ( e . valeur ) une chaine de caract\u00e8res. Sinon, on concat\u00e8ne du texte avec l'op\u00e9rateur + : Une parenth\u00e8se ouvrante. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 gauche e.gauche L'op\u00e9rateur sous forme de texte. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 droite e.droite Une parenth\u00e8se fermante. On utilise ici une contre-oblique pour sauter des lignes. Si l'expression renvoy\u00e9e \u00e9tait incluse dans des parenth\u00e8ses, ou crochet, ou accolades, ces contre-obliques auraient \u00e9t\u00e9 inutiles.","title":"Commentaires"},{"location":"2-moyen/expr_parenthesee/sujet/","tags":["a_trou","POO","arbre"],"text":"Expression parenth\u00e9s\u00e9e \u2693\ufe0e Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations \\(+, - , \u00d7, \u00f7\\) peut \u00eatre repr\u00e9sent\u00e9e sous forme d'arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. Les n\u0153uds internes (pour les op\u00e9rateurs binaires) ont tous deux sous arbres non vides : les op\u00e9randes. Les feuilles rassemblent tous les nombres. Avec un parcours en profondeur infixe l'arbre binaire ci-dessous, on peut retrouver l'expression not\u00e9e habituellement : \\(3 \u00d7 (8 + 7) - (2 + 1)\\) . La classe Noeud ci-apr\u00e8s permet d'impl\u00e9menter une structure d'arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_parenthesee qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l'expression arithm\u00e9tique repr\u00e9sent\u00e9e par l'arbre binaire pass\u00e9 en param\u00e8tre, sous forme d'une chaine de caract\u00e8res contenant des parenth\u00e8ses. \ud83d\udc0d Script Python class Noeud : \"\"\" Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00c3\u00a9tiquette, - gauche : le sous-arbre \u00c3 gauche. - droite : le sous-arbre \u00c3 droite. \"\"\" def __init__ ( self , gauche , valeur , droite ): self . gauche = gauche self . valeur = valeur self . droite = droite def est_feuille ( self ): \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\" return self . gauche is None and self . droite is None def expression_parenthesee ( e ): if e . est_feuille (): return str ( ... ) else : return '(' + expression_parenthesee ( ... ) + ... Exemple R\u00e9sultat attendu avec l'arbre ci-dessus : \ud83d\udc0d Console Python >>> somme_1 = Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None )) >>> somme_2 = Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None )) >>> produit_1 = Noeud ( Noeud ( None , 3 , None ), '*' , somme_1 ) >>> expression = Noeud ( produit_1 , '-' , somme_2 ) >>> expression_parenthesee ( expression ) '((3*(8+7))-(2+1))' \ud83d\udc0d Console Python >>> feuille = Noeud ( None , 5 , None ) >>> expression_parenthesee ( feuille ) '5' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlinebackslash-newlinenombre = Noeud(None, 42, None)backslash-newlineassert expressionpython-underscoreparenthesee(nombre) == '42'backslash-newlinebackslash-newlinesomme = Noeud(Noeud(None, 1, None), '+', Noeud(None, 2, None))backslash-newlineassert expressionpython-underscoreparenthesee(somme) == '(1+2)'backslash-newlinebackslash-newlinequotient = Noeud(Noeud(None, 3, None), '/', somme)backslash-newlineassert expressionpython-underscoreparenthesee(quotient) == '(3/(1+2))'backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 class Noeud:backslash-newline \"\"\"backslash-newline Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs :backslash-newline - valeur : la valeur de l'\u00c3\u00a9tiquette,backslash-newline - gauche : le sous-arbre \u00c3 gauche.backslash-newline - droite : le sous-arbre \u00c3 droite.backslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, valeur, droite):backslash-newline self.gauche = gauchebackslash-newline self.valeur = valeurbackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorefeuille(self):backslash-newline \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\"backslash-newline return self.gauche is None and self.droite is Nonebackslash-newlinebackslash-newlinebackslash-newlinedef expressionpython-underscoreparenthesee(e):backslash-newline if e.estpython-underscorefeuille():backslash-newline return str(...)backslash-newline else:backslash-newline return '(' + expressionpython-underscoreparenthesee(...) + ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinefeuille = Noeud(None, 5, None)backslash-newlineassert expressionpython-underscoreparenthesee(feuille) == '5'backslash-newlinebackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newline class Noeud:backslash-newline \"\"\"backslash-newline Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs :backslash-newline - valeur : la valeur de l'\u00c3\u00a9tiquette,backslash-newline - gauche : le sous-arbre \u00c3 gauche.backslash-newline - droite : le sous-arbre \u00c3 droite.backslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, valeur, droite):backslash-newline self.gauche = gauchebackslash-newline self.valeur = valeurbackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorefeuille(self):backslash-newline \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\"backslash-newline return self.gauche is None and self.droite is Nonebackslash-newlinebackslash-newlinebackslash-newlinedef expressionpython-underscoreparenthesee(e):backslash-newline if e.estpython-underscorefeuille():backslash-newline return str(e.valeur)backslash-newline else:backslash-newline return '(' \\backslash-newline + expressionpython-underscoreparenthesee(e.gauche)\\backslash-newline + e.valeur\\backslash-newline + expressionpython-underscoreparenthesee(e.droite)\\backslash-newline + ')'backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py_sujet('exo_corr') }} Si e est une feuille, on souhaite renvoyer la valeur sans parenth\u00e8se, donc on renvoie str ( e . valeur ) une chaine de caract\u00e8res. Sinon, on concat\u00e8ne du texte avec l'op\u00e9rateur + : Une parenth\u00e8se ouvrante. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 gauche e.gauche L'op\u00e9rateur sous forme de texte. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 droite e.droite Une parenth\u00e8se fermante. On utilise ici une contre-oblique pour sauter des lignes. Si l'expression renvoy\u00e9e \u00e9tait incluse dans des parenth\u00e8ses, ou crochet, ou accolades, ces contre-obliques auraient \u00e9t\u00e9 inutiles. Z","title":"Expression parenth\u00e9s\u00e9e"},{"location":"2-moyen/expr_parenthesee/sujet/#expression-parenthesee","text":"Une expression arithm\u00e9tique ne comportant que les quatre op\u00e9rations \\(+, - , \u00d7, \u00f7\\) peut \u00eatre repr\u00e9sent\u00e9e sous forme d'arbre binaire. Les n\u0153uds internes sont des op\u00e9rateurs et les feuilles sont des nombres. Dans un tel arbre, la disposition des n\u0153uds joue le r\u00f4le des parenth\u00e8ses que nous connaissons bien. Les n\u0153uds internes (pour les op\u00e9rateurs binaires) ont tous deux sous arbres non vides : les op\u00e9randes. Les feuilles rassemblent tous les nombres. Avec un parcours en profondeur infixe l'arbre binaire ci-dessous, on peut retrouver l'expression not\u00e9e habituellement : \\(3 \u00d7 (8 + 7) - (2 + 1)\\) . La classe Noeud ci-apr\u00e8s permet d'impl\u00e9menter une structure d'arbre binaire. Compl\u00e9ter la fonction r\u00e9cursive expression_parenthesee qui prend en param\u00e8tre un objet de la classe Noeud et qui renvoie l'expression arithm\u00e9tique repr\u00e9sent\u00e9e par l'arbre binaire pass\u00e9 en param\u00e8tre, sous forme d'une chaine de caract\u00e8res contenant des parenth\u00e8ses. \ud83d\udc0d Script Python class Noeud : \"\"\" Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs : - valeur : la valeur de l'\u00c3\u00a9tiquette, - gauche : le sous-arbre \u00c3 gauche. - droite : le sous-arbre \u00c3 droite. \"\"\" def __init__ ( self , gauche , valeur , droite ): self . gauche = gauche self . valeur = valeur self . droite = droite def est_feuille ( self ): \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\" return self . gauche is None and self . droite is None def expression_parenthesee ( e ): if e . est_feuille (): return str ( ... ) else : return '(' + expression_parenthesee ( ... ) + ... Exemple R\u00e9sultat attendu avec l'arbre ci-dessus : \ud83d\udc0d Console Python >>> somme_1 = Noeud ( Noeud ( None , 8 , None ), '+' , Noeud ( None , 7 , None )) >>> somme_2 = Noeud ( Noeud ( None , 2 , None ), '+' , Noeud ( None , 1 , None )) >>> produit_1 = Noeud ( Noeud ( None , 3 , None ), '*' , somme_1 ) >>> expression = Noeud ( produit_1 , '-' , somme_2 ) >>> expression_parenthesee ( expression ) '((3*(8+7))-(2+1))' \ud83d\udc0d Console Python >>> feuille = Noeud ( None , 5 , None ) >>> expression_parenthesee ( feuille ) '5' Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # autres testsbackslash-newlinebackslash-newlinenombre = Noeud(None, 42, None)backslash-newlineassert expressionpython-underscoreparenthesee(nombre) == '42'backslash-newlinebackslash-newlinesomme = Noeud(Noeud(None, 1, None), '+', Noeud(None, 2, None))backslash-newlineassert expressionpython-underscoreparenthesee(somme) == '(1+2)'backslash-newlinebackslash-newlinequotient = Noeud(Noeud(None, 3, None), '/', somme)backslash-newlineassert expressionpython-underscoreparenthesee(quotient) == '(3/(1+2))'backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 class Noeud:backslash-newline \"\"\"backslash-newline Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs :backslash-newline - valeur : la valeur de l'\u00c3\u00a9tiquette,backslash-newline - gauche : le sous-arbre \u00c3 gauche.backslash-newline - droite : le sous-arbre \u00c3 droite.backslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, valeur, droite):backslash-newline self.gauche = gauchebackslash-newline self.valeur = valeurbackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorefeuille(self):backslash-newline \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\"backslash-newline return self.gauche is None and self.droite is Nonebackslash-newlinebackslash-newlinebackslash-newlinedef expressionpython-underscoreparenthesee(e):backslash-newline if e.estpython-underscorefeuille():backslash-newline return str(...)backslash-newline else:backslash-newline return '(' + expressionpython-underscoreparenthesee(...) + ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinefeuille = Noeud(None, 5, None)backslash-newlineassert expressionpython-underscoreparenthesee(feuille) == '5'backslash-newlinebackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newline class Noeud:backslash-newline \"\"\"backslash-newline Classe impl\u00c3\u00a9mentant un n\u00c5\u201cud d'arbre binaire disposant de 3 attributs :backslash-newline - valeur : la valeur de l'\u00c3\u00a9tiquette,backslash-newline - gauche : le sous-arbre \u00c3 gauche.backslash-newline - droite : le sous-arbre \u00c3 droite.backslash-newline \"\"\"backslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, gauche, valeur, droite):backslash-newline self.gauche = gauchebackslash-newline self.valeur = valeurbackslash-newline self.droite = droitebackslash-newline backslash-newline def estpython-underscorefeuille(self):backslash-newline \"Renvoie un bool\u00c3\u00a9en, la r\u00c3\u00a9ponse \u00c3 : le n\u00c5\u201cud est-il une feuille ?\"backslash-newline return self.gauche is None and self.droite is Nonebackslash-newlinebackslash-newlinebackslash-newlinedef expressionpython-underscoreparenthesee(e):backslash-newline if e.estpython-underscorefeuille():backslash-newline return str(e.valeur)backslash-newline else:backslash-newline return '(' \\backslash-newline + expressionpython-underscoreparenthesee(e.gauche)\\backslash-newline + e.valeur\\backslash-newline + expressionpython-underscoreparenthesee(e.droite)\\backslash-newline + ')'backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinesommepython-underscore1 = Noeud(Noeud(None, 8, None), '+', Noeud(None, 7, None))backslash-newlinesommepython-underscore2 = Noeud(Noeud(None, 2, None), '+', Noeud(None, 1, None))backslash-newlineproduitpython-underscore1 = Noeud(Noeud(None, 3, None), 'python-star', sommepython-underscore1)backslash-newlineexpression = Noeud(produitpython-underscore1, '-', sommepython-underscore2)backslash-newlinebackslash-newlineassert expressionpython-underscoreparenthesee(expression) == '((3python-star(8+7))-(2+1))'backslash-newlinebackslash-newlinebackslash-newline A","title":"Expression parenth\u00e9s\u00e9e"},{"location":"2-moyen/expr_parenthesee/sujet/#commentaires","text":"{{ py_sujet('exo_corr') }} Si e est une feuille, on souhaite renvoyer la valeur sans parenth\u00e8se, donc on renvoie str ( e . valeur ) une chaine de caract\u00e8res. Sinon, on concat\u00e8ne du texte avec l'op\u00e9rateur + : Une parenth\u00e8se ouvrante. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 gauche e.gauche L'op\u00e9rateur sous forme de texte. L'expression parenth\u00e9s\u00e9e du sous-arbre \u00e0 droite e.droite Une parenth\u00e8se fermante. On utilise ici une contre-oblique pour sauter des lignes. Si l'expression renvoy\u00e9e \u00e9tait incluse dans des parenth\u00e8ses, ou crochet, ou accolades, ces contre-obliques auraient \u00e9t\u00e9 inutiles. Z","title":"Commentaires"},{"location":"2-moyen/formes/sujet/","tags":["a_trou","boucle","string"],"text":"Formes pleines et formes creuses \u2693\ufe0e \ud83c\udfa8 Un rectangle 3\u00d75 plein, motif: # ##### ##### ##### \ud83c\udfa8 Un triangle creux 5\u00d75, motif: Y Y YY Y Y Y Y YYYYY Dans cet exercice, on travaille avec des listes de chaines de caract\u00e8res pour repr\u00e9senter des dessins. Chaque ligne d'un dessin sera une chaine de caract\u00e8res non vide. Un dessin sera une liste non vide de lignes. Lignes et dessins, dans cet exercice ligne_pleine et ligne_creuse sont des fonctions qui renvoient une ligne que l'on peut afficher avec print rectangle et triangle en version creux ou plein sont des fonctions qui renvoient un dessin (une liste de lignes) que l'on peut afficher avec dessine . Compl\u00e9ter le code suivant afin de disposer des fonctions indiqu\u00e9es. On utilisera les fonctions simples dans les fonctions \u00e9labor\u00e9es. Vous n'avez qu'\u00e0 compl\u00e9ter les fonctions ligne , rectangle et triangle dans chacune des deux versions. Le param\u00e8tre motif sera une chaine de caract\u00e8res de longueur 1. D\u00e9commenter bloc par bloc les assertions Le premier bloc d'assertions est actif. Il permet de tester la fonction ligne_pleine . Quand vous avez r\u00e9ussi, vous pouvez d\u00e9commenter le bloc suivant d'assertions. Pour cela, il suffit de d\u00e9placer la ligne \"\"\" sous le bloc. Exemples \ud83d\udc0d Console Python >>> print ( ligne_pleine ( 'M' , 1 )) M >>> print ( ligne_pleine ( '#' , 5 )) ##### >>> print ( ligne_creuse ( 'X' , 5 )) X X >>> print ( ligne_creuse ( 'M' , 1 )) M \ud83d\udc0d Console Python >>> dessine ( rectangle_plein ( 'A' , 3 , 5 )) AAAAA AAAAA AAAAA >>> dessine ( rectangle_creux ( 'O' , 3 , 5 )) OOOOO O O OOOOO >>> dessine ( rectangle_creux ( 'O' , 1 , 5 )) OOOOO \ud83d\udc0d Console Python >>> dessine ( triangle_plein ( 'T' , 5 )) T TT TTT TTTT TTTTT >>> dessine ( triangle_creux ( 'F' , 5 )) F FF F F F F FFFFF >>> dessine ( triangle_creux ( 'K' , 1 )) K Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('P', 7) == \"PPPPPPP\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('P', 7) == \"P P\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('1', 3, 1) == [backslash-newline \"1\",backslash-newline \"1\",backslash-newline \"1\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('8', 3, 8) == [backslash-newline \"88888888\",backslash-newline \"88888888\",backslash-newline \"88888888\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('C', 1, 7) == [\"CCCCCCC\"]backslash-newlineassert rectanglepython-underscorecreux('C', 3, 1) == [backslash-newline \"C\",backslash-newline \"C\",backslash-newline \"C\",backslash-newline]backslash-newlineassert rectanglepython-underscorecreux('C', 4, 6) == [backslash-newline \"CCCCCC\",backslash-newline \"C C\",backslash-newline \"C C\",backslash-newline \"CCCCCC\",backslash-newline]backslash-newlinebackslash-newline Valider 5/5 def dessine(lignes):backslash-newline \"\"\"Affiche les rectangles et les trianglesbackslash-newline N'affiche pas les lignes ! Pour une ligne : utiliser printbackslash-newline \"\"\"backslash-newline for ligne in lignes:backslash-newline print(ligne)backslash-newlinebackslash-newlinedef lignepython-underscorepleine(motif, nbpython-underscorecolonnes):backslash-newline return ...backslash-newlinebackslash-newlinedef lignepython-underscorecreuse(motif, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorecolonnes == 1:backslash-newline return ...backslash-newline else:backslash-newline return motif + \" \" python-star (nbpython-underscorecolonnes - 2) + ...backslash-newlinebackslash-newlinedef rectanglepython-underscoreplein(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline resultat = []backslash-newline for i in range(...):backslash-newline resultat.append(...)backslash-newline return resultatbackslash-newlinebackslash-newlinedef rectanglepython-underscorecreux(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [lignepython-underscorepleine(...)]backslash-newline else:backslash-newline resultat = [...]backslash-newline for i in range(...):backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscoreplein(motif, nbpython-underscorelignes):backslash-newline ...backslash-newlinebackslash-newlinedef trianglepython-underscorecreux(motif, nbpython-underscorelignes):backslash-newline ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newline# Conseil : d\u00c3\u00a9commenter bloc par bloc les assertionsbackslash-newline\"\"\"backslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline\"\"\"backslash-newlinebackslash-newline def dessine(lignes):backslash-newline \"\"\"Affiche les rectangles et les trianglesbackslash-newline N'affiche pas les lignes ! Pour une ligne : utiliser printbackslash-newline \"\"\"backslash-newline for ligne in lignes:backslash-newline print(ligne)backslash-newlinebackslash-newlinedef lignepython-underscorepleine(motif, nbpython-underscorecolonnes):backslash-newline return motif python-star nbpython-underscorecolonnesbackslash-newlinebackslash-newlinedef lignepython-underscorecreuse(motif, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorecolonnes == 1:backslash-newline return motifbackslash-newline else:backslash-newline return motif + \" \" python-star (nbpython-underscorecolonnes - 2) + motifbackslash-newlinebackslash-newlinedef rectanglepython-underscoreplein(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline resultat = []backslash-newline for i in range(nbpython-underscorelignes):backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorecolonnes))backslash-newline return resultatbackslash-newlinebackslash-newlinedef rectanglepython-underscorecreux(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [lignepython-underscorepleine(motif, nbpython-underscorecolonnes)]backslash-newline else:backslash-newline resultat = [lignepython-underscorepleine(motif, nbpython-underscorecolonnes)]backslash-newline for i in range(nbpython-underscorelignes - 2):backslash-newline resultat.append(lignepython-underscorecreuse(motif, nbpython-underscorecolonnes))backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorecolonnes))backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscoreplein(motif, nbpython-underscorelignes):backslash-newline resultat = []backslash-newline for i in range(nbpython-underscorelignes):backslash-newline resultat.append(lignepython-underscorepleine(motif, i + 1))backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscorecreux(motif, nbpython-underscorelignes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [motif]backslash-newline else:backslash-newline resultat = [motif]backslash-newline for i in range(nbpython-underscorelignes - 2):backslash-newline resultat.append(lignepython-underscorecreuse(motif, i + 2))backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorelignes))backslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline A Z","title":"Formes g\u00e9om\u00e9triques ASCII"},{"location":"2-moyen/formes/sujet/#formes-pleines-et-formes-creuses","text":"\ud83c\udfa8 Un rectangle 3\u00d75 plein, motif: # ##### ##### ##### \ud83c\udfa8 Un triangle creux 5\u00d75, motif: Y Y YY Y Y Y Y YYYYY Dans cet exercice, on travaille avec des listes de chaines de caract\u00e8res pour repr\u00e9senter des dessins. Chaque ligne d'un dessin sera une chaine de caract\u00e8res non vide. Un dessin sera une liste non vide de lignes. Lignes et dessins, dans cet exercice ligne_pleine et ligne_creuse sont des fonctions qui renvoient une ligne que l'on peut afficher avec print rectangle et triangle en version creux ou plein sont des fonctions qui renvoient un dessin (une liste de lignes) que l'on peut afficher avec dessine . Compl\u00e9ter le code suivant afin de disposer des fonctions indiqu\u00e9es. On utilisera les fonctions simples dans les fonctions \u00e9labor\u00e9es. Vous n'avez qu'\u00e0 compl\u00e9ter les fonctions ligne , rectangle et triangle dans chacune des deux versions. Le param\u00e8tre motif sera une chaine de caract\u00e8res de longueur 1. D\u00e9commenter bloc par bloc les assertions Le premier bloc d'assertions est actif. Il permet de tester la fonction ligne_pleine . Quand vous avez r\u00e9ussi, vous pouvez d\u00e9commenter le bloc suivant d'assertions. Pour cela, il suffit de d\u00e9placer la ligne \"\"\" sous le bloc. Exemples \ud83d\udc0d Console Python >>> print ( ligne_pleine ( 'M' , 1 )) M >>> print ( ligne_pleine ( '#' , 5 )) ##### >>> print ( ligne_creuse ( 'X' , 5 )) X X >>> print ( ligne_creuse ( 'M' , 1 )) M \ud83d\udc0d Console Python >>> dessine ( rectangle_plein ( 'A' , 3 , 5 )) AAAAA AAAAA AAAAA >>> dessine ( rectangle_creux ( 'O' , 3 , 5 )) OOOOO O O OOOOO >>> dessine ( rectangle_creux ( 'O' , 1 , 5 )) OOOOO \ud83d\udc0d Console Python >>> dessine ( triangle_plein ( 'T' , 5 )) T TT TTT TTTT TTTTT >>> dessine ( triangle_creux ( 'F' , 5 )) F FF F F F F FFFFF >>> dessine ( triangle_creux ( 'K' , 1 )) K Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('P', 7) == \"PPPPPPP\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('P', 7) == \"P P\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('1', 3, 1) == [backslash-newline \"1\",backslash-newline \"1\",backslash-newline \"1\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('8', 3, 8) == [backslash-newline \"88888888\",backslash-newline \"88888888\",backslash-newline \"88888888\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('C', 1, 7) == [\"CCCCCCC\"]backslash-newlineassert rectanglepython-underscorecreux('C', 3, 1) == [backslash-newline \"C\",backslash-newline \"C\",backslash-newline \"C\",backslash-newline]backslash-newlineassert rectanglepython-underscorecreux('C', 4, 6) == [backslash-newline \"CCCCCC\",backslash-newline \"C C\",backslash-newline \"C C\",backslash-newline \"CCCCCC\",backslash-newline]backslash-newlinebackslash-newline Valider 5/5 def dessine(lignes):backslash-newline \"\"\"Affiche les rectangles et les trianglesbackslash-newline N'affiche pas les lignes ! Pour une ligne : utiliser printbackslash-newline \"\"\"backslash-newline for ligne in lignes:backslash-newline print(ligne)backslash-newlinebackslash-newlinedef lignepython-underscorepleine(motif, nbpython-underscorecolonnes):backslash-newline return ...backslash-newlinebackslash-newlinedef lignepython-underscorecreuse(motif, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorecolonnes == 1:backslash-newline return ...backslash-newline else:backslash-newline return motif + \" \" python-star (nbpython-underscorecolonnes - 2) + ...backslash-newlinebackslash-newlinedef rectanglepython-underscoreplein(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline resultat = []backslash-newline for i in range(...):backslash-newline resultat.append(...)backslash-newline return resultatbackslash-newlinebackslash-newlinedef rectanglepython-underscorecreux(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [lignepython-underscorepleine(...)]backslash-newline else:backslash-newline resultat = [...]backslash-newline for i in range(...):backslash-newline resultat.append(...)backslash-newline resultat.append(...)backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscoreplein(motif, nbpython-underscorelignes):backslash-newline ...backslash-newlinebackslash-newlinedef trianglepython-underscorecreux(motif, nbpython-underscorelignes):backslash-newline ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newline# Conseil : d\u00c3\u00a9commenter bloc par bloc les assertionsbackslash-newline\"\"\"backslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline\"\"\"backslash-newlinebackslash-newline def dessine(lignes):backslash-newline \"\"\"Affiche les rectangles et les trianglesbackslash-newline N'affiche pas les lignes ! Pour une ligne : utiliser printbackslash-newline \"\"\"backslash-newline for ligne in lignes:backslash-newline print(ligne)backslash-newlinebackslash-newlinedef lignepython-underscorepleine(motif, nbpython-underscorecolonnes):backslash-newline return motif python-star nbpython-underscorecolonnesbackslash-newlinebackslash-newlinedef lignepython-underscorecreuse(motif, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorecolonnes == 1:backslash-newline return motifbackslash-newline else:backslash-newline return motif + \" \" python-star (nbpython-underscorecolonnes - 2) + motifbackslash-newlinebackslash-newlinedef rectanglepython-underscoreplein(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline resultat = []backslash-newline for i in range(nbpython-underscorelignes):backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorecolonnes))backslash-newline return resultatbackslash-newlinebackslash-newlinedef rectanglepython-underscorecreux(motif, nbpython-underscorelignes, nbpython-underscorecolonnes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [lignepython-underscorepleine(motif, nbpython-underscorecolonnes)]backslash-newline else:backslash-newline resultat = [lignepython-underscorepleine(motif, nbpython-underscorecolonnes)]backslash-newline for i in range(nbpython-underscorelignes - 2):backslash-newline resultat.append(lignepython-underscorecreuse(motif, nbpython-underscorecolonnes))backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorecolonnes))backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscoreplein(motif, nbpython-underscorelignes):backslash-newline resultat = []backslash-newline for i in range(nbpython-underscorelignes):backslash-newline resultat.append(lignepython-underscorepleine(motif, i + 1))backslash-newline return resultatbackslash-newlinebackslash-newlinedef trianglepython-underscorecreux(motif, nbpython-underscorelignes):backslash-newline if nbpython-underscorelignes == 1:backslash-newline return [motif]backslash-newline else:backslash-newline resultat = [motif]backslash-newline for i in range(nbpython-underscorelignes - 2):backslash-newline resultat.append(lignepython-underscorecreuse(motif, i + 2))backslash-newline resultat.append(lignepython-underscorepleine(motif, nbpython-underscorelignes))backslash-newline return resultatbackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert lignepython-underscorepleine('M', 1) == \"M\"backslash-newlineassert lignepython-underscorepleine('#', 5) == \"#####\"backslash-newlinebackslash-newlineassert lignepython-underscorecreuse('Y', 1) == \"Y\"backslash-newlineassert lignepython-underscorecreuse('X', 5) == \"X X\"backslash-newlinebackslash-newlineassert rectanglepython-underscoreplein('B', 1, 5) == [\"BBBBB\"]backslash-newlineassert rectanglepython-underscoreplein('A', 3, 5) == [backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline \"AAAAA\",backslash-newline]backslash-newlinebackslash-newlineassert rectanglepython-underscorecreux('P', 1, 5) == [\"PPPPP\"]backslash-newlineassert rectanglepython-underscorecreux('O', 3, 5) == [backslash-newline \"OOOOO\",backslash-newline \"O O\",backslash-newline \"OOOOO\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscoreplein('S', 1) == [\"S\"]backslash-newlineassert trianglepython-underscoreplein('T', 5) == [backslash-newline \"T\",backslash-newline \"TT\",backslash-newline \"TTT\",backslash-newline \"TTTT\",backslash-newline \"TTTTT\",backslash-newline]backslash-newlinebackslash-newlineassert trianglepython-underscorecreux('G', 1) == [\"G\"]backslash-newlineassert trianglepython-underscorecreux('F', 5) == [backslash-newline \"F\",backslash-newline \"FF\",backslash-newline \"F F\",backslash-newline \"F F\",backslash-newline \"FFFFF\",backslash-newline]backslash-newlinebackslash-newline A Z","title":"Formes pleines et formes creuses"},{"location":"2-moyen/fusion_listes_triees/sujet/","tags":["a_trou","tri"],"text":"Fusion de deux listes tri\u00e9es \u2693\ufe0e La fonction fusion prend deux listes liste_a , liste_b d'entiers tri\u00e9es par ordre croissant et les fusionne en une seule liste tri\u00e9e liste_triee qu'elle renvoie. Pour cet exercice, on n'utilisera ni sort , ni sorted . Compl\u00e9ter le code : \ud83d\udc0d Script Python def fusion ( liste_a , liste_b ): taille_a = len ( liste_a ) taille_b = len ( liste_b ) liste_triee = [] i_a = 0 i_b = 0 while ( i_a < taille_a ) and ( ... ): if liste_a [ i_a ] < liste_b [ i_b ]: liste_triee . append ( ... [ i_a ]) i_a = ... else : liste_triee . append ( liste_b [ ... ]) i_b = ... while i_a < taille_a : liste_triee . append ( ... ) i_a = ... while i_b < taille_b : liste_triee . append ( ... ) ... return liste_triee Exemples \ud83d\udc0d Console Python >>> fusion ([ 1 , 6 , 10 ], [ 0 , 7 , 8 , 9 ]) [0, 1, 6, 7, 8, 9, 10] \ud83d\udc0d Console Python >>> fusion ([ 1 , 6 , 10 ], []) [1, 6, 10] \ud83d\udc0d Console Python >>> fusion ([], [ 0 , 7 , 8 , 9 ]) [0, 7, 8, 9] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineimport randombackslash-newlineexemplepython-underscorea = sorted(random.sample(range(10python-starpython-star9), 100))backslash-newlineexemplepython-underscoreb = sorted(random.sample(range(10python-starpython-star9), 100))backslash-newlineattendu = exemplepython-underscorea + exemplepython-underscorebbackslash-newlineattendu.sort()backslash-newlineresultat = fusion(exemplepython-underscorea[:], exemplepython-underscoreb[:])backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert a == b, \"Erreur dans la fusion de grandes listes\"backslash-newlinebackslash-newlineresultat = fusion(exemplepython-underscorea, [])backslash-newlinefor a, b in zip(resultat, exemplepython-underscorea):backslash-newline assert a == b, \"Erreur dans la fusion quand la seconde est vide\"backslash-newlinebackslash-newlineresultat = fusion([], exemplepython-underscoreb)backslash-newlinefor a, b in zip(resultat, exemplepython-underscoreb):backslash-newline assert a == b, \"Erreur dans la fusion quand la seconde est vide\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def fusion(listepython-underscorea, listepython-underscoreb):backslash-newline taillepython-underscorea = len(listepython-underscorea)backslash-newline taillepython-underscoreb = len(listepython-underscoreb)backslash-newline listepython-underscoretriee = []backslash-newline ipython-underscorea = 0backslash-newline ipython-underscoreb = 0backslash-newline while (ipython-underscorea < taillepython-underscorea) and (...):backslash-newline if listepython-underscorea[ipython-underscorea] < listepython-underscoreb[ipython-underscoreb]:backslash-newline listepython-underscoretriee.append(...[ipython-underscorea])backslash-newline ipython-underscorea = ...backslash-newline else:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[...])backslash-newline ipython-underscoreb = ...backslash-newline while ipython-underscorea < taillepython-underscorea:backslash-newline listepython-underscoretriee.append(...)backslash-newline ipython-underscorea = ...backslash-newline while ipython-underscoreb < taillepython-underscoreb:backslash-newline listepython-underscoretriee.append(...)backslash-newline ...backslash-newline return listepython-underscoretrieebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline def fusion(listepython-underscorea, listepython-underscoreb):backslash-newline taillepython-underscorea = len(listepython-underscorea)backslash-newline taillepython-underscoreb = len(listepython-underscoreb)backslash-newline listepython-underscoretriee = []backslash-newline ipython-underscorea = 0backslash-newline ipython-underscoreb = 0backslash-newline while (ipython-underscorea < taillepython-underscorea) and (ipython-underscoreb < taillepython-underscoreb):backslash-newline if listepython-underscorea[ipython-underscorea] < listepython-underscoreb[ipython-underscoreb]:backslash-newline listepython-underscoretriee.append(listepython-underscorea[ipython-underscorea])backslash-newline ipython-underscorea += 1backslash-newline else:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[ipython-underscoreb])backslash-newline ipython-underscoreb += 1backslash-newline while ipython-underscorea < taillepython-underscorea:backslash-newline listepython-underscoretriee.append(listepython-underscorea[ipython-underscorea])backslash-newline ipython-underscorea += 1backslash-newline while ipython-underscoreb < taillepython-underscoreb:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[ipython-underscoreb])backslash-newline ipython-underscoreb += 1backslash-newline return listepython-underscoretrieebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline A Z","title":"Fusion de listes tri\u00e9es"},{"location":"2-moyen/fusion_listes_triees/sujet/#fusion-de-deux-listes-triees","text":"La fonction fusion prend deux listes liste_a , liste_b d'entiers tri\u00e9es par ordre croissant et les fusionne en une seule liste tri\u00e9e liste_triee qu'elle renvoie. Pour cet exercice, on n'utilisera ni sort , ni sorted . Compl\u00e9ter le code : \ud83d\udc0d Script Python def fusion ( liste_a , liste_b ): taille_a = len ( liste_a ) taille_b = len ( liste_b ) liste_triee = [] i_a = 0 i_b = 0 while ( i_a < taille_a ) and ( ... ): if liste_a [ i_a ] < liste_b [ i_b ]: liste_triee . append ( ... [ i_a ]) i_a = ... else : liste_triee . append ( liste_b [ ... ]) i_b = ... while i_a < taille_a : liste_triee . append ( ... ) i_a = ... while i_b < taille_b : liste_triee . append ( ... ) ... return liste_triee Exemples \ud83d\udc0d Console Python >>> fusion ([ 1 , 6 , 10 ], [ 0 , 7 , 8 , 9 ]) [0, 1, 6, 7, 8, 9, 10] \ud83d\udc0d Console Python >>> fusion ([ 1 , 6 , 10 ], []) [1, 6, 10] \ud83d\udc0d Console Python >>> fusion ([], [ 0 , 7 , 8 , 9 ]) [0, 7, 8, 9] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineimport randombackslash-newlineexemplepython-underscorea = sorted(random.sample(range(10python-starpython-star9), 100))backslash-newlineexemplepython-underscoreb = sorted(random.sample(range(10python-starpython-star9), 100))backslash-newlineattendu = exemplepython-underscorea + exemplepython-underscorebbackslash-newlineattendu.sort()backslash-newlineresultat = fusion(exemplepython-underscorea[:], exemplepython-underscoreb[:])backslash-newlinefor a, b in zip(resultat, attendu):backslash-newline assert a == b, \"Erreur dans la fusion de grandes listes\"backslash-newlinebackslash-newlineresultat = fusion(exemplepython-underscorea, [])backslash-newlinefor a, b in zip(resultat, exemplepython-underscorea):backslash-newline assert a == b, \"Erreur dans la fusion quand la seconde est vide\"backslash-newlinebackslash-newlineresultat = fusion([], exemplepython-underscoreb)backslash-newlinefor a, b in zip(resultat, exemplepython-underscoreb):backslash-newline assert a == b, \"Erreur dans la fusion quand la seconde est vide\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def fusion(listepython-underscorea, listepython-underscoreb):backslash-newline taillepython-underscorea = len(listepython-underscorea)backslash-newline taillepython-underscoreb = len(listepython-underscoreb)backslash-newline listepython-underscoretriee = []backslash-newline ipython-underscorea = 0backslash-newline ipython-underscoreb = 0backslash-newline while (ipython-underscorea < taillepython-underscorea) and (...):backslash-newline if listepython-underscorea[ipython-underscorea] < listepython-underscoreb[ipython-underscoreb]:backslash-newline listepython-underscoretriee.append(...[ipython-underscorea])backslash-newline ipython-underscorea = ...backslash-newline else:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[...])backslash-newline ipython-underscoreb = ...backslash-newline while ipython-underscorea < taillepython-underscorea:backslash-newline listepython-underscoretriee.append(...)backslash-newline ipython-underscorea = ...backslash-newline while ipython-underscoreb < taillepython-underscoreb:backslash-newline listepython-underscoretriee.append(...)backslash-newline ...backslash-newline return listepython-underscoretrieebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline def fusion(listepython-underscorea, listepython-underscoreb):backslash-newline taillepython-underscorea = len(listepython-underscorea)backslash-newline taillepython-underscoreb = len(listepython-underscoreb)backslash-newline listepython-underscoretriee = []backslash-newline ipython-underscorea = 0backslash-newline ipython-underscoreb = 0backslash-newline while (ipython-underscorea < taillepython-underscorea) and (ipython-underscoreb < taillepython-underscoreb):backslash-newline if listepython-underscorea[ipython-underscorea] < listepython-underscoreb[ipython-underscoreb]:backslash-newline listepython-underscoretriee.append(listepython-underscorea[ipython-underscorea])backslash-newline ipython-underscorea += 1backslash-newline else:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[ipython-underscoreb])backslash-newline ipython-underscoreb += 1backslash-newline while ipython-underscorea < taillepython-underscorea:backslash-newline listepython-underscoretriee.append(listepython-underscorea[ipython-underscorea])backslash-newline ipython-underscorea += 1backslash-newline while ipython-underscoreb < taillepython-underscoreb:backslash-newline listepython-underscoretriee.append(listepython-underscoreb[ipython-underscoreb])backslash-newline ipython-underscoreb += 1backslash-newline return listepython-underscoretrieebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert fusion([1, 6, 10], [0, 7, 8, 9]) == [0, 1, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineassert fusion([1, 6, 10], []) == [1, 6, 10]backslash-newlinebackslash-newlineassert fusion([], [0, 7, 8, 9]) == [0, 7, 8, 9]backslash-newlinebackslash-newline A Z","title":"Fusion de deux listes tri\u00e9es"},{"location":"2-moyen/insertion_liste_triee/sujet/","tags":["a_trou","boucle"],"text":"Insertion dans une liste tri\u00e9e \u2693\ufe0e On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et une liste nombres d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans la liste. \ud83d\udc0d Script Python def insere ( a , nombres ): nombres . append ( a ) i = ... while ( a < ... ) and ( i >= 0 ): nombres [ i + 1 ] = ... nombres [ i ] = a i = ... Compl\u00e9ter la fonction insere ci-dessus. Exemples \ud83d\udc0d Console Python >>> exemple_1 = [ 1 , 2 , 4 , 5 ] >>> insere ( 3 , exemple_1 ) >>> exemple_1 [1, 2, 3, 4, 5] \ud83d\udc0d Console Python >>> exemple_2 = [ 1 , 2 , 7 , 12 , 14 , 25 ] >>> insere ( 7 , exemple_2 ) >>> exemple_2 [1, 2, 7, 7, 12, 14, 25] \ud83d\udc0d Console Python >>> exemple_3 = [ 2 , 3 , 4 ] >>> insere ( 1 , exemple_3 ) >>> ex_3 [1, 2, 3, 4] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser","title":"Ins\u00e8re dans liste tri\u00e9e"},{"location":"2-moyen/insertion_liste_triee/sujet/#insertion-dans-une-liste-triee","text":"On consid\u00e8re la fonction insere ci-dessous qui prend en argument un entier a et une liste nombres d'entiers tri\u00e9s par ordre croissant. Cette fonction ins\u00e8re la valeur a dans la liste. \ud83d\udc0d Script Python def insere ( a , nombres ): nombres . append ( a ) i = ... while ( a < ... ) and ( i >= 0 ): nombres [ i + 1 ] = ... nombres [ i ] = a i = ... Compl\u00e9ter la fonction insere ci-dessus. Exemples \ud83d\udc0d Console Python >>> exemple_1 = [ 1 , 2 , 4 , 5 ] >>> insere ( 3 , exemple_1 ) >>> exemple_1 [1, 2, 3, 4, 5] \ud83d\udc0d Console Python >>> exemple_2 = [ 1 , 2 , 7 , 12 , 14 , 25 ] >>> insere ( 7 , exemple_2 ) >>> exemple_2 [1, 2, 7, 7, 12, 14, 25] \ud83d\udc0d Console Python >>> exemple_3 = [ 2 , 3 , 4 ] >>> insere ( 1 , exemple_3 ) >>> ex_3 [1, 2, 3, 4] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser","title":"Insertion dans une liste tri\u00e9e"},{"location":"2-moyen/labyrinthe/sujet/","tags":["grille","graphe","a_trou"],"text":"V\u00e9rification de sortie de labyrinthe \u2693\ufe0e Un labyrinthe rectangulaire d\u00e9limit\u00e9 et entour\u00e9 par des buissons peut \u00eatre sch\u00e9matis\u00e9 par un tableau 2D : une liste de listes d'entiers \u00e9gaux \u00e0 0 ou 1 . Les 1 d\u00e9signent des buissons dans lesquels on s'entrave. Les 0 d\u00e9signent des emplacements libres, o\u00f9 l'on peut circuler vers toute case libre imm\u00e9diatement au Nord, au Sud, \u00e0 l'Est ou \u00e0 l'Ouest. Il y a au moins trois lignes et trois colonnes. La premi\u00e8re et la derni\u00e8re ligne sont remplies de 1 . La premi\u00e8re et la derni\u00e8re colonne sont remplies de 1 . Le d\u00e9part est sur la deuxi\u00e8me ligne, deuxi\u00e8me colonne. Cette case est libre. La sortie est sur l'avant-derni\u00e8re ligne, avant-derni\u00e8re deuxi\u00e8me colonne. Un chemin est d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de lettres parmi \"NSEO\" . Le Nord ( N ), c'est vers le haut du tableau ; \\(-1\\) pour la ligne, m\u00eame colonne. Le Sud ( S ), c'est vers le bas du tableau ; \\(+1\\) pour la ligne, m\u00eame colonne. L'Est ( E ), c'est vers la droite du tableau ; m\u00eame ligne, \\(+1\\) pour la colonne. L'Ouest ( O ), c'est vers la gauche du tableau ; m\u00eame ligne, \\(-1\\) pour la colonne. \u00c9crire une fonction telle que verifie(labyrinthe, chemin) renvoie un bool\u00e9en, la r\u00e9ponse \u00e0 la question \u00ab La description chemin permet-elle d'aller du d\u00e9part \u00e0 la sortie du labyrinthe sans passer deux fois sur la m\u00eame case, ni passer par des buissons ? \u00bb La fonction pourra modifier labyrinthe \u00e0 loisir. Code \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def verifie ( labyrinthe , chemin ): DECALAGE = { 'N' : ( - 1 , 0 ), 'S' : ... } MARQUE_LIBRE = 0 MARQUE_BUISSON = 1 MARQUE_VU = 2 i_entree , j_entree = 1 , 1 i_sortie , j_sortie = ... , ... i , j = i_entree , j_entree for direction in chemin : labyrinthe [ i ][ j ] = MARQUE_VU di , dj = DECALAGE [ ... ] i , j = ... , ... if labyrinthe [ i ][ j ] != ... : return ... return ( i , j ) == ... Exemples \ud83d\udc0d Script Python labyrinthe = [ [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ] chemin_1 = \"EEEEES\" chemin_2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\" import copy labyrinthe_1 = copy . deepcopy ( labyrinthe ) labyrinthe_2 = copy . deepcopy ( labyrinthe ) assert not verifie ( labyrinthe_1 , chemin_1 ) assert verifie ( labyrinthe_2 , chemin_2 ) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline# autres testsbackslash-newlineimport copybackslash-newlinebackslash-newline# test minimalistebackslash-newlinebackslash-newlinelab2 = [backslash-newline [1, 1, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newlineassert verifie(lab2, \"\")backslash-newlinebackslash-newlineassert not verifie(lab2, \"N\")backslash-newlineassert not verifie(lab2, \"S\")backslash-newlineassert not verifie(lab2, \"E\")backslash-newlineassert not verifie(lab2, \"O\")backslash-newlinebackslash-newlinebackslash-newline# test 4\u00c3\u20143backslash-newlinebackslash-newlinelab3 = [backslash-newline [1, 1, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert verifie(lab, \"S\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"SNS\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"N\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"E\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"O\")backslash-newlinebackslash-newlinebackslash-newline# test 3\u00c3\u20144backslash-newlinebackslash-newlinelab3 = [backslash-newline [1, 1, 1, 1],backslash-newline [1, 0, 0, 1],backslash-newline [1, 1, 1, 1],backslash-newline]backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert verifie(lab, \"E\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"EOE\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"N\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"S\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"O\")backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def verifie(labyrinthe, chemin):backslash-newline DECALAGE = {'N': (-1, 0), 'S': ...}backslash-newline MARQUEpython-underscoreLIBRE = 0backslash-newline MARQUEpython-underscoreBUISSON = 1backslash-newline MARQUEpython-underscoreVU = 2backslash-newline backslash-newline ipython-underscoreentree, jpython-underscoreentree = 1, 1backslash-newline ipython-underscoresortie, jpython-underscoresortie = ..., ...backslash-newlinebackslash-newline i, j = ipython-underscoreentree, jpython-underscoreentreebackslash-newline for direction in chemin:backslash-newline labyrinthe[i][j] = MARQUEpython-underscoreVUbackslash-newline di, dj = DECALAGE[...]backslash-newline i, j = ..., ...backslash-newline if labyrinthe[i][j] != ...:backslash-newline return ...backslash-newline return (i, j) == ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline def verifie(labyrinthe, chemin):backslash-newline DECALAGE = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'O': (0, -1)}backslash-newline MARQUEpython-underscoreLIBRE = 0backslash-newline MARQUEpython-underscoreBUISSON = 1backslash-newline MARQUEpython-underscoreVU = 2backslash-newlinebackslash-newline ipython-underscoreentree, jpython-underscoreentree = 1, 1backslash-newline ipython-underscoresortie, jpython-underscoresortie = len(labyrinthe) - 2, len(labyrinthe[0]) - 2backslash-newlinebackslash-newline i, j = ipython-underscoreentree, jpython-underscoreentreebackslash-newline for direction in chemin:backslash-newline labyrinthe[i][j] = MARQUEpython-underscoreVUbackslash-newline di, dj = DECALAGE[direction]backslash-newline i, j = i + di, j + djbackslash-newline if labyrinthe[i][j] != MARQUEpython-underscoreLIBRE:backslash-newline return Falsebackslash-newline return (i, j) == (ipython-underscoresortie, jpython-underscoresortie)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline A Z","title":"Sortie de labyrinthe"},{"location":"2-moyen/labyrinthe/sujet/#verification-de-sortie-de-labyrinthe","text":"Un labyrinthe rectangulaire d\u00e9limit\u00e9 et entour\u00e9 par des buissons peut \u00eatre sch\u00e9matis\u00e9 par un tableau 2D : une liste de listes d'entiers \u00e9gaux \u00e0 0 ou 1 . Les 1 d\u00e9signent des buissons dans lesquels on s'entrave. Les 0 d\u00e9signent des emplacements libres, o\u00f9 l'on peut circuler vers toute case libre imm\u00e9diatement au Nord, au Sud, \u00e0 l'Est ou \u00e0 l'Ouest. Il y a au moins trois lignes et trois colonnes. La premi\u00e8re et la derni\u00e8re ligne sont remplies de 1 . La premi\u00e8re et la derni\u00e8re colonne sont remplies de 1 . Le d\u00e9part est sur la deuxi\u00e8me ligne, deuxi\u00e8me colonne. Cette case est libre. La sortie est sur l'avant-derni\u00e8re ligne, avant-derni\u00e8re deuxi\u00e8me colonne. Un chemin est d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de lettres parmi \"NSEO\" . Le Nord ( N ), c'est vers le haut du tableau ; \\(-1\\) pour la ligne, m\u00eame colonne. Le Sud ( S ), c'est vers le bas du tableau ; \\(+1\\) pour la ligne, m\u00eame colonne. L'Est ( E ), c'est vers la droite du tableau ; m\u00eame ligne, \\(+1\\) pour la colonne. L'Ouest ( O ), c'est vers la gauche du tableau ; m\u00eame ligne, \\(-1\\) pour la colonne. \u00c9crire une fonction telle que verifie(labyrinthe, chemin) renvoie un bool\u00e9en, la r\u00e9ponse \u00e0 la question \u00ab La description chemin permet-elle d'aller du d\u00e9part \u00e0 la sortie du labyrinthe sans passer deux fois sur la m\u00eame case, ni passer par des buissons ? \u00bb La fonction pourra modifier labyrinthe \u00e0 loisir. Code \u00e0 compl\u00e9ter : \ud83d\udc0d Script Python def verifie ( labyrinthe , chemin ): DECALAGE = { 'N' : ( - 1 , 0 ), 'S' : ... } MARQUE_LIBRE = 0 MARQUE_BUISSON = 1 MARQUE_VU = 2 i_entree , j_entree = 1 , 1 i_sortie , j_sortie = ... , ... i , j = i_entree , j_entree for direction in chemin : labyrinthe [ i ][ j ] = MARQUE_VU di , dj = DECALAGE [ ... ] i , j = ... , ... if labyrinthe [ i ][ j ] != ... : return ... return ( i , j ) == ... Exemples \ud83d\udc0d Script Python labyrinthe = [ [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ], [ 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 0 , 0 , 1 , 0 , 1 , 1 , 1 ], [ 1 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 0 , 1 ], [ 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ] chemin_1 = \"EEEEES\" chemin_2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\" import copy labyrinthe_1 = copy . deepcopy ( labyrinthe ) labyrinthe_2 = copy . deepcopy ( labyrinthe ) assert not verifie ( labyrinthe_1 , chemin_1 ) assert verifie ( labyrinthe_2 , chemin_2 ) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline# autres testsbackslash-newlineimport copybackslash-newlinebackslash-newline# test minimalistebackslash-newlinebackslash-newlinelab2 = [backslash-newline [1, 1, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newlineassert verifie(lab2, \"\")backslash-newlinebackslash-newlineassert not verifie(lab2, \"N\")backslash-newlineassert not verifie(lab2, \"S\")backslash-newlineassert not verifie(lab2, \"E\")backslash-newlineassert not verifie(lab2, \"O\")backslash-newlinebackslash-newlinebackslash-newline# test 4\u00c3\u20143backslash-newlinebackslash-newlinelab3 = [backslash-newline [1, 1, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert verifie(lab, \"S\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"SNS\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"N\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"E\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"O\")backslash-newlinebackslash-newlinebackslash-newline# test 3\u00c3\u20144backslash-newlinebackslash-newlinelab3 = [backslash-newline [1, 1, 1, 1],backslash-newline [1, 0, 0, 1],backslash-newline [1, 1, 1, 1],backslash-newline]backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert verifie(lab, \"E\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"EOE\")backslash-newlinebackslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"N\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"S\")backslash-newlinelab = copy.deepcopy(lab3)backslash-newlineassert not verifie(lab, \"O\")backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def verifie(labyrinthe, chemin):backslash-newline DECALAGE = {'N': (-1, 0), 'S': ...}backslash-newline MARQUEpython-underscoreLIBRE = 0backslash-newline MARQUEpython-underscoreBUISSON = 1backslash-newline MARQUEpython-underscoreVU = 2backslash-newline backslash-newline ipython-underscoreentree, jpython-underscoreentree = 1, 1backslash-newline ipython-underscoresortie, jpython-underscoresortie = ..., ...backslash-newlinebackslash-newline i, j = ipython-underscoreentree, jpython-underscoreentreebackslash-newline for direction in chemin:backslash-newline labyrinthe[i][j] = MARQUEpython-underscoreVUbackslash-newline di, dj = DECALAGE[...]backslash-newline i, j = ..., ...backslash-newline if labyrinthe[i][j] != ...:backslash-newline return ...backslash-newline return (i, j) == ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline def verifie(labyrinthe, chemin):backslash-newline DECALAGE = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'O': (0, -1)}backslash-newline MARQUEpython-underscoreLIBRE = 0backslash-newline MARQUEpython-underscoreBUISSON = 1backslash-newline MARQUEpython-underscoreVU = 2backslash-newlinebackslash-newline ipython-underscoreentree, jpython-underscoreentree = 1, 1backslash-newline ipython-underscoresortie, jpython-underscoresortie = len(labyrinthe) - 2, len(labyrinthe[0]) - 2backslash-newlinebackslash-newline i, j = ipython-underscoreentree, jpython-underscoreentreebackslash-newline for direction in chemin:backslash-newline labyrinthe[i][j] = MARQUEpython-underscoreVUbackslash-newline di, dj = DECALAGE[direction]backslash-newline i, j = i + di, j + djbackslash-newline if labyrinthe[i][j] != MARQUEpython-underscoreLIBRE:backslash-newline return Falsebackslash-newline return (i, j) == (ipython-underscoresortie, jpython-underscoresortie)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinelabyrinthe = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1],backslash-newline [1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1],backslash-newline [1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinecheminpython-underscore1 = \"EEEEES\"backslash-newlinecheminpython-underscore2 = \"SSSSSEENNNEEEEEEESSOOOOSSSEEEESS\"backslash-newlinebackslash-newlineimport copybackslash-newlinelabyrinthepython-underscore1 = copy.deepcopy(labyrinthe)backslash-newlinelabyrinthepython-underscore2 = copy.deepcopy(labyrinthe)backslash-newlinebackslash-newlineassert not verifie(labyrinthepython-underscore1, cheminpython-underscore1)backslash-newlineassert verifie(labyrinthepython-underscore2, cheminpython-underscore2)backslash-newlinebackslash-newline A Z","title":"V\u00e9rification de sortie de labyrinthe"},{"location":"2-moyen/nb_catalan_1/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python catalan_mem = [ 1 ] Pour un appel de catalan(n) deux cas peuvent se produire. n est plus petit que la longueur de la liste, alors le r\u00e9sultat est d\u00e9j\u00e0 stock\u00e9, il suffit de renvoyer catalan_mem[n] . n est sup\u00e9rieur ou \u00e9gal \u00e0 la longueur de la liste. On va alors faire grandir cette liste en utilisant la formule de r\u00e9currence, tant que n\u00e9cessaire. On se retrouve alors dans le cas 1. Preuve de la formule \u2693\ufe0e \\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Nous montrons ici une partie seulement de la preuve. La suite sera dans un autre exercice. Nous partirons du fait (admis) que \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Pour \\(n = 0\\) , on a bien \\(C_0 = \\dfrac{0!}{1!0!} = \\dfrac11=1\\) Pour \\(n>0\\) , on a \\(C_{n-1} = \\dfrac{(2n-2)!}{(n-1)!n!}\\) , de sorte que \\(C_{n-1} \u00d7 \\dfrac{(2n)\u00d7(2n-1)}{n(n+1)} = \\dfrac{(2n)!}{(n+1)!n!} = C_n\\) \\(C_{n-1} \u00d7 \\dfrac{2\u00d7(2n-1)}{n+1} = C_n\\) Pour la formule : \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Un autre exercice sera consacr\u00e9 \u00e0 cela.","title":"Commentaires"},{"location":"2-moyen/nb_catalan_1/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python catalan_mem = [ 1 ] Pour un appel de catalan(n) deux cas peuvent se produire. n est plus petit que la longueur de la liste, alors le r\u00e9sultat est d\u00e9j\u00e0 stock\u00e9, il suffit de renvoyer catalan_mem[n] . n est sup\u00e9rieur ou \u00e9gal \u00e0 la longueur de la liste. On va alors faire grandir cette liste en utilisant la formule de r\u00e9currence, tant que n\u00e9cessaire. On se retrouve alors dans le cas 1.","title":"Commentaires"},{"location":"2-moyen/nb_catalan_1/exo_REM/#preuve-de-la-formule","text":"\\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Nous montrons ici une partie seulement de la preuve. La suite sera dans un autre exercice. Nous partirons du fait (admis) que \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Pour \\(n = 0\\) , on a bien \\(C_0 = \\dfrac{0!}{1!0!} = \\dfrac11=1\\) Pour \\(n>0\\) , on a \\(C_{n-1} = \\dfrac{(2n-2)!}{(n-1)!n!}\\) , de sorte que \\(C_{n-1} \u00d7 \\dfrac{(2n)\u00d7(2n-1)}{n(n+1)} = \\dfrac{(2n)!}{(n+1)!n!} = C_n\\) \\(C_{n-1} \u00d7 \\dfrac{2\u00d7(2n-1)}{n+1} = C_n\\) Pour la formule : \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Un autre exercice sera consacr\u00e9 \u00e0 cela.","title":"Preuve de la formule"},{"location":"2-moyen/nb_catalan_1/sujet/","tags":["maths","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des expressions bien parenth\u00e9s\u00e9es \u2693\ufe0e Expression bien parenth\u00e9s\u00e9e Une expression bien parenth\u00e9s\u00e9e est une chaine de caract\u00e8res compos\u00e9e d'autant de ( que de ) et o\u00f9 chaque parenth\u00e8se ouvrante est plac\u00e9e avant la fermante qui lui correspond. ()(()) et ((()))() sont bien parenth\u00e9s\u00e9es )()( et ())(() ne sont pas bien parenth\u00e9s\u00e9es. Pour \\(2\\) paires de parenth\u00e8ses, il y a \\(2\\) expressions bien parenth\u00e9s\u00e9es. ()() (()) Pour \\(3\\) paires de parenth\u00e8ses, il y a \\(5\\) expressions bien parenth\u00e9s\u00e9es. ()()() (())() ()(()) (()()) ((())) On admettra que le nombres d'expressions bien parenth\u00e9s\u00e9es contenant \\(n\\) paires de parenth\u00e8ses est le nombre de Catalan \\(C_n\\) que l'on peut calculer, par exemple, avec la formule suivante : \\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Objectif : \u00c9crire une fonction telle que catalan(n) renvoie le nombre de Catalan d'indice n . On utilisera la liste catalan_mem pour conserver en m\u00e9moire les r\u00e9sultats, ce qui permet un acc\u00e8s ult\u00e9rieur sans calcul. On utilisera la variable catalan_i pour d\u00e9signer \\(C_i\\) et catalan_im1 pour d\u00e9signer \\(C_{i-1}\\) . On sera capable de justifier \u00e0 l'oral le commentaire plac\u00e9 dans le code. On compl\u00e8tera le code : \ud83d\udc0d Script Python catalan_mem = [ 1 ] def catalan ( n ): i = len ( catalan_mem ) while n >= i : catalan_im1 = ... catalan_i = ... // ( i + 1 ) catalan_mem . append ( ... ) i = ... # ici n < len(catalan_mem) return ... Exemples \ud83d\udc0d Console Python >>> catalan ( 2 ) 2 >>> catalan ( 3 ) 5 >>> catalan ( 5 ) 42 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newline# autres testbackslash-newlinebackslash-newlineA000108 = [backslash-newline 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,backslash-newline 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700,backslash-newline 1767263190, 6564120420, 24466267020, 91482563640, 343059613650,backslash-newline 1289904147324, 4861946401452, 18367353072152, 69533550916004,backslash-newline 263747951750360, 1002242216651368, 3814986502092304,backslash-newline]backslash-newlinebackslash-newlinefor i, resultat in enumerate(A000108):backslash-newline assert catalan(i) == resultat, f\"Erreur avec i = {i}\"backslash-newlinebackslash-newline Valider 5/5 catalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef catalan(n):backslash-newline i = len(catalanpython-underscoremem)backslash-newline while n >= i:backslash-newline catalanpython-underscoreim1 = ...backslash-newline catalanpython-underscorei = ... // (i + 1)backslash-newline catalanpython-underscoremem.append(...)backslash-newline i = ...backslash-newline # ici n < len(catalanpython-underscoremem)backslash-newline return ...backslash-newlinebackslash-newline# testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newlinebackslash-newline catalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef catalan(n):backslash-newline i = len(catalanpython-underscoremem)backslash-newline while n >= i:backslash-newline catalanpython-underscoreim1 = catalanpython-underscoremem[i - 1]backslash-newline catalanpython-underscorei = catalanpython-underscoreim1 python-star 2 python-star (2python-stari - 1) // (i + 1)backslash-newline catalanpython-underscoremem.append(catalanpython-underscorei)backslash-newline i += 1backslash-newline # ici n < len(catalanpython-underscoremem)backslash-newline return catalanpython-underscoremem[n]backslash-newlinebackslash-newline# testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} Pour un appel de catalan(n) deux cas peuvent se produire. n est plus petit que la longueur de la liste, alors le r\u00e9sultat est d\u00e9j\u00e0 stock\u00e9, il suffit de renvoyer catalan_mem[n] . n est sup\u00e9rieur ou \u00e9gal \u00e0 la longueur de la liste. On va alors faire grandir cette liste en utilisant la formule de r\u00e9currence, tant que n\u00e9cessaire. On se retrouve alors dans le cas 1. Preuve de la formule \u2693\ufe0e \\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Nous montrons ici une partie seulement de la preuve. La suite sera dans un autre exercice. Nous partirons du fait (admis) que \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Pour \\(n = 0\\) , on a bien \\(C_0 = \\dfrac{0!}{1!0!} = \\dfrac11=1\\) Pour \\(n>0\\) , on a \\(C_{n-1} = \\dfrac{(2n-2)!}{(n-1)!n!}\\) , de sorte que \\(C_{n-1} \u00d7 \\dfrac{(2n)\u00d7(2n-1)}{n(n+1)} = \\dfrac{(2n)!}{(n+1)!n!} = C_n\\) \\(C_{n-1} \u00d7 \\dfrac{2\u00d7(2n-1)}{n+1} = C_n\\) Pour la formule : \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Un autre exercice sera consacr\u00e9 \u00e0 cela. Z","title":"Nombres de Catalan I"},{"location":"2-moyen/nb_catalan_1/sujet/#enumeration-des-expressions-bien-parenthesees","text":"Expression bien parenth\u00e9s\u00e9e Une expression bien parenth\u00e9s\u00e9e est une chaine de caract\u00e8res compos\u00e9e d'autant de ( que de ) et o\u00f9 chaque parenth\u00e8se ouvrante est plac\u00e9e avant la fermante qui lui correspond. ()(()) et ((()))() sont bien parenth\u00e9s\u00e9es )()( et ())(() ne sont pas bien parenth\u00e9s\u00e9es. Pour \\(2\\) paires de parenth\u00e8ses, il y a \\(2\\) expressions bien parenth\u00e9s\u00e9es. ()() (()) Pour \\(3\\) paires de parenth\u00e8ses, il y a \\(5\\) expressions bien parenth\u00e9s\u00e9es. ()()() (())() ()(()) (()()) ((())) On admettra que le nombres d'expressions bien parenth\u00e9s\u00e9es contenant \\(n\\) paires de parenth\u00e8ses est le nombre de Catalan \\(C_n\\) que l'on peut calculer, par exemple, avec la formule suivante : \\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Objectif : \u00c9crire une fonction telle que catalan(n) renvoie le nombre de Catalan d'indice n . On utilisera la liste catalan_mem pour conserver en m\u00e9moire les r\u00e9sultats, ce qui permet un acc\u00e8s ult\u00e9rieur sans calcul. On utilisera la variable catalan_i pour d\u00e9signer \\(C_i\\) et catalan_im1 pour d\u00e9signer \\(C_{i-1}\\) . On sera capable de justifier \u00e0 l'oral le commentaire plac\u00e9 dans le code. On compl\u00e8tera le code : \ud83d\udc0d Script Python catalan_mem = [ 1 ] def catalan ( n ): i = len ( catalan_mem ) while n >= i : catalan_im1 = ... catalan_i = ... // ( i + 1 ) catalan_mem . append ( ... ) i = ... # ici n < len(catalan_mem) return ... Exemples \ud83d\udc0d Console Python >>> catalan ( 2 ) 2 >>> catalan ( 3 ) 5 >>> catalan ( 5 ) 42 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newline# autres testbackslash-newlinebackslash-newlineA000108 = [backslash-newline 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,backslash-newline 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700,backslash-newline 1767263190, 6564120420, 24466267020, 91482563640, 343059613650,backslash-newline 1289904147324, 4861946401452, 18367353072152, 69533550916004,backslash-newline 263747951750360, 1002242216651368, 3814986502092304,backslash-newline]backslash-newlinebackslash-newlinefor i, resultat in enumerate(A000108):backslash-newline assert catalan(i) == resultat, f\"Erreur avec i = {i}\"backslash-newlinebackslash-newline Valider 5/5 catalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef catalan(n):backslash-newline i = len(catalanpython-underscoremem)backslash-newline while n >= i:backslash-newline catalanpython-underscoreim1 = ...backslash-newline catalanpython-underscorei = ... // (i + 1)backslash-newline catalanpython-underscoremem.append(...)backslash-newline i = ...backslash-newline # ici n < len(catalanpython-underscoremem)backslash-newline return ...backslash-newlinebackslash-newline# testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newlinebackslash-newline catalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef catalan(n):backslash-newline i = len(catalanpython-underscoremem)backslash-newline while n >= i:backslash-newline catalanpython-underscoreim1 = catalanpython-underscoremem[i - 1]backslash-newline catalanpython-underscorei = catalanpython-underscoreim1 python-star 2 python-star (2python-stari - 1) // (i + 1)backslash-newline catalanpython-underscoremem.append(catalanpython-underscorei)backslash-newline i += 1backslash-newline # ici n < len(catalanpython-underscoremem)backslash-newline return catalanpython-underscoremem[n]backslash-newlinebackslash-newline# testsbackslash-newlineassert catalan(2) == 2backslash-newlineassert catalan(3) == 5backslash-newlineassert catalan(5) == 42backslash-newlinebackslash-newlinebackslash-newline A","title":"\u00c9num\u00e9ration des expressions bien parenth\u00e9s\u00e9es"},{"location":"2-moyen/nb_catalan_1/sujet/#commentaires","text":"{{ py('exo_corr') }} Pour un appel de catalan(n) deux cas peuvent se produire. n est plus petit que la longueur de la liste, alors le r\u00e9sultat est d\u00e9j\u00e0 stock\u00e9, il suffit de renvoyer catalan_mem[n] . n est sup\u00e9rieur ou \u00e9gal \u00e0 la longueur de la liste. On va alors faire grandir cette liste en utilisant la formule de r\u00e9currence, tant que n\u00e9cessaire. On se retrouve alors dans le cas 1.","title":"Commentaires"},{"location":"2-moyen/nb_catalan_1/sujet/#preuve-de-la-formule","text":"\\[C_n = \\begin{cases} 1 & \\quad \\text{ si } n = 0\\\\ C_{n-1}\u00d7\\dfrac{2(2n - 1)}{n + 1} & \\quad \\text{ si } n > 0\\\\ \\end{cases}\\] Nous montrons ici une partie seulement de la preuve. La suite sera dans un autre exercice. Nous partirons du fait (admis) que \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Pour \\(n = 0\\) , on a bien \\(C_0 = \\dfrac{0!}{1!0!} = \\dfrac11=1\\) Pour \\(n>0\\) , on a \\(C_{n-1} = \\dfrac{(2n-2)!}{(n-1)!n!}\\) , de sorte que \\(C_{n-1} \u00d7 \\dfrac{(2n)\u00d7(2n-1)}{n(n+1)} = \\dfrac{(2n)!}{(n+1)!n!} = C_n\\) \\(C_{n-1} \u00d7 \\dfrac{2\u00d7(2n-1)}{n+1} = C_n\\) Pour la formule : \\(C_n = \\dfrac{(2n)!}{(n+1)!n!}\\) pour \\(n\\geqslant 0\\) . Un autre exercice sera consacr\u00e9 \u00e0 cela. Z","title":"Preuve de la formule"},{"location":"2-moyen/nb_factoriel/sujet/","tags":["maths","boucle","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des permutations \u2693\ufe0e La factorielle d'un entier naturel \\(n\\) se note \\(n!\\) , c'est le produit des nombres entiers strictement positifs qui sont inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . \\[n! = 1\u00d72\u00d73\u00d74\u00d7...\u00d7n\\] \\(0! = 1\\) , c'est un produit vide, donc \u00e9gal \u00e0 \\(1\\) \\(1! = 1\\) , c'est un produit avec \\(1\\) comme seul facteur. \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(4! = 1\u00d72\u00d73\u00d74 = 24\\) La factorielle joue un r\u00f4le important en alg\u00e8bre combinatoire parce qu'il y a \\(n!\\) fa\u00e7ons diff\u00e9rentes de permuter \\(n\\) objets. Elle apparait dans de nombreuses formules en math\u00e9matiques, comme la formule du bin\u00f4me. Nombre de fa\u00e7ons de placer 10 personnes \u00e0 table Par exemple, la factorielle 10 exprime le nombre de combinaisons possibles de placement des 10 convives autour d'une table (on dit la permutation des convives). Le premier convive s'installe sur l'une des 10 places \u00e0 sa disposition. Chacun de ses 10 placements ouvre 9 nouvelles possibilit\u00e9s pour le deuxi\u00e8me convive, celles-ci 8 pour le troisi\u00e8me, et ainsi de suite. Il y a \\(10! = 3\\,628\\,800\\) fa\u00e7ons de placer 10 personnes \u00e0 table. On souhaite calculer et m\u00e9moriser dans une liste factorielle_mem les nombres factoriels. On propose ici une fonction r\u00e9cursive factorielle dont voici le principe : factorielle_mem est initialis\u00e9 \u00e0 [1] de sorte que \\(0!\\) est \u00e9gal \u00e0 factorielle_mem[0] factorielle(n) fait plusieurs actions : Elle remplit, si n\u00e9cessaire, factorielle_mem avec une boucle. Elle renvoie n! en utilisant factorielle_mem[n] qui sera donc de taille au moins n + 1 \u00e0 la fin de l'appel. On utilisera la variable fact_i pour \\(i!\\) On utilisera la variable fact_im1 pour \\((i-1)!\\) Formule r\u00e9cursive Pour \\(i>0\\) on a \\(i! = (i-1)! \u00d7 i\\) , comme on peut le constater sur les exemples \\(5! = 1\u00d72\u00d73\u00d74\u00d75 = 4! \u00d7 5\\) \\(6! = 1\u00d72\u00d73\u00d74\u00d75\u00d76 = 5! \u00d7 6\\) \\(7! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77 = 6! \u00d7 7\\) Compl\u00e9ter le code : \ud83d\udc0d Script Python factorielle_mem = [ 1 ] def factorielle ( n ): i = len ( factorielle_mem ) while n >= i : fact_im1 = ... fact_i = ... factorielle_mem . append ( ... ) i = ... return ... Exemples \ud83d\udc0d Console Python >>> factorielle ( 5 ) 120 >>> factorielle ( 10 ) 3628800 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinefrom math import factorialbackslash-newlinefor n in [0, 1, 2, 3, 4, 17, 42, 11, 42, 31]:backslash-newline assert factorial(n) == factorielle(n), \"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 factoriellepython-underscoremem = [1]backslash-newlinebackslash-newlinedef factorielle(n):backslash-newline i = len(factoriellepython-underscoremem)backslash-newline while n >= i:backslash-newline factpython-underscoreim1 = ...backslash-newline factpython-underscorei = ...backslash-newline factoriellepython-underscoremem.append(...)backslash-newline i = ...backslash-newline return ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline factoriellepython-underscoremem = [1]backslash-newlinebackslash-newlinedef factorielle(n):backslash-newline i = len(factoriellepython-underscoremem)backslash-newline while n >= i:backslash-newline factpython-underscoreim1 = factoriellepython-underscoremem[i - 1]backslash-newline factpython-underscorei = factpython-underscoreim1 python-star ibackslash-newline factoriellepython-underscoremem.append(factpython-underscorei)backslash-newline i += 1backslash-newline return factoriellepython-underscoremem[n]backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline A Z","title":"Nombre Factoriel"},{"location":"2-moyen/nb_factoriel/sujet/#enumeration-des-permutations","text":"La factorielle d'un entier naturel \\(n\\) se note \\(n!\\) , c'est le produit des nombres entiers strictement positifs qui sont inf\u00e9rieurs ou \u00e9gaux \u00e0 \\(n\\) . \\[n! = 1\u00d72\u00d73\u00d74\u00d7...\u00d7n\\] \\(0! = 1\\) , c'est un produit vide, donc \u00e9gal \u00e0 \\(1\\) \\(1! = 1\\) , c'est un produit avec \\(1\\) comme seul facteur. \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(4! = 1\u00d72\u00d73\u00d74 = 24\\) La factorielle joue un r\u00f4le important en alg\u00e8bre combinatoire parce qu'il y a \\(n!\\) fa\u00e7ons diff\u00e9rentes de permuter \\(n\\) objets. Elle apparait dans de nombreuses formules en math\u00e9matiques, comme la formule du bin\u00f4me. Nombre de fa\u00e7ons de placer 10 personnes \u00e0 table Par exemple, la factorielle 10 exprime le nombre de combinaisons possibles de placement des 10 convives autour d'une table (on dit la permutation des convives). Le premier convive s'installe sur l'une des 10 places \u00e0 sa disposition. Chacun de ses 10 placements ouvre 9 nouvelles possibilit\u00e9s pour le deuxi\u00e8me convive, celles-ci 8 pour le troisi\u00e8me, et ainsi de suite. Il y a \\(10! = 3\\,628\\,800\\) fa\u00e7ons de placer 10 personnes \u00e0 table. On souhaite calculer et m\u00e9moriser dans une liste factorielle_mem les nombres factoriels. On propose ici une fonction r\u00e9cursive factorielle dont voici le principe : factorielle_mem est initialis\u00e9 \u00e0 [1] de sorte que \\(0!\\) est \u00e9gal \u00e0 factorielle_mem[0] factorielle(n) fait plusieurs actions : Elle remplit, si n\u00e9cessaire, factorielle_mem avec une boucle. Elle renvoie n! en utilisant factorielle_mem[n] qui sera donc de taille au moins n + 1 \u00e0 la fin de l'appel. On utilisera la variable fact_i pour \\(i!\\) On utilisera la variable fact_im1 pour \\((i-1)!\\) Formule r\u00e9cursive Pour \\(i>0\\) on a \\(i! = (i-1)! \u00d7 i\\) , comme on peut le constater sur les exemples \\(5! = 1\u00d72\u00d73\u00d74\u00d75 = 4! \u00d7 5\\) \\(6! = 1\u00d72\u00d73\u00d74\u00d75\u00d76 = 5! \u00d7 6\\) \\(7! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77 = 6! \u00d7 7\\) Compl\u00e9ter le code : \ud83d\udc0d Script Python factorielle_mem = [ 1 ] def factorielle ( n ): i = len ( factorielle_mem ) while n >= i : fact_im1 = ... fact_i = ... factorielle_mem . append ( ... ) i = ... return ... Exemples \ud83d\udc0d Console Python >>> factorielle ( 5 ) 120 >>> factorielle ( 10 ) 3628800 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinefrom math import factorialbackslash-newlinefor n in [0, 1, 2, 3, 4, 17, 42, 11, 42, 31]:backslash-newline assert factorial(n) == factorielle(n), \"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 factoriellepython-underscoremem = [1]backslash-newlinebackslash-newlinedef factorielle(n):backslash-newline i = len(factoriellepython-underscoremem)backslash-newline while n >= i:backslash-newline factpython-underscoreim1 = ...backslash-newline factpython-underscorei = ...backslash-newline factoriellepython-underscoremem.append(...)backslash-newline i = ...backslash-newline return ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline factoriellepython-underscoremem = [1]backslash-newlinebackslash-newlinedef factorielle(n):backslash-newline i = len(factoriellepython-underscoremem)backslash-newline while n >= i:backslash-newline factpython-underscoreim1 = factoriellepython-underscoremem[i - 1]backslash-newline factpython-underscorei = factpython-underscoreim1 python-star ibackslash-newline factoriellepython-underscoremem.append(factpython-underscorei)backslash-newline i += 1backslash-newline return factoriellepython-underscoremem[n]backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert factorielle(5) == 120backslash-newlineassert factorielle(10) == 3628800backslash-newlinebackslash-newline A Z","title":"\u00c9num\u00e9ration des permutations"},{"location":"2-moyen/percolation/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python TERRE = 1 VIDE = 0 EAU = 2 def percolation ( sol , i , j , prof_max ): sol [ i ][ j ] = EAU if i == prof_max : return True else : if sol [ i + 1 ][ j ] == VIDE : if percolation ( sol , i + 1 , j , prof_max ): return True if sol [ i ][ j - 1 ] == VIDE : if percolation ( sol , i , j - 1 , prof_max ): return True if sol [ i ][ j + 1 ] == VIDE : if percolation ( sol , i , j + 1 , prof_max ): return True return False On utilise par commodit\u00e9 les variables VIDE et EAU d\u00e9finies. D\u00e8s la premi\u00e8re ligne, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule. Cette action emp\u00eachera de reconsid\u00e9rer des cellules d\u00e9j\u00e0 visit\u00e9es. On teste ensuite le cas de base de la r\u00e9cursivit\u00e9 : la profondeur de la cellule actuelle est-elle \u00e9gale \u00e0 la profondeur vis\u00e9e ? Si oui, on renvoie True . Dans le cas contraire, on explore successivement les trois directions (bas, gauche, droite) : Pour chacune, on v\u00e9rifie tout d'abord que la cellule est vide Si c'est le cas, on teste alors le retour de l'appel percolation(sol, nouveau_i, nouveau_j, prof_max) . S'il vaut True , on renvoie directement True Si aucune des explorations n'a renvoy\u00e9 True , on ne peut pas atteindre la profondeur souhait\u00e9e : on renvoie False","title":"Commentaires"},{"location":"2-moyen/percolation/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python TERRE = 1 VIDE = 0 EAU = 2 def percolation ( sol , i , j , prof_max ): sol [ i ][ j ] = EAU if i == prof_max : return True else : if sol [ i + 1 ][ j ] == VIDE : if percolation ( sol , i + 1 , j , prof_max ): return True if sol [ i ][ j - 1 ] == VIDE : if percolation ( sol , i , j - 1 , prof_max ): return True if sol [ i ][ j + 1 ] == VIDE : if percolation ( sol , i , j + 1 , prof_max ): return True return False On utilise par commodit\u00e9 les variables VIDE et EAU d\u00e9finies. D\u00e8s la premi\u00e8re ligne, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule. Cette action emp\u00eachera de reconsid\u00e9rer des cellules d\u00e9j\u00e0 visit\u00e9es. On teste ensuite le cas de base de la r\u00e9cursivit\u00e9 : la profondeur de la cellule actuelle est-elle \u00e9gale \u00e0 la profondeur vis\u00e9e ? Si oui, on renvoie True . Dans le cas contraire, on explore successivement les trois directions (bas, gauche, droite) : Pour chacune, on v\u00e9rifie tout d'abord que la cellule est vide Si c'est le cas, on teste alors le retour de l'appel percolation(sol, nouveau_i, nouveau_j, prof_max) . S'il vaut True , on renvoie directement True Si aucune des explorations n'a renvoy\u00e9 True , on ne peut pas atteindre la profondeur souhait\u00e9e : on renvoie False","title":"Commentaires"},{"location":"2-moyen/percolation/sujet/","tags":["grille","r\u00e9cursivit\u00e9"],"text":"Percolation \u2693\ufe0e En g\u00e9ologie, la percolation est un \u00e9coulement d'eau \u00e0 travers un sol sous l'effet de la gravit\u00e9. Le sol n'\u00e9tant pas compact, l'eau s'infiltre dans les \"vides\" et p\u00e9n\u00e8tre en profondeur. Pr\u00e9cisons tout de suite que l'on appelle sol , l'ensemble du milieu : la surface sur laquelle nous marchons et l'\u00e9paisseur de terre et de roche sous nos pieds ! On se propose ici de simuler grossi\u00e8rement ce m\u00e9canisme en se demandant si un \u00e9coulement d'eau peut atteindre une certaine profondeur dans un sol . Le sol \u2693\ufe0e Le sol sera repr\u00e9sent\u00e9 en Python par une liste de listes contenant des entiers. Dans cette liste : les 0 repr\u00e9sentent des \"vides\". L'eau peut traverser ces cellules les 1 repr\u00e9sentent de la \"terre\". L'eau ne peut pas traverser ces cellules les 2 repr\u00e9sentent de l'eau On garantit que, mis \u00e0 part une cellule vide sur la premi\u00e8re ligne, tous les bords de la grille sont en \"terre\". On donne ci-dessous un exemple de sol \"sec\" (aucune cellule ne contient la valeur 2 ) : \ud83d\udc0d Console Python >>> sol = [ ... [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], ... [ 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], ... [ 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ], ... [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], ... [ 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 ], ... [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ], ... [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 ], ... [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ... ] Comme on peut le voir, une cellule de la premi\u00e8re ligne est \"vide\" ( sol[0][5] vaut 0 ). L'eau peut donc p\u00e9n\u00e9trer par cet endroit. Comme on le verra dans la suite, l'eau va s'\u00e9couler dans ce sol . On peut r\u00e9cup\u00e9rer un \"sol sec\" (sans aucun 2 dans la grille) en faisant sol = nouveau_sol() . Attention N'oubliez pas d'ex\u00e9cuter le code ci-dessous afin de charger la fonction en m\u00e9moire G\u00e9n\u00e9ration d'un nouveau sol (NE PAS MODIFIER) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def nouveaupython-underscoresol(nom='base'):backslash-newline \"\"\"backslash-newline Renvoie un sol secbackslash-newline Trois sols sont propos\u00c3\u00a9sbackslash-newline Par d\u00c3\u00a9faut on r\u00c3\u00a9cup\u00c3\u00a8re le sol 'base'backslash-newline \"\"\"backslash-newline sols = {'base': [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline ],backslash-newline 'puits': [backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline ],backslash-newline 'diagonale': [backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 0, 0, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 0, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline ]backslash-newlinebackslash-newline }backslash-newline return [ligne.copy() for ligne in sols[nom]]backslash-newlinebackslash-newline L'\u00e9coulement \u2693\ufe0e Lors de l'\u00e9coulement, l'eau peut se d\u00e9placer dans trois directions : vers le bas vers la gauche vers la droite L'animation ci-dessous pr\u00e9sente l'\u00e9coulement dans le sol pr\u00e9c\u00e9dent. Dans ce cas, l'eau peut atteindre les profondeurs 0 \u00e0 5 mais pas la 6 ni la 7 . La fonction \u00e0 \u00e9crire \u2693\ufe0e On \u00e9crira une fonction percolation prenant en argument les coordonn\u00e9es de la cellule de d\u00e9part (ligne i et colonne j ) ainsi qu'une profondeur maximale \u00e0 atteindre. La liste d\u00e9crivant le sol sera d\u00e9clar\u00e9e dans le corps du programme et modifi\u00e9e directement. La fonction renverra True si l'eau atteint cette profondeur, False dans le cas contraire. On utilisera une fonction r\u00e9cursive proc\u00e9dant ainsi : \u00e0 chaque appel, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule (on place un 2 dans la cellule correspondante) on v\u00e9rifie ensuite que la profondeur de la cellule pass\u00e9e en argument est \u00e9gale \u00e0 la profondeur cherch\u00e9e. Si c'est le cas, on renvoie True dans le cas contraire : on v\u00e9rifie que la cellule de dessous est vide. Si oui, on explore cette cellule en appelant \u00e0 nouveau la fonction. Si cette exploration renvoie True , la fonction renvoie True on proc\u00e8de de la m\u00eame fa\u00e7on avec les cellules de gauche et de droite une fois ces trois cas \u00e9tudi\u00e9s, si la fonction ne s'est pas encore termin\u00e9e (aucune des explorations n'a renvoy\u00e9 True ) on renvoie False Attention Dans la mesure o\u00f9 la fonction modifie la liste Python repr\u00e9sentant le sol (en l'inondant avec des valeurs 2 ), il est n\u00e9cessaire de g\u00e9n\u00e9rer un nouveau sol avant chaque test Exemples On g\u00e9n\u00e8re un sol sec gr\u00e2ce \u00e0 la fonction nouveau_sol d\u00e9finie plus haut. Le point de d\u00e9part est en i=0 et j=5 . \ud83d\udc0d Console Python >>> sol = nouveau_sol () >>> # L'eau atteint-elle la profondeur 4 ? >>> percolation ( 0 , 5 , 4 ) True On n'oublie pas d'ass\u00e9cher le sol avant de faire un nouveau test : \ud83d\udc0d Console Python >>> sol = nouveau_sol () >>> # L'eau atteint-elle la profondeur 6 ? >>> percolation ( 0 , 5 , 6 ) False Au travail \u2693\ufe0e Compl\u00e9ter ci-dessous la fonction percolation : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlinefrom copy import deepcopybackslash-newlinebackslash-newlinebasepython-underscoresol = [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinebasepython-underscoresol = [backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 0)backslash-newline# Test profondeur 3 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 4 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 1, 4)backslash-newlinebackslash-newlinebasepython-underscoresol = [backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 0, 0, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 0, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 0)backslash-newline# Test profondeur 3 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 6 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 7 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 1, 7)backslash-newlinebackslash-newline Valider 5/5 TERRE = 1backslash-newlineVIDE = 0backslash-newlineEAU = 2backslash-newlinebackslash-newlinebackslash-newlinedef percolation(sol, i, j, profpython-underscoremax):backslash-newline sol[i][j] = ...backslash-newlinebackslash-newline if ... == ...:backslash-newline return Truebackslash-newline else:backslash-newline if ... == VIDE:backslash-newline if percolation(sol, ..., ..., profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline ...backslash-newlinebackslash-newline ...backslash-newlinebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline TERRE = 1backslash-newlineVIDE = 0backslash-newlineEAU = 2backslash-newlinebackslash-newlinebackslash-newlinedef percolation(sol, i, j, profpython-underscoremax):backslash-newline sol[i][j] = EAUbackslash-newlinebackslash-newline if i == profpython-underscoremax:backslash-newline return Truebackslash-newline else:backslash-newline if sol[i+1][j] == VIDE:backslash-newline if percolation(sol, i+1, j, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline if sol[i][j-1] == VIDE:backslash-newline if percolation(sol, i, j-1, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline if sol[i][j+1] == VIDE:backslash-newline if percolation(sol, i, j+1, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlinebasepython-underscoresol = [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinefrom copy import deepcopybackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr', 0, \"# TESTS\") }} On utilise par commodit\u00e9 les variables VIDE et EAU d\u00e9finies. D\u00e8s la premi\u00e8re ligne, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule. Cette action emp\u00eachera de reconsid\u00e9rer des cellules d\u00e9j\u00e0 visit\u00e9es. On teste ensuite le cas de base de la r\u00e9cursivit\u00e9 : la profondeur de la cellule actuelle est-elle \u00e9gale \u00e0 la profondeur vis\u00e9e ? Si oui, on renvoie True . Dans le cas contraire, on explore successivement les trois directions (bas, gauche, droite) : Pour chacune, on v\u00e9rifie tout d'abord que la cellule est vide Si c'est le cas, on teste alors le retour de l'appel percolation(sol, nouveau_i, nouveau_j, prof_max) . S'il vaut True , on renvoie directement True Si aucune des explorations n'a renvoy\u00e9 True , on ne peut pas atteindre la profondeur souhait\u00e9e : on renvoie False Z Solution","title":"Percolation"},{"location":"2-moyen/percolation/sujet/#percolation","text":"En g\u00e9ologie, la percolation est un \u00e9coulement d'eau \u00e0 travers un sol sous l'effet de la gravit\u00e9. Le sol n'\u00e9tant pas compact, l'eau s'infiltre dans les \"vides\" et p\u00e9n\u00e8tre en profondeur. Pr\u00e9cisons tout de suite que l'on appelle sol , l'ensemble du milieu : la surface sur laquelle nous marchons et l'\u00e9paisseur de terre et de roche sous nos pieds ! On se propose ici de simuler grossi\u00e8rement ce m\u00e9canisme en se demandant si un \u00e9coulement d'eau peut atteindre une certaine profondeur dans un sol .","title":"Percolation"},{"location":"2-moyen/percolation/sujet/#le-sol","text":"Le sol sera repr\u00e9sent\u00e9 en Python par une liste de listes contenant des entiers. Dans cette liste : les 0 repr\u00e9sentent des \"vides\". L'eau peut traverser ces cellules les 1 repr\u00e9sentent de la \"terre\". L'eau ne peut pas traverser ces cellules les 2 repr\u00e9sentent de l'eau On garantit que, mis \u00e0 part une cellule vide sur la premi\u00e8re ligne, tous les bords de la grille sont en \"terre\". On donne ci-dessous un exemple de sol \"sec\" (aucune cellule ne contient la valeur 2 ) : \ud83d\udc0d Console Python >>> sol = [ ... [ 1 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 ], ... [ 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 ], ... [ 1 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 ], ... [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 ], ... [ 1 , 0 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 1 ], ... [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ], ... [ 1 , 1 , 1 , 0 , 0 , 1 , 1 , 1 , 0 , 1 ], ... [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ] ... ] Comme on peut le voir, une cellule de la premi\u00e8re ligne est \"vide\" ( sol[0][5] vaut 0 ). L'eau peut donc p\u00e9n\u00e9trer par cet endroit. Comme on le verra dans la suite, l'eau va s'\u00e9couler dans ce sol . On peut r\u00e9cup\u00e9rer un \"sol sec\" (sans aucun 2 dans la grille) en faisant sol = nouveau_sol() . Attention N'oubliez pas d'ex\u00e9cuter le code ci-dessous afin de charger la fonction en m\u00e9moire G\u00e9n\u00e9ration d'un nouveau sol (NE PAS MODIFIER) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser def nouveaupython-underscoresol(nom='base'):backslash-newline \"\"\"backslash-newline Renvoie un sol secbackslash-newline Trois sols sont propos\u00c3\u00a9sbackslash-newline Par d\u00c3\u00a9faut on r\u00c3\u00a9cup\u00c3\u00a8re le sol 'base'backslash-newline \"\"\"backslash-newline sols = {'base': [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline ],backslash-newline 'puits': [backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline ],backslash-newline 'diagonale': [backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 0, 0, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 0, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline ]backslash-newlinebackslash-newline }backslash-newline return [ligne.copy() for ligne in sols[nom]]backslash-newlinebackslash-newline","title":"Le sol"},{"location":"2-moyen/percolation/sujet/#lecoulement","text":"Lors de l'\u00e9coulement, l'eau peut se d\u00e9placer dans trois directions : vers le bas vers la gauche vers la droite L'animation ci-dessous pr\u00e9sente l'\u00e9coulement dans le sol pr\u00e9c\u00e9dent. Dans ce cas, l'eau peut atteindre les profondeurs 0 \u00e0 5 mais pas la 6 ni la 7 .","title":"L'\u00e9coulement"},{"location":"2-moyen/percolation/sujet/#la-fonction-a-ecrire","text":"On \u00e9crira une fonction percolation prenant en argument les coordonn\u00e9es de la cellule de d\u00e9part (ligne i et colonne j ) ainsi qu'une profondeur maximale \u00e0 atteindre. La liste d\u00e9crivant le sol sera d\u00e9clar\u00e9e dans le corps du programme et modifi\u00e9e directement. La fonction renverra True si l'eau atteint cette profondeur, False dans le cas contraire. On utilisera une fonction r\u00e9cursive proc\u00e9dant ainsi : \u00e0 chaque appel, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule (on place un 2 dans la cellule correspondante) on v\u00e9rifie ensuite que la profondeur de la cellule pass\u00e9e en argument est \u00e9gale \u00e0 la profondeur cherch\u00e9e. Si c'est le cas, on renvoie True dans le cas contraire : on v\u00e9rifie que la cellule de dessous est vide. Si oui, on explore cette cellule en appelant \u00e0 nouveau la fonction. Si cette exploration renvoie True , la fonction renvoie True on proc\u00e8de de la m\u00eame fa\u00e7on avec les cellules de gauche et de droite une fois ces trois cas \u00e9tudi\u00e9s, si la fonction ne s'est pas encore termin\u00e9e (aucune des explorations n'a renvoy\u00e9 True ) on renvoie False Attention Dans la mesure o\u00f9 la fonction modifie la liste Python repr\u00e9sentant le sol (en l'inondant avec des valeurs 2 ), il est n\u00e9cessaire de g\u00e9n\u00e9rer un nouveau sol avant chaque test Exemples On g\u00e9n\u00e8re un sol sec gr\u00e2ce \u00e0 la fonction nouveau_sol d\u00e9finie plus haut. Le point de d\u00e9part est en i=0 et j=5 . \ud83d\udc0d Console Python >>> sol = nouveau_sol () >>> # L'eau atteint-elle la profondeur 4 ? >>> percolation ( 0 , 5 , 4 ) True On n'oublie pas d'ass\u00e9cher le sol avant de faire un nouveau test : \ud83d\udc0d Console Python >>> sol = nouveau_sol () >>> # L'eau atteint-elle la profondeur 6 ? >>> percolation ( 0 , 5 , 6 ) False","title":"La fonction \u00e0 \u00e9crire"},{"location":"2-moyen/percolation/sujet/#au-travail","text":"Compl\u00e9ter ci-dessous la fonction percolation : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlinefrom copy import deepcopybackslash-newlinebackslash-newlinebasepython-underscoresol = [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinebasepython-underscoresol = [backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 0, 1],backslash-newline [1, 1, 1],backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 0)backslash-newline# Test profondeur 3 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 4 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 1, 4)backslash-newlinebackslash-newlinebasepython-underscoresol = [backslash-newline [1, 0, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 0, 0, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 0, 0, 1, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 0, 0, 1, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 0, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 0)backslash-newline# Test profondeur 3 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 6 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 1, 1)backslash-newline# Test profondeur 7 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 1, 7)backslash-newlinebackslash-newline Valider 5/5 TERRE = 1backslash-newlineVIDE = 0backslash-newlineEAU = 2backslash-newlinebackslash-newlinebackslash-newlinedef percolation(sol, i, j, profpython-underscoremax):backslash-newline sol[i][j] = ...backslash-newlinebackslash-newline if ... == ...:backslash-newline return Truebackslash-newline else:backslash-newline if ... == VIDE:backslash-newline if percolation(sol, ..., ..., profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline ...backslash-newlinebackslash-newline ...backslash-newlinebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = nouveaupython-underscoresol()backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline TERRE = 1backslash-newlineVIDE = 0backslash-newlineEAU = 2backslash-newlinebackslash-newlinebackslash-newlinedef percolation(sol, i, j, profpython-underscoremax):backslash-newline sol[i][j] = EAUbackslash-newlinebackslash-newline if i == profpython-underscoremax:backslash-newline return Truebackslash-newline else:backslash-newline if sol[i+1][j] == VIDE:backslash-newline if percolation(sol, i+1, j, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline if sol[i][j-1] == VIDE:backslash-newline if percolation(sol, i, j-1, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline if sol[i][j+1] == VIDE:backslash-newline if percolation(sol, i, j+1, profpython-underscoremax):backslash-newline return Truebackslash-newlinebackslash-newline return Falsebackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlinebasepython-underscoresol = [backslash-newline [1, 1, 1, 1, 1, 0, 1, 1, 1, 1],backslash-newline [1, 1, 0, 1, 0, 0, 0, 0, 0, 1],backslash-newline [1, 1, 0, 1, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 0, 1, 1, 0, 0, 1],backslash-newline [1, 0, 1, 0, 1, 0, 0, 0, 1, 1],backslash-newline [1, 0, 1, 1, 1, 1, 0, 1, 1, 1],backslash-newline [1, 1, 1, 0, 0, 1, 1, 1, 0, 1],backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]backslash-newline]backslash-newlinebackslash-newlinefrom copy import deepcopybackslash-newline# Test profondeur 0 (d\u00c3\u00a9j\u00c3 atteinte)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 0)backslash-newline# Test profondeur 1 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 1)backslash-newline# Test profondeur 5 (atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert percolation(sol, 0, 5, 5)backslash-newline# Test profondeur 6 (non atteignable)backslash-newlinesol = deepcopy(basepython-underscoresol)backslash-newlineassert not percolation(sol, 0, 5, 6)backslash-newlinebackslash-newline A","title":"Au travail"},{"location":"2-moyen/percolation/sujet/#commentaires","text":"{{ py('exo_corr', 0, \"# TESTS\") }} On utilise par commodit\u00e9 les variables VIDE et EAU d\u00e9finies. D\u00e8s la premi\u00e8re ligne, on indique dans le sol que l'eau s'est \u00e9coul\u00e9e jusqu'\u00e0 cette cellule. Cette action emp\u00eachera de reconsid\u00e9rer des cellules d\u00e9j\u00e0 visit\u00e9es. On teste ensuite le cas de base de la r\u00e9cursivit\u00e9 : la profondeur de la cellule actuelle est-elle \u00e9gale \u00e0 la profondeur vis\u00e9e ? Si oui, on renvoie True . Dans le cas contraire, on explore successivement les trois directions (bas, gauche, droite) : Pour chacune, on v\u00e9rifie tout d'abord que la cellule est vide Si c'est le cas, on teste alors le retour de l'appel percolation(sol, nouveau_i, nouveau_j, prof_max) . S'il vaut True , on renvoie directement True Si aucune des explorations n'a renvoy\u00e9 True , on ne peut pas atteindre la profondeur souhait\u00e9e : on renvoie False Z Solution","title":"Commentaires"},{"location":"2-moyen/plus_proche/exo_REM/","text":"Commentaires \u2693\ufe0e Premi\u00e8re version \u2693\ufe0e \ud83d\udc0d Script Python from math import sqrt Variante \u2693\ufe0e Une autre possibilit\u00e9 en initialisant la distance minimale \u00e0 \\(+\\infty\\) et en faisant une boucle sur les \u00e9l\u00e9ments du tableau et non sur les indices. D'autre part, comme ce qui nous int\u00e9resse ici est de comparer les distances, nous pouvons nous contenter de calculer le carr\u00e9 de la distance euclidienne. Nous \u00e9viterons ainsi la manipulation des nombres flottants. \ud83d\udc0d Script Python def distance_carree ( point_1 , point_2 ): \"\"\" Calcule et renvoie le carr\u00e9 de la distance euclidienne entre deux points. \"\"\" # vous pouvez ajouter des lignes de code ici si besoin x1 , y1 = point_1 x2 , y2 = point_2 return (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) def plus_proche ( points , depart ): \"\"\" Renvoie le point du tableau points se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point_proche = None dist_minimale = float ( 'inf' ) for point in points : dist_courante = distance_carree ( point , depart ) if dist_courante < dist_minimale : point_proche = point dist_minimale = dist_courante return point_proche","title":"Commentaires"},{"location":"2-moyen/plus_proche/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/plus_proche/exo_REM/#premiere-version","text":"\ud83d\udc0d Script Python from math import sqrt","title":"Premi\u00e8re version"},{"location":"2-moyen/plus_proche/exo_REM/#variante","text":"Une autre possibilit\u00e9 en initialisant la distance minimale \u00e0 \\(+\\infty\\) et en faisant une boucle sur les \u00e9l\u00e9ments du tableau et non sur les indices. D'autre part, comme ce qui nous int\u00e9resse ici est de comparer les distances, nous pouvons nous contenter de calculer le carr\u00e9 de la distance euclidienne. Nous \u00e9viterons ainsi la manipulation des nombres flottants. \ud83d\udc0d Script Python def distance_carree ( point_1 , point_2 ): \"\"\" Calcule et renvoie le carr\u00e9 de la distance euclidienne entre deux points. \"\"\" # vous pouvez ajouter des lignes de code ici si besoin x1 , y1 = point_1 x2 , y2 = point_2 return (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) def plus_proche ( points , depart ): \"\"\" Renvoie le point du tableau points se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point_proche = None dist_minimale = float ( 'inf' ) for point in points : dist_courante = distance_carree ( point , depart ) if dist_courante < dist_minimale : point_proche = point dist_minimale = dist_courante return point_proche","title":"Variante"},{"location":"2-moyen/plus_proche/sujet/","text":"Nous souhaitons programmer une fonction qui, \u00e9tant donn\u00e9 une liste de points du plan \u00e0 coordonn\u00e9es enti\u00e8res, donne celui qui est le plus proche d'un point de d\u00e9part. Les points sont donn\u00e9s sous la forme d'un tuple de deux entiers. La liste des points \u00e0 traiter est donc un tableau de tuples. La distance utilis\u00e9e est la distance euclidienne, dont on rappelle la d\u00e9finition. La distance euclidienne entre deux points du plan de coordonn\u00e9es \\((x_1;y_1)\\) et \\((x_2;y_2)\\) est donn\u00e9e par la formule : \\[d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}\\] Indication Si la variable point r\u00e9f\u00e9rence notre couple de coordonn\u00e9es, alors le d\u00e9compactage permet de donner un nom simple aux composantes point[0] et point[1] : \ud83d\udc0d Script Python x , y = point Vous pouvez utiliser cette astuce dans votre solution. Nous disposons d'une fonction distance et d'une fonction plus_proche dans l'IDE suivant. Compl\u00e9ter comme il se doit et tester. Exemples \ud83d\udc0d Console Python >>> plus_proche ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 0 , 0 )) (2, 5) >>> plus_proche ([( 7 , 9 ), ( 2 , 5 ), ( 5 , 2 )], ( 7 , 9 )) (7, 9) Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser backslash-newline# testsbackslash-newlinebackslash-newlineassert pluspython-underscoreproche([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5)backslash-newlineassert pluspython-underscoreproche([(7, 9), (2, 5), (5, 2)], (7, 9)) == (7, 9)backslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlinetableaupython-underscore1 = [(10, -8), (-3, -3), (0, 3), (8, -6), (-1, -6), (5, -3), (-4, -7), (6, -9), (7, 3), (2, 5)]backslash-newlinedepartpython-underscore1 = (-8, -7)backslash-newlinedepartpython-underscore2 = (-2, -1)backslash-newlinebackslash-newlineassert pluspython-underscoreproche(tableaupython-underscore1, departpython-underscore1) == (-4, -7)backslash-newlineassert pluspython-underscoreproche(tableaupython-underscore1, departpython-underscore2) == (-3, -3)backslash-newlinebackslash-newlinegros = [(36, -11), (84, 75), (18, 17), (88, 54), (100, 83), (15, 60), (52, 33), (61, -19), (9, 99), (-12, 6), (7, 28), (45, -43), (-87, -71), (66, 53), (-5, 75), (26, -57), (-71, 93), (-57, 9), (-87, -32), (45, -59), (-73, 31), (74, -5), (-66, 45), (-16, -61), (3, 1), (87, -76), (-57, 50), (7, -66), (34, -73), (55, 56), (62, 7), (10, 97), (54, -98), (54, 21), (-95, 41), (74, -56), (3, 85), (-73, -8), (-82, -11), (70, -26), (-82, 7), (-71, -81), (8, -72), (29, 24), (26, 98), (95, -22), (-57, 100), (16, -59), (62, 57), (-35, 51), (-47, 40), (-55, -83), (-23, 34), (17, -67), (15, 27), (45, 34), (42, -93), (-41, 9), (-77, 83), (-3, 75), (-20, -39), (66, 40), (-57, -40), (53, 24), (-36, 1), (5, -99), (56, 38), (-24, 57), (0, 42), (-25, -67), (70, 3), (-99, 75), (-45, -64), (52, 61), (-7, -71), (62, -17), (35, -81), (88, 50), (13, 56), (-47, 78), (-37, 46), (69, -92), (58, -83), (15, 65), (-31, 77), (-50, -46), (-64, -36), (-4, -40), (-59, 24), (-31, 40), (-67, 84), (-75, -73), (-86, 61), (-14, 22), (41, -97), (-97, 15), (60, -20), (15, 12), (-93, -79), (-19, -11)]backslash-newlinedepartpython-underscore3 = (10, 38)backslash-newlinebackslash-newlineassert pluspython-underscoreproche(gros, departpython-underscore3) == (7, 28)backslash-newlinebackslash-newline Valider 5/5 from math import sqrtbackslash-newlinebackslash-newlinedef distance(pointpython-underscore1, pointpython-underscore2):backslash-newline \"\"\" Calcule et renvoie la distance euclidiennebackslash-newline entre deux points. \"\"\"backslash-newline # vous pouvez ajouter des lignes de code ici si besoinbackslash-newline return sqrt(((...)python-starpython-star2 + (...)python-starpython-star2))backslash-newlinebackslash-newlinedef pluspython-underscoreproche(points, depart):backslash-newline \"\"\" Renvoie le point du tableau points se trouvant \u00c3 la plus backslash-newline courte distance du point depart.\"\"\"backslash-newline pointpython-underscoreproche = points[0]backslash-newline distpython-underscoreminimale = ...backslash-newline for i in range(1, ...):backslash-newline point = ...backslash-newline distpython-underscorecourante = ...backslash-newline if distpython-underscorecourante ...:backslash-newline pointpython-underscoreproche = ...backslash-newline distpython-underscoreminimale = ...backslash-newline return pointpython-underscoreprochebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert pluspython-underscoreproche([(7, 9), (2, 5), (5, 2)], (0, 0)) == (2, 5)backslash-newlineassert pluspython-underscoreproche([(7, 9), (2, 5), (5, 2)], (7, 9)) == (7, 9)backslash-newlinebackslash-newline from math import sqrtbackslash-newlinebackslash-newlinedef distance(pointpython-underscore1, pointpython-underscore2):backslash-newline \"\"\" Calcule et renvoie la distance euclidiennebackslash-newline entre deux points. \"\"\"backslash-newline # vous pouvez ajouter des lignes de code ici si besoinbackslash-newline x1, y1 = pointpython-underscore1backslash-newline x2, y2 = pointpython-underscore2backslash-newline return sqrt(((x1 - x2)python-starpython-star2 + (y1 - y2)python-starpython-star2))backslash-newlinebackslash-newlinedef pluspython-underscoreproche(points, depart):backslash-newline \"\"\" Renvoie le point du tableau points se trouvant \u00c3 la plus backslash-newline courte distance du point depart.\"\"\"backslash-newline pointpython-underscoreproche = points[0]backslash-newline distpython-underscoreminimale = distance(pointpython-underscoreproche, depart)backslash-newline for i in range(1, len(points)):backslash-newline point = points[i]backslash-newline distpython-underscorecourante = distance(point, depart)backslash-newline if distpython-underscorecourante < distpython-underscoreminimale:backslash-newline pointpython-underscoreproche = pointbackslash-newline distpython-underscoreminimale = distpython-underscorecourantebackslash-newline return pointpython-underscoreprochebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Premi\u00e8re version \u2693\ufe0e {{ py('exo_corr') }} Variante \u2693\ufe0e Une autre possibilit\u00e9 en initialisant la distance minimale \u00e0 \\(+\\infty\\) et en faisant une boucle sur les \u00e9l\u00e9ments du tableau et non sur les indices. D'autre part, comme ce qui nous int\u00e9resse ici est de comparer les distances, nous pouvons nous contenter de calculer le carr\u00e9 de la distance euclidienne. Nous \u00e9viterons ainsi la manipulation des nombres flottants. \ud83d\udc0d Script Python def distance_carree ( point_1 , point_2 ): \"\"\" Calcule et renvoie le carr\u00e9 de la distance euclidienne entre deux points. \"\"\" # vous pouvez ajouter des lignes de code ici si besoin x1 , y1 = point_1 x2 , y2 = point_2 return (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) def plus_proche ( points , depart ): \"\"\" Renvoie le point du tableau points se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point_proche = None dist_minimale = float ( 'inf' ) for point in points : dist_courante = distance_carree ( point , depart ) if dist_courante < dist_minimale : point_proche = point dist_minimale = dist_courante return point_proche Z","title":"Le plus proche"},{"location":"2-moyen/plus_proche/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/plus_proche/sujet/#premiere-version","text":"{{ py('exo_corr') }}","title":"Premi\u00e8re version"},{"location":"2-moyen/plus_proche/sujet/#variante","text":"Une autre possibilit\u00e9 en initialisant la distance minimale \u00e0 \\(+\\infty\\) et en faisant une boucle sur les \u00e9l\u00e9ments du tableau et non sur les indices. D'autre part, comme ce qui nous int\u00e9resse ici est de comparer les distances, nous pouvons nous contenter de calculer le carr\u00e9 de la distance euclidienne. Nous \u00e9viterons ainsi la manipulation des nombres flottants. \ud83d\udc0d Script Python def distance_carree ( point_1 , point_2 ): \"\"\" Calcule et renvoie le carr\u00e9 de la distance euclidienne entre deux points. \"\"\" # vous pouvez ajouter des lignes de code ici si besoin x1 , y1 = point_1 x2 , y2 = point_2 return (( x1 - x2 ) ** 2 + ( y1 - y2 ) ** 2 ) def plus_proche ( points , depart ): \"\"\" Renvoie le point du tableau points se trouvant \u00e0 la plus courte distance du point depart.\"\"\" point_proche = None dist_minimale = float ( 'inf' ) for point in points : dist_courante = distance_carree ( point , depart ) if dist_courante < dist_minimale : point_proche = point dist_minimale = dist_courante return point_proche Z","title":"Variante"},{"location":"2-moyen/propagation_image/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def propager ( M , i , j , intensite ): if M [ i ][ j ] == intensite : # il n'y a rien \u00c3 faire return Pour ne rien faire, nous aurions pu ins\u00e9rer pass ou un commentaire comme ici. Nous aurions pu aussi prendre la n\u00e9gation de la condition, et ne pas placer de clause else . Il est plus lisible de traiter les cas faciles explicitement d\u00e8s le d\u00e9but, plut\u00f4t que de retarder un dernier cas simple pour la fin. C'est uniquement un choix esth\u00e9tique et p\u00e9dagogique. En revanche, pour un bloc d'actions court, on pr\u00e9f\u00e8re \ud83d\udc0d Script Python if not condition : actions Plut\u00f4t que \ud83d\udc0d Script Python if condition : pass else : actions","title":"Commentaires"},{"location":"2-moyen/propagation_image/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def propager ( M , i , j , intensite ): if M [ i ][ j ] == intensite : # il n'y a rien \u00c3 faire return Pour ne rien faire, nous aurions pu ins\u00e9rer pass ou un commentaire comme ici. Nous aurions pu aussi prendre la n\u00e9gation de la condition, et ne pas placer de clause else . Il est plus lisible de traiter les cas faciles explicitement d\u00e8s le d\u00e9but, plut\u00f4t que de retarder un dernier cas simple pour la fin. C'est uniquement un choix esth\u00e9tique et p\u00e9dagogique. En revanche, pour un bloc d'actions court, on pr\u00e9f\u00e8re \ud83d\udc0d Script Python if not condition : actions Plut\u00f4t que \ud83d\udc0d Script Python if condition : pass else : actions","title":"Commentaires"},{"location":"2-moyen/propagation_image/sujet/","tags":["a_trou","grille","r\u00e9cursivit\u00e9"],"text":"TODO Images \u00e0 refaire !!! Propagation d'intensit\u00e9 sur une image \u2693\ufe0e Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont des nombres entiers. Une composante d'une image est un sous-ensemble de l'image constitu\u00e9 uniquement d'entiers identiques qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement, soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d'un pixel dans une image, donner la valeur intensite \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image pixels , deux entiers i et j et une valeur enti\u00e8re intensite . Elle met \u00e0 la valeur intensite tous les pixels de la composante de M[i][j] . Par exemple, propager(M, i=2, j=1, intensite=3) donne Remarque : si M[i][j] est d\u00e9j\u00e0 \u00e9gal \u00e0 intensite , il n'y a rien \u00e0 faire. Avec Python, on peut utiliser l'instruction pass pour ne rien faire. Compl\u00e9ter le code suivant, en ajoutant aussi des tests : \ud83d\udc0d Script Python def propager ( M , i , j , intensite ): if M [ i ][ j ] == ... : # ... return Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=0, j=0, intensite=5)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [5, 5, 1, 0],backslash-newline [5, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline Valider 5/5 def propager(M, i, j, intensite):backslash-newline if M[i][j] == ...:backslash-newline # ...backslash-newline returnbackslash-newlinebackslash-newline intensitepython-underscoreorigine = ...backslash-newlinebackslash-newline M[i][j] = intensitebackslash-newlinebackslash-newline if (i - 1) >= 0 and M[i - 1][j] == ...:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessus fait partie de la composantebackslash-newline propager(M, i - 1, j, intensite)backslash-newlinebackslash-newline if (...) < len(M) and M[i + 1][j] == 1:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessous fait partie de la composantebackslash-newline propager(M, ..., j, intensite)backslash-newlinebackslash-newline if (...) >= 0 and M[i][j - 1] == 1:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 gauche fait partie de la composantebackslash-newline ...backslash-newlinebackslash-newline if ...:backslash-newline # ...backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline def propager(M, i, j, intensite):backslash-newline if M[i][j] == intensite:backslash-newline # il n'y a rien \u00c3 fairebackslash-newline returnbackslash-newlinebackslash-newline intensitepython-underscoreorigine = M[i][j]backslash-newlinebackslash-newline M[i][j] = intensitebackslash-newlinebackslash-newline if (i - 1) >= 0 and M[i - 1][j] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessus fait partie de la composantebackslash-newline propager(M, i-1, j, intensite)backslash-newlinebackslash-newline if (i + 1) < len(M) and M[i + 1][j] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessous fait partie de la composantebackslash-newline propager(M, i + 1, j, intensite)backslash-newlinebackslash-newline if (j - 1) >= 0 and M[i][j - 1] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 gauche fait partie de la composantebackslash-newline propager(M, i, j - 1, intensite)backslash-newlinebackslash-newline if (j + 1) < len(M) and M[i][j + 1] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 droite fait partie de la composantebackslash-newline propager(M, i, j + 1, intensite)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} Pour ne rien faire, nous aurions pu ins\u00e9rer pass ou un commentaire comme ici. Nous aurions pu aussi prendre la n\u00e9gation de la condition, et ne pas placer de clause else . Il est plus lisible de traiter les cas faciles explicitement d\u00e8s le d\u00e9but, plut\u00f4t que de retarder un dernier cas simple pour la fin. C'est uniquement un choix esth\u00e9tique et p\u00e9dagogique. En revanche, pour un bloc d'actions court, on pr\u00e9f\u00e8re \ud83d\udc0d Script Python if not condition : actions Plut\u00f4t que \ud83d\udc0d Script Python if condition : pass else : actions Z","title":"Propagation sur image"},{"location":"2-moyen/propagation_image/sujet/#propagation-dintensite-sur-une-image","text":"Soit une image binaire repr\u00e9sent\u00e9e dans un tableau \u00e0 2 dimensions. Les \u00e9l\u00e9ments M[i][j] , appel\u00e9s pixels, sont des nombres entiers. Une composante d'une image est un sous-ensemble de l'image constitu\u00e9 uniquement d'entiers identiques qui sont c\u00f4te \u00e0 c\u00f4te, soit horizontalement, soit verticalement. Par exemple, les composantes de sont On souhaite, \u00e0 partir d'un pixel dans une image, donner la valeur intensite \u00e0 tous les pixels de la composante \u00e0 laquelle appartient ce pixel. La fonction propager prend pour param\u00e8tre une image pixels , deux entiers i et j et une valeur enti\u00e8re intensite . Elle met \u00e0 la valeur intensite tous les pixels de la composante de M[i][j] . Par exemple, propager(M, i=2, j=1, intensite=3) donne Remarque : si M[i][j] est d\u00e9j\u00e0 \u00e9gal \u00e0 intensite , il n'y a rien \u00e0 faire. Avec Python, on peut utiliser l'instruction pass pour ne rien faire. Compl\u00e9ter le code suivant, en ajoutant aussi des tests : \ud83d\udc0d Script Python def propager ( M , i , j , intensite ): if M [ i ][ j ] == ... : # ... return Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=0, j=0, intensite=5)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [5, 5, 1, 0],backslash-newline [5, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline Valider 5/5 def propager(M, i, j, intensite):backslash-newline if M[i][j] == ...:backslash-newline # ...backslash-newline returnbackslash-newlinebackslash-newline intensitepython-underscoreorigine = ...backslash-newlinebackslash-newline M[i][j] = intensitebackslash-newlinebackslash-newline if (i - 1) >= 0 and M[i - 1][j] == ...:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessus fait partie de la composantebackslash-newline propager(M, i - 1, j, intensite)backslash-newlinebackslash-newline if (...) < len(M) and M[i + 1][j] == 1:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessous fait partie de la composantebackslash-newline propager(M, ..., j, intensite)backslash-newlinebackslash-newline if (...) >= 0 and M[i][j - 1] == 1:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 gauche fait partie de la composantebackslash-newline ...backslash-newlinebackslash-newline if ...:backslash-newline # ...backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline def propager(M, i, j, intensite):backslash-newline if M[i][j] == intensite:backslash-newline # il n'y a rien \u00c3 fairebackslash-newline returnbackslash-newlinebackslash-newline intensitepython-underscoreorigine = M[i][j]backslash-newlinebackslash-newline M[i][j] = intensitebackslash-newlinebackslash-newline if (i - 1) >= 0 and M[i - 1][j] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessus fait partie de la composantebackslash-newline propager(M, i-1, j, intensite)backslash-newlinebackslash-newline if (i + 1) < len(M) and M[i + 1][j] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment au-dessous fait partie de la composantebackslash-newline propager(M, i + 1, j, intensite)backslash-newlinebackslash-newline if (j - 1) >= 0 and M[i][j - 1] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 gauche fait partie de la composantebackslash-newline propager(M, i, j - 1, intensite)backslash-newlinebackslash-newline if (j + 1) < len(M) and M[i][j + 1] == intensitepython-underscoreorigine:backslash-newline # l'\u00c3\u00a9l\u00c3\u00a9ment \u00c3 droite fait partie de la composantebackslash-newline propager(M, i, j + 1, intensite)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineM = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 1, 0, 1],backslash-newline [1, 1, 1, 0],backslash-newline [0, 1, 1, 0],backslash-newline]backslash-newlinebackslash-newlinepropager(M, i=2, j=1, intensite=3)backslash-newlinebackslash-newlineMpython-underscoreattendu = [backslash-newline [0, 0, 1, 0],backslash-newline [0, 3, 0, 1],backslash-newline [3, 3, 3, 0],backslash-newline [0, 3, 3, 0],backslash-newline]backslash-newlinebackslash-newlineassert M == Mpython-underscoreattendubackslash-newlinebackslash-newline A","title":"Propagation d'intensit\u00e9 sur une image"},{"location":"2-moyen/propagation_image/sujet/#commentaires","text":"{{ py('exo_corr') }} Pour ne rien faire, nous aurions pu ins\u00e9rer pass ou un commentaire comme ici. Nous aurions pu aussi prendre la n\u00e9gation de la condition, et ne pas placer de clause else . Il est plus lisible de traiter les cas faciles explicitement d\u00e8s le d\u00e9but, plut\u00f4t que de retarder un dernier cas simple pour la fin. C'est uniquement un choix esth\u00e9tique et p\u00e9dagogique. En revanche, pour un bloc d'actions court, on pr\u00e9f\u00e8re \ud83d\udc0d Script Python if not condition : actions Plut\u00f4t que \ud83d\udc0d Script Python if condition : pass else : actions Z","title":"Commentaires"},{"location":"2-moyen/recherche_tab_trie/sujet/","tags":["a_trou","r\u00e9cursivit\u00e9","boucle"],"text":"Rechercher un \u00e9l\u00e9ment dans un tableau tri\u00e9 \u2693\ufe0e L'objectif de cet exercice est d'\u00e9crire une fonction indice qui prend en argument : un tableau valeurs d'entiers rang\u00e9s dans l'ordre croissant un entier cible qui renvoie : l'indice de cible dans le tableau s'il en fait partie None sinon La fonction indice utilisera une fonction indice_rec qui sera r\u00e9cursive et qui prendra les m\u00eames arguments que indice , et en plus debut et fin qui d\u00e9signeront les indices pour la recherche : de debut inclus \u00e0 fin inclus . Le tableau valeurs pourra \u00eatre aussi \u00eatre rempli de chaines de caract\u00e8res, sans aucun changement \u00e0 proc\u00e9der. On compl\u00e8tera le code : \ud83d\udc0d Script Python def indice_rec ( valeurs , cible , debut , fin ): if debut > fin : return None milieu = ( debut + fin ) // ... if valeurs [ milieu ] > ... : return indice_rec ( valeurs , cible , ... , ... ) elif ... : return indice_rec ( valeurs , cible , ... , ... ) else : return milieu def indice ( valeurs , cible ): return ... ( valeurs , cible , 0 , len ( valeurs ) - 1 ) Exemples \ud83d\udc0d Console Python >>> nombres = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 ] >>> indice ( nombres , 7 ) 3 >>> indice ( nombres , 8 ) is None True \ud83d\udc0d Console Python >>> fruits = [ \"abricot\" , \"kiwi\" , \"mangue\" , \"poire\" , \"pomme\" ] >>> fruits == sorted ( fruits ) # le tableau est bien tri\u00e9 True >>> indice ( fruits , \"kiwi\" ) 1 >>> indice ( fruits , \"cerise\" ) is None True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinevaleurs = [2python-stari for i in range(8)]backslash-newlinefor i in range(8):backslash-newline cible = 2python-staribackslash-newline attendu = ibackslash-newline assert indice(valeurs, cible) == attendu, f\"Erreur avec {cible} dans {valeurs}\"backslash-newlinefor i in range(9):backslash-newline cible = 2python-stari - 1backslash-newline assert indice(valeurs, cible) is None, f\"Erreur avec {cible} dans {valeurs}\"backslash-newlinebackslash-newlinetxt = [chr(ord('A') + i) for i in range(26)]backslash-newlinefor i in range(26):backslash-newline cible = chr(ord('A') + i)backslash-newline attendu = ibackslash-newline assert indice(txt, cible) == attendu, f\"1.Erreur avec {cible} dans {txt}\"backslash-newline cible = chr(ord('A') + i) + \"!\"backslash-newline assert indice(txt, cible) is None, f\"2.Erreur avec {cible} dans {txt}\"backslash-newline cible = \"!\" + chr(ord('A') + i)backslash-newline assert indice(txt, cible) is None, f\"3.Erreur avec {cible} dans {txt}\"backslash-newlinecible = \"\"backslash-newlineassert indice(txt, cible) is None, f\"4.Erreur avec {cible} dans {txt}\"backslash-newlinebackslash-newline Valider 5/5 def indicepython-underscorerec(valeurs, cible, debut, fin):backslash-newline if debut > fin:backslash-newline return Nonebackslash-newline milieu = (debut + fin) // ...backslash-newline if valeurs[milieu] > ...:backslash-newline return indicepython-underscorerec(valeurs, cible, ..., ...)backslash-newline elif ...:backslash-newline return indicepython-underscorerec(valeurs, cible, ..., ...)backslash-newline else:backslash-newline return milieubackslash-newlinebackslash-newlinedef indice(valeurs, cible):backslash-newline return ...(valeurs, cible, 0, len(valeurs) - 1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newline def indicepython-underscorerec(valeurs, cible, debut, fin):backslash-newline if debut > fin:backslash-newline return Nonebackslash-newline milieu = (debut + fin) // 2backslash-newline if valeurs[milieu] > cible:backslash-newline return indicepython-underscorerec(valeurs, cible, debut, milieu - 1)backslash-newline elif valeurs[milieu] < cible:backslash-newline return indicepython-underscorerec(valeurs, cible, milieu + 1, fin)backslash-newline else:backslash-newline return milieubackslash-newlinebackslash-newlinedef indice(valeurs, cible):backslash-newline return indicepython-underscorerec(valeurs, cible, 0, len(valeurs) - 1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newline A Z","title":"Indice dans un tableau tri\u00e9"},{"location":"2-moyen/recherche_tab_trie/sujet/#rechercher-un-element-dans-un-tableau-trie","text":"L'objectif de cet exercice est d'\u00e9crire une fonction indice qui prend en argument : un tableau valeurs d'entiers rang\u00e9s dans l'ordre croissant un entier cible qui renvoie : l'indice de cible dans le tableau s'il en fait partie None sinon La fonction indice utilisera une fonction indice_rec qui sera r\u00e9cursive et qui prendra les m\u00eames arguments que indice , et en plus debut et fin qui d\u00e9signeront les indices pour la recherche : de debut inclus \u00e0 fin inclus . Le tableau valeurs pourra \u00eatre aussi \u00eatre rempli de chaines de caract\u00e8res, sans aucun changement \u00e0 proc\u00e9der. On compl\u00e8tera le code : \ud83d\udc0d Script Python def indice_rec ( valeurs , cible , debut , fin ): if debut > fin : return None milieu = ( debut + fin ) // ... if valeurs [ milieu ] > ... : return indice_rec ( valeurs , cible , ... , ... ) elif ... : return indice_rec ( valeurs , cible , ... , ... ) else : return milieu def indice ( valeurs , cible ): return ... ( valeurs , cible , 0 , len ( valeurs ) - 1 ) Exemples \ud83d\udc0d Console Python >>> nombres = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 ] >>> indice ( nombres , 7 ) 3 >>> indice ( nombres , 8 ) is None True \ud83d\udc0d Console Python >>> fruits = [ \"abricot\" , \"kiwi\" , \"mangue\" , \"poire\" , \"pomme\" ] >>> fruits == sorted ( fruits ) # le tableau est bien tri\u00e9 True >>> indice ( fruits , \"kiwi\" ) 1 >>> indice ( fruits , \"cerise\" ) is None True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinevaleurs = [2python-stari for i in range(8)]backslash-newlinefor i in range(8):backslash-newline cible = 2python-staribackslash-newline attendu = ibackslash-newline assert indice(valeurs, cible) == attendu, f\"Erreur avec {cible} dans {valeurs}\"backslash-newlinefor i in range(9):backslash-newline cible = 2python-stari - 1backslash-newline assert indice(valeurs, cible) is None, f\"Erreur avec {cible} dans {valeurs}\"backslash-newlinebackslash-newlinetxt = [chr(ord('A') + i) for i in range(26)]backslash-newlinefor i in range(26):backslash-newline cible = chr(ord('A') + i)backslash-newline attendu = ibackslash-newline assert indice(txt, cible) == attendu, f\"1.Erreur avec {cible} dans {txt}\"backslash-newline cible = chr(ord('A') + i) + \"!\"backslash-newline assert indice(txt, cible) is None, f\"2.Erreur avec {cible} dans {txt}\"backslash-newline cible = \"!\" + chr(ord('A') + i)backslash-newline assert indice(txt, cible) is None, f\"3.Erreur avec {cible} dans {txt}\"backslash-newlinecible = \"\"backslash-newlineassert indice(txt, cible) is None, f\"4.Erreur avec {cible} dans {txt}\"backslash-newlinebackslash-newline Valider 5/5 def indicepython-underscorerec(valeurs, cible, debut, fin):backslash-newline if debut > fin:backslash-newline return Nonebackslash-newline milieu = (debut + fin) // ...backslash-newline if valeurs[milieu] > ...:backslash-newline return indicepython-underscorerec(valeurs, cible, ..., ...)backslash-newline elif ...:backslash-newline return indicepython-underscorerec(valeurs, cible, ..., ...)backslash-newline else:backslash-newline return milieubackslash-newlinebackslash-newlinedef indice(valeurs, cible):backslash-newline return ...(valeurs, cible, 0, len(valeurs) - 1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newline def indicepython-underscorerec(valeurs, cible, debut, fin):backslash-newline if debut > fin:backslash-newline return Nonebackslash-newline milieu = (debut + fin) // 2backslash-newline if valeurs[milieu] > cible:backslash-newline return indicepython-underscorerec(valeurs, cible, debut, milieu - 1)backslash-newline elif valeurs[milieu] < cible:backslash-newline return indicepython-underscorerec(valeurs, cible, milieu + 1, fin)backslash-newline else:backslash-newline return milieubackslash-newlinebackslash-newlinedef indice(valeurs, cible):backslash-newline return indicepython-underscorerec(valeurs, cible, 0, len(valeurs) - 1)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newline#1backslash-newlinenombres = [2, 3, 5, 7, 11, 13, 17]backslash-newlineassert indice(nombres, 7) == 3backslash-newlineassert indice(nombres, 8) is Nonebackslash-newlinebackslash-newlinebackslash-newline#2backslash-newlinebackslash-newlinefruits = [\"abricot\", \"kiwi\", \"mangue\", \"poire\", \"pomme\"]backslash-newlineassert fruits == sorted(fruits) # le tableau est bien tri\u00c3\u00a9backslash-newlineassert indice(fruits, \"kiwi\") == 1backslash-newlineassert indice(fruits, \"cerise\") is Nonebackslash-newlinebackslash-newline A Z","title":"Rechercher un \u00e9l\u00e9ment dans un tableau tri\u00e9"},{"location":"2-moyen/redimensionner/exo_REM/","text":"Cet exercice demande de coder une fonction approchant la m\u00e9thode reshape du module numpy . Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def redimensionner ( tab , nouvelle_largeur , nouvelle_hauteur ): nouveau_tab = [[ 0 ] * nouvelle_largeur for _ in range ( nouvelle_hauteur )] numero_ligne , numero_colonne = 0 , - 1 for ligne in tab : for valeur in ligne : numero_colonne += 1 if numero_colonne == nouvelle_largeur : numero_ligne += 1 numero_colonne = 0 nouveau_tab [ numero_ligne ][ numero_colonne ] = valeur return nouveau_tab On commence par cr\u00e9er un nouveau tableau vide aux bonnes dimensions. On parcourt ensuite l'ancien tableau (les lignes puis les valeurs dans chaque ligne) en calculant les coordonn\u00e9es de la cellule correspondante du nouveau tableau. Pour ce faire, \u00e0 chaque nouvelle valeur, on augmente le num\u00e9ro de colonne auquel ins\u00e9rer. Si celui-ci est \u00e9gal \u00e0 la nouvelle largeur, cela signifie que l'on a fini de remplir une colonne du nouveau tableau. Dans ce cas on passe \u00e0 la ligne suivante et on recommence \u00e0 la colonne 0 . A la fin de la fonction, on renvoie le nouveau tableau.","title":"exo REM"},{"location":"2-moyen/redimensionner/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def redimensionner ( tab , nouvelle_largeur , nouvelle_hauteur ): nouveau_tab = [[ 0 ] * nouvelle_largeur for _ in range ( nouvelle_hauteur )] numero_ligne , numero_colonne = 0 , - 1 for ligne in tab : for valeur in ligne : numero_colonne += 1 if numero_colonne == nouvelle_largeur : numero_ligne += 1 numero_colonne = 0 nouveau_tab [ numero_ligne ][ numero_colonne ] = valeur return nouveau_tab On commence par cr\u00e9er un nouveau tableau vide aux bonnes dimensions. On parcourt ensuite l'ancien tableau (les lignes puis les valeurs dans chaque ligne) en calculant les coordonn\u00e9es de la cellule correspondante du nouveau tableau. Pour ce faire, \u00e0 chaque nouvelle valeur, on augmente le num\u00e9ro de colonne auquel ins\u00e9rer. Si celui-ci est \u00e9gal \u00e0 la nouvelle largeur, cela signifie que l'on a fini de remplir une colonne du nouveau tableau. Dans ce cas on passe \u00e0 la ligne suivante et on recommence \u00e0 la colonne 0 . A la fin de la fonction, on renvoie le nouveau tableau.","title":"Commentaires"},{"location":"2-moyen/redimensionner/sujet/","tags":["grille"],"text":"Redimensionner un tableau \u2693\ufe0e Objectif \u2693\ufe0e On consid\u00e8re un tableau de nombres, une matrice dit-on aussi, de dimensions \\(l_1 \\times h_1\\) (largeur \\(l_1\\) et hauteur \\(h_1\\) ) et l'on souhaite modifier ses dimensions afin de cr\u00e9er un tableau de dimensions \\(l_2 \\times h_2\\) . Bien entendu, les deux tableaux contiendront autant de valeurs l'un et l'autre. On garantit donc que l'on aura toujours \\(l_1 \\times h_1 = l_2 \\times h_2\\) . Par exemple, le tableau de dimensions \\(4 \\times 3\\) : \\[ \\begin{array}{|c|c|c|c|} \\hline 1&2&3&4\\\\ \\hline 5&6&7&8\\\\ \\hline 9&10&11&12\\\\ \\hline \\end{array} \\] pourra \u00eatre transform\u00e9 en un nouveau tableau de dimensions \\(6 \\times 2\\) \\[ \\begin{array}{|c|c|c|c|c|c|} \\hline 1&2&3&4&5&6\\\\ \\hline 7&8&9&10&11&12\\\\ \\hline \\end{array} \\] Les tableaux seront repr\u00e9sent\u00e9s par des listes de listes Python. Ainsi les deux tableaux ci-dessus seront repr\u00e9sent\u00e9s par : \ud83d\udc0d Script Python tab1 = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] tab2 = [[ 1 , 2 , 3 , 4 , 5 , 6 ], [ 7 , 8 , 9 , 10 , 11 , 12 ]] D\u00e9marche \u2693\ufe0e Il faut tout d'abord cr\u00e9er un nouveau tableau aux bonnes dimensions. Le code Python ci-dessous permet de cr\u00e9er un tableau de 3 lignes sur 5 colonnes rempli de 0 \ud83d\udc0d Script Python tab_vide = [[ 0 ] * 5 for _ in range ( 3 )] Il va ensuite falloir mettre en correspondance les cellules du premier tableau et celles du second. Pour cela on propose la m\u00e9thode suivante : on cr\u00e9e des coordonn\u00e9es (par exemple num_ligne et num_colonne ). num_ligne est initialis\u00e9e \u00e0 0 , num_colonne \u00e0 -1 on parcourt l'ensemble des lignes et l'ensemble des valeurs du tableau de d\u00e9part A chaque it\u00e9ration : on incr\u00e9mente num_colonne pour passer \u00e0 une nouvelle colonne on v\u00e9rifie que num_colonne n'est pas \u00e9gal \u00e0 la nouvelle largeur si oui, on passe \u00e0 la ligne suivante ( num_ligne += 1 ) et on recommence \u00e0 la premi\u00e8re colonne ( num_colonne = 0 ) on ins\u00e8re dans le nouveau tableau la valeur dans la cellule de coordonn\u00e9es num_ligne et num_colonne du tableau Cette m\u00e9thode est analogue \u00e0 celle utilis\u00e9e dans le code ci-dessous permettant de compter les dizaines et les unit\u00e9s entre 0 et 20 : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser dizaine, unites = 0, -1backslash-newlinefor nombre in range(21):backslash-newline unites += 1backslash-newline if unites == 10:backslash-newline dizaine += 1backslash-newline unites = 0backslash-newline print(f\"{nombre} = {dizaine} dizaine et {unites} unit\u00c3\u00a9(s)\")backslash-newlinebackslash-newline A Z Au travail ! \u2693\ufe0e \u00c9crire la fonction redimensionner prenant en arguments : le tableau tab \u00e0 redimensionner sous forme d'une liste de listes la nouvelle largeur nouvelle_largeur la nouvelle hauteur nouvelle_hauteur Cette fonction renverra le tableau redimensionn\u00e9 sous forme d'une liste de listes. Exemples \ud83d\udc0d Console Python >>> tab = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] >>> redimensionner ( tab , 6 , 2 ) [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]] >>> redimensionner ( tab , 3 , 4 ) [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlinetab1 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]backslash-newlinetab2 = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]backslash-newlinetab3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]backslash-newlineassert redimensionner(tab1, 6, 2) == tab2backslash-newlineassert redimensionner(tab1, 3, 4) == tab3backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinetab4 = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]backslash-newlineassert redimensionner(tab1, 12, 1) == tab4backslash-newlinetab5 = [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]]backslash-newlineassert redimensionner(tab1, 1, 12) == tab5backslash-newlinetab6 = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]backslash-newlineassert redimensionner(tab1, 2, 6) == tab6backslash-newlinetab10python-underscore2 = [backslash-newline [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],backslash-newline [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]backslash-newline]backslash-newlinetab5python-underscore4 = [backslash-newline [1, 2, 3, 4, 5],backslash-newline [6, 7, 8, 9, 10],backslash-newline [11, 12, 13, 14, 15],backslash-newline [16, 17, 18, 19, 20]backslash-newline]backslash-newlineassert redimensionner(tab10python-underscore2, 5, 4) == tab5python-underscore4backslash-newlinebackslash-newline Valider 5/5 def redimensionner(tab, nouvellepython-underscorelargeur, nouvellepython-underscorehauteur):backslash-newline nouveaupython-underscoretab = [[0]python-starnouvellepython-underscorelargeur for python-underscore in range(nouvellepython-underscorehauteur)]backslash-newlinebackslash-newline numeropython-underscoreligne, numeropython-underscorecolonne = 0, -1backslash-newline for ligne in tab:backslash-newline for valeur in ligne:backslash-newline numeropython-underscorecolonne += 1backslash-newline if numeropython-underscorecolonne == nouvellepython-underscorelargeur:backslash-newline numeropython-underscoreligne += 1backslash-newline numeropython-underscorecolonne = 0backslash-newline nouveaupython-underscoretab[numeropython-underscoreligne][numeropython-underscorecolonne] = valeurbackslash-newline return nouveaupython-underscoretabbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlinetab1 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]backslash-newlinetab2 = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]backslash-newlinetab3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]backslash-newlineassert redimensionner(tab1, 6, 2) == tab2backslash-newlineassert redimensionner(tab1, 3, 4) == tab3backslash-newlinebackslash-newline A Cet exercice demande de coder une fonction approchant la m\u00e9thode reshape du module numpy . Commentaires \u2693\ufe0e {{ py('exo_corr', 0, \"# TESTS\") }} On commence par cr\u00e9er un nouveau tableau vide aux bonnes dimensions. On parcourt ensuite l'ancien tableau (les lignes puis les valeurs dans chaque ligne) en calculant les coordonn\u00e9es de la cellule correspondante du nouveau tableau. Pour ce faire, \u00e0 chaque nouvelle valeur, on augmente le num\u00e9ro de colonne auquel ins\u00e9rer. Si celui-ci est \u00e9gal \u00e0 la nouvelle largeur, cela signifie que l'on a fini de remplir une colonne du nouveau tableau. Dans ce cas on passe \u00e0 la ligne suivante et on recommence \u00e0 la colonne 0 . A la fin de la fonction, on renvoie le nouveau tableau. Z Solution","title":"Redimensionner"},{"location":"2-moyen/redimensionner/sujet/#redimensionner-un-tableau","text":"","title":"Redimensionner un tableau"},{"location":"2-moyen/redimensionner/sujet/#objectif","text":"On consid\u00e8re un tableau de nombres, une matrice dit-on aussi, de dimensions \\(l_1 \\times h_1\\) (largeur \\(l_1\\) et hauteur \\(h_1\\) ) et l'on souhaite modifier ses dimensions afin de cr\u00e9er un tableau de dimensions \\(l_2 \\times h_2\\) . Bien entendu, les deux tableaux contiendront autant de valeurs l'un et l'autre. On garantit donc que l'on aura toujours \\(l_1 \\times h_1 = l_2 \\times h_2\\) . Par exemple, le tableau de dimensions \\(4 \\times 3\\) : \\[ \\begin{array}{|c|c|c|c|} \\hline 1&2&3&4\\\\ \\hline 5&6&7&8\\\\ \\hline 9&10&11&12\\\\ \\hline \\end{array} \\] pourra \u00eatre transform\u00e9 en un nouveau tableau de dimensions \\(6 \\times 2\\) \\[ \\begin{array}{|c|c|c|c|c|c|} \\hline 1&2&3&4&5&6\\\\ \\hline 7&8&9&10&11&12\\\\ \\hline \\end{array} \\] Les tableaux seront repr\u00e9sent\u00e9s par des listes de listes Python. Ainsi les deux tableaux ci-dessus seront repr\u00e9sent\u00e9s par : \ud83d\udc0d Script Python tab1 = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] tab2 = [[ 1 , 2 , 3 , 4 , 5 , 6 ], [ 7 , 8 , 9 , 10 , 11 , 12 ]]","title":"Objectif"},{"location":"2-moyen/redimensionner/sujet/#demarche","text":"Il faut tout d'abord cr\u00e9er un nouveau tableau aux bonnes dimensions. Le code Python ci-dessous permet de cr\u00e9er un tableau de 3 lignes sur 5 colonnes rempli de 0 \ud83d\udc0d Script Python tab_vide = [[ 0 ] * 5 for _ in range ( 3 )] Il va ensuite falloir mettre en correspondance les cellules du premier tableau et celles du second. Pour cela on propose la m\u00e9thode suivante : on cr\u00e9e des coordonn\u00e9es (par exemple num_ligne et num_colonne ). num_ligne est initialis\u00e9e \u00e0 0 , num_colonne \u00e0 -1 on parcourt l'ensemble des lignes et l'ensemble des valeurs du tableau de d\u00e9part A chaque it\u00e9ration : on incr\u00e9mente num_colonne pour passer \u00e0 une nouvelle colonne on v\u00e9rifie que num_colonne n'est pas \u00e9gal \u00e0 la nouvelle largeur si oui, on passe \u00e0 la ligne suivante ( num_ligne += 1 ) et on recommence \u00e0 la premi\u00e8re colonne ( num_colonne = 0 ) on ins\u00e8re dans le nouveau tableau la valeur dans la cellule de coordonn\u00e9es num_ligne et num_colonne du tableau Cette m\u00e9thode est analogue \u00e0 celle utilis\u00e9e dans le code ci-dessous permettant de compter les dizaines et les unit\u00e9s entre 0 et 20 : Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser dizaine, unites = 0, -1backslash-newlinefor nombre in range(21):backslash-newline unites += 1backslash-newline if unites == 10:backslash-newline dizaine += 1backslash-newline unites = 0backslash-newline print(f\"{nombre} = {dizaine} dizaine et {unites} unit\u00c3\u00a9(s)\")backslash-newlinebackslash-newline A Z","title":"D\u00e9marche"},{"location":"2-moyen/redimensionner/sujet/#au-travail","text":"\u00c9crire la fonction redimensionner prenant en arguments : le tableau tab \u00e0 redimensionner sous forme d'une liste de listes la nouvelle largeur nouvelle_largeur la nouvelle hauteur nouvelle_hauteur Cette fonction renverra le tableau redimensionn\u00e9 sous forme d'une liste de listes. Exemples \ud83d\udc0d Console Python >>> tab = [[ 1 , 2 , 3 , 4 ], [ 5 , 6 , 7 , 8 ], [ 9 , 10 , 11 , 12 ]] >>> redimensionner ( tab , 6 , 2 ) [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]] >>> redimensionner ( tab , 3 , 4 ) [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlinetab1 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]backslash-newlinetab2 = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]backslash-newlinetab3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]backslash-newlineassert redimensionner(tab1, 6, 2) == tab2backslash-newlineassert redimensionner(tab1, 3, 4) == tab3backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlinetab4 = [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]backslash-newlineassert redimensionner(tab1, 12, 1) == tab4backslash-newlinetab5 = [[1], [2], [3], [4], [5], [6], [7], [8], [9], [10], [11], [12]]backslash-newlineassert redimensionner(tab1, 1, 12) == tab5backslash-newlinetab6 = [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]backslash-newlineassert redimensionner(tab1, 2, 6) == tab6backslash-newlinetab10python-underscore2 = [backslash-newline [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],backslash-newline [11, 12, 13, 14, 15, 16, 17, 18, 19, 20]backslash-newline]backslash-newlinetab5python-underscore4 = [backslash-newline [1, 2, 3, 4, 5],backslash-newline [6, 7, 8, 9, 10],backslash-newline [11, 12, 13, 14, 15],backslash-newline [16, 17, 18, 19, 20]backslash-newline]backslash-newlineassert redimensionner(tab10python-underscore2, 5, 4) == tab5python-underscore4backslash-newlinebackslash-newline Valider 5/5 def redimensionner(tab, nouvellepython-underscorelargeur, nouvellepython-underscorehauteur):backslash-newline nouveaupython-underscoretab = [[0]python-starnouvellepython-underscorelargeur for python-underscore in range(nouvellepython-underscorehauteur)]backslash-newlinebackslash-newline numeropython-underscoreligne, numeropython-underscorecolonne = 0, -1backslash-newline for ligne in tab:backslash-newline for valeur in ligne:backslash-newline numeropython-underscorecolonne += 1backslash-newline if numeropython-underscorecolonne == nouvellepython-underscorelargeur:backslash-newline numeropython-underscoreligne += 1backslash-newline numeropython-underscorecolonne = 0backslash-newline nouveaupython-underscoretab[numeropython-underscoreligne][numeropython-underscorecolonne] = valeurbackslash-newline return nouveaupython-underscoretabbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlinetab1 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]backslash-newlinetab2 = [[1, 2, 3, 4, 5, 6], [7, 8, 9, 10, 11, 12]]backslash-newlinetab3 = [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]]backslash-newlineassert redimensionner(tab1, 6, 2) == tab2backslash-newlineassert redimensionner(tab1, 3, 4) == tab3backslash-newlinebackslash-newline A Cet exercice demande de coder une fonction approchant la m\u00e9thode reshape du module numpy .","title":"Au travail !"},{"location":"2-moyen/redimensionner/sujet/#commentaires","text":"{{ py('exo_corr', 0, \"# TESTS\") }} On commence par cr\u00e9er un nouveau tableau vide aux bonnes dimensions. On parcourt ensuite l'ancien tableau (les lignes puis les valeurs dans chaque ligne) en calculant les coordonn\u00e9es de la cellule correspondante du nouveau tableau. Pour ce faire, \u00e0 chaque nouvelle valeur, on augmente le num\u00e9ro de colonne auquel ins\u00e9rer. Si celui-ci est \u00e9gal \u00e0 la nouvelle largeur, cela signifie que l'on a fini de remplir une colonne du nouveau tableau. Dans ce cas on passe \u00e0 la ligne suivante et on recommence \u00e0 la colonne 0 . A la fin de la fonction, on renvoie le nouveau tableau. Z Solution","title":"Commentaires"},{"location":"2-moyen/rendu_monnaie/exo_REM/","text":"Commentaires \u2693\ufe0e version it\u00e9rative \u2693\ufe0e \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] i = 0 while a_rendre > 0 : if piece [ i ] > a_rendre : i += 1 else : a_rendre -= piece solution . append ( piece ) return solution Version r\u00e9cursive tr\u00e8s discutable... \u2693\ufe0e Il ne faut pas utiliser de param\u00e8tre par d\u00e9faut mutable ! \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre , solution = [], i = 0 ): if a_rendre == 0 : return solution piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) return rendu_monnaie ( a_rendre - piece , solution , i ) else : return rendu_monnaie ( a_rendre , solution , i + 1 ) Version r\u00e9cursive avec fonction interne \u2693\ufe0e \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] def rendu_glouton_rec ( a_rendre , i ): \"Ajoute \u00e0 `solution` les pi\u00e8ces \u00e0 rendre \u00e0 partir de l'indice `i`\" if a_rendre == 0 : return piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) rendu_glouton ( a_rendre - piece , i ) else : rendu_glouton ( a_rendre , i + 1 ) rendu_glouton_rec ( a_rendre , 0 ) return solution","title":"Commentaires"},{"location":"2-moyen/rendu_monnaie/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/rendu_monnaie/exo_REM/#version-iterative","text":"\ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] i = 0 while a_rendre > 0 : if piece [ i ] > a_rendre : i += 1 else : a_rendre -= piece solution . append ( piece ) return solution","title":"version it\u00e9rative"},{"location":"2-moyen/rendu_monnaie/exo_REM/#version-recursive-tres-discutable","text":"Il ne faut pas utiliser de param\u00e8tre par d\u00e9faut mutable ! \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre , solution = [], i = 0 ): if a_rendre == 0 : return solution piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) return rendu_monnaie ( a_rendre - piece , solution , i ) else : return rendu_monnaie ( a_rendre , solution , i + 1 )","title":"Version r\u00e9cursive tr\u00e8s discutable..."},{"location":"2-moyen/rendu_monnaie/exo_REM/#version-recursive-avec-fonction-interne","text":"\ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] def rendu_glouton_rec ( a_rendre , i ): \"Ajoute \u00e0 `solution` les pi\u00e8ces \u00e0 rendre \u00e0 partir de l'indice `i`\" if a_rendre == 0 : return piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) rendu_glouton ( a_rendre - piece , i ) else : rendu_glouton ( a_rendre , i + 1 ) rendu_glouton_rec ( a_rendre , 0 ) return solution","title":"Version r\u00e9cursive avec fonction interne"},{"location":"2-moyen/rendu_monnaie/sujet/","tags":["a_trou","glouton","r\u00e9cursivit\u00e9"],"text":"Algorithme de rendu de monnaie \u2693\ufe0e On s'int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d'une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d'une liste d\u00e9croissante fix\u00e9e : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] On supposera qu'il n'y a pas de limitation quant \u00e0 leur nombre. On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_monnaie qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. La fonction prend un deuxi\u00e8me entier i qui correspond \u00e0 l'indice de la pi\u00e8ce actuellement consid\u00e9r\u00e9e. Par d\u00e9faut, il vaut 0 et peut donc \u00eatre omis lors des tests. Compl\u00e9ter le code : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_monnaie ( a_rendre , i = 0 ): if a_rendre == 0 : return ... p = pieces [ i ] if p <= ... : return [ ... ] + rendu_monnaie ( ... , i ) else : return rendu_monnaie ( a_rendre , ... ) Exemples \ud83d\udc0d Console Python >>> rendu_monnaie ( 68 ) [50, 10, 5, 2, 1] >>> rendu_monnaie ( 291 ) [100, 100, 50, 20, 20, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1], \"Erreur sur ce test\"backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1], \"Erreur sur ce test\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(0) == []backslash-newlineassert rendupython-underscoremonnaie(1) == [1]backslash-newlineassert rendupython-underscoremonnaie(2) == [2]backslash-newlineassert rendupython-underscoremonnaie(sum(pieces)) == piecesbackslash-newlineassert rendupython-underscoremonnaie(4) == [2, 2]backslash-newlineassert rendupython-underscoremonnaie(500) == [100, 100, 100, 100, 100]backslash-newlinebackslash-newline Valider 5/5 pieces = [100, 50, 20, 10, 5, 2, 1]backslash-newlinebackslash-newlinedef rendupython-underscoremonnaie(apython-underscorerendre, i=0):backslash-newline if apython-underscorerendre == 0:backslash-newline return ...backslash-newline p = pieces[i]backslash-newline if p <= ... :backslash-newline return [...] + rendupython-underscoremonnaie(..., i)backslash-newline else :backslash-newline return rendupython-underscoremonnaie(apython-underscorerendre, ...)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1]backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1]backslash-newlinebackslash-newline pieces = [100, 50, 20, 10, 5, 2, 1]backslash-newlinebackslash-newlinedef rendupython-underscoremonnaie(apython-underscorerendre, i=0):backslash-newline if apython-underscorerendre == 0:backslash-newline return []backslash-newline p = pieces[i]backslash-newline if p <= apython-underscorerendre :backslash-newline return [p] + rendupython-underscoremonnaie(apython-underscorerendre - p, i)backslash-newline else :backslash-newline return rendupython-underscoremonnaie(apython-underscorerendre, i + 1)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1]backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e version it\u00e9rative \u2693\ufe0e \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] i = 0 while a_rendre > 0 : if piece [ i ] > a_rendre : i += 1 else : a_rendre -= piece solution . append ( piece ) return solution Version r\u00e9cursive tr\u00e8s discutable... \u2693\ufe0e Il ne faut pas utiliser de param\u00e8tre par d\u00e9faut mutable ! \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre , solution = [], i = 0 ): if a_rendre == 0 : return solution piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) return rendu_monnaie ( a_rendre - piece , solution , i ) else : return rendu_monnaie ( a_rendre , solution , i + 1 ) Version r\u00e9cursive avec fonction interne \u2693\ufe0e \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] def rendu_glouton_rec ( a_rendre , i ): \"Ajoute \u00e0 `solution` les pi\u00e8ces \u00e0 rendre \u00e0 partir de l'indice `i`\" if a_rendre == 0 : return piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) rendu_glouton ( a_rendre - piece , i ) else : rendu_glouton ( a_rendre , i + 1 ) rendu_glouton_rec ( a_rendre , 0 ) return solution Z","title":"Rendu de monnaie"},{"location":"2-moyen/rendu_monnaie/sujet/#algorithme-de-rendu-de-monnaie","text":"On s'int\u00e9resse \u00e0 un algorithme r\u00e9cursif qui permet de rendre la monnaie \u00e0 partir d'une liste donn\u00e9e de valeurs de pi\u00e8ces et de billets. Le syst\u00e8me mon\u00e9taire est donn\u00e9 sous forme d'une liste d\u00e9croissante fix\u00e9e : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] On supposera qu'il n'y a pas de limitation quant \u00e0 leur nombre. On cherche \u00e0 donner la liste de pi\u00e8ces \u00e0 rendre pour une somme donn\u00e9e en argument. Compl\u00e9ter le code Python ci-dessous de la fonction rendu_monnaie qui impl\u00e9mente cet algorithme et renvoie la liste des pi\u00e8ces \u00e0 rendre. La fonction prend un deuxi\u00e8me entier i qui correspond \u00e0 l'indice de la pi\u00e8ce actuellement consid\u00e9r\u00e9e. Par d\u00e9faut, il vaut 0 et peut donc \u00eatre omis lors des tests. Compl\u00e9ter le code : \ud83d\udc0d Script Python pieces = [ 100 , 50 , 20 , 10 , 5 , 2 , 1 ] def rendu_monnaie ( a_rendre , i = 0 ): if a_rendre == 0 : return ... p = pieces [ i ] if p <= ... : return [ ... ] + rendu_monnaie ( ... , i ) else : return rendu_monnaie ( a_rendre , ... ) Exemples \ud83d\udc0d Console Python >>> rendu_monnaie ( 68 ) [50, 10, 5, 2, 1] >>> rendu_monnaie ( 291 ) [100, 100, 50, 20, 20, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1], \"Erreur sur ce test\"backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1], \"Erreur sur ce test\"backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(0) == []backslash-newlineassert rendupython-underscoremonnaie(1) == [1]backslash-newlineassert rendupython-underscoremonnaie(2) == [2]backslash-newlineassert rendupython-underscoremonnaie(sum(pieces)) == piecesbackslash-newlineassert rendupython-underscoremonnaie(4) == [2, 2]backslash-newlineassert rendupython-underscoremonnaie(500) == [100, 100, 100, 100, 100]backslash-newlinebackslash-newline Valider 5/5 pieces = [100, 50, 20, 10, 5, 2, 1]backslash-newlinebackslash-newlinedef rendupython-underscoremonnaie(apython-underscorerendre, i=0):backslash-newline if apython-underscorerendre == 0:backslash-newline return ...backslash-newline p = pieces[i]backslash-newline if p <= ... :backslash-newline return [...] + rendupython-underscoremonnaie(..., i)backslash-newline else :backslash-newline return rendupython-underscoremonnaie(apython-underscorerendre, ...)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1]backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1]backslash-newlinebackslash-newline pieces = [100, 50, 20, 10, 5, 2, 1]backslash-newlinebackslash-newlinedef rendupython-underscoremonnaie(apython-underscorerendre, i=0):backslash-newline if apython-underscorerendre == 0:backslash-newline return []backslash-newline p = pieces[i]backslash-newline if p <= apython-underscorerendre :backslash-newline return [p] + rendupython-underscoremonnaie(apython-underscorerendre - p, i)backslash-newline else :backslash-newline return rendupython-underscoremonnaie(apython-underscorerendre, i + 1)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert rendupython-underscoremonnaie(68) == [50, 10, 5, 2, 1]backslash-newlineassert rendupython-underscoremonnaie(291) == [100, 100, 50, 20, 20, 1]backslash-newlinebackslash-newline A","title":"Algorithme de rendu de monnaie"},{"location":"2-moyen/rendu_monnaie/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/rendu_monnaie/sujet/#version-iterative","text":"\ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] i = 0 while a_rendre > 0 : if piece [ i ] > a_rendre : i += 1 else : a_rendre -= piece solution . append ( piece ) return solution","title":"version it\u00e9rative"},{"location":"2-moyen/rendu_monnaie/sujet/#version-recursive-tres-discutable","text":"Il ne faut pas utiliser de param\u00e8tre par d\u00e9faut mutable ! \ud83d\udc0d Script Python def rendu_monnaie ( a_rendre , solution = [], i = 0 ): if a_rendre == 0 : return solution piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) return rendu_monnaie ( a_rendre - piece , solution , i ) else : return rendu_monnaie ( a_rendre , solution , i + 1 )","title":"Version r\u00e9cursive tr\u00e8s discutable..."},{"location":"2-moyen/rendu_monnaie/sujet/#version-recursive-avec-fonction-interne","text":"\ud83d\udc0d Script Python def rendu_monnaie ( a_rendre ): solution = [] def rendu_glouton_rec ( a_rendre , i ): \"Ajoute \u00e0 `solution` les pi\u00e8ces \u00e0 rendre \u00e0 partir de l'indice `i`\" if a_rendre == 0 : return piece = pieces [ i ] if piece <= a_rendre : solution . append ( piece ) rendu_glouton ( a_rendre - piece , i ) else : rendu_glouton ( a_rendre , i + 1 ) rendu_glouton_rec ( a_rendre , 0 ) return solution Z","title":"Version r\u00e9cursive avec fonction interne"},{"location":"2-moyen/resultat_vote/sujet/","text":"Chaque soir, les auditeurs d'une radio votent en ligne pour leur artiste favori. Ces votes sont stock\u00e9s dans un tableau. Exemple \ud83d\udc0d Console Python >>> urne = [ 'Oreilles sales' , 'Oreilles sales' , 'Oreilles sales' , 'Extra Vomit' , 'Lady Baba' , 'Extra Vomit' , 'Lady Baba' , 'Extra Vomit' , 'Lady Baba' , 'Extra Vomit' ] >>> depouille ( urne ) {'Oreilles sales': 3, 'Extra Vomit': 4, 'Lady Baba': 3} >>> vainqueur ( depouille ( urne )) ['Extra Vomit'] >>> urne_2 = [ 'Poons' , 'DrRed' , 'Soleran' , 'Mimeen' , 'Poons' , 'Soleran' , 'Mimeen' , 'Zajy' , 'Soleran' , 'DrRed' , 'Zajy' , 'Kashur' , 'Mimeen' ] >>> depouille ( urne_2 ) {'Poons': 2, 'DrRed': 2, 'Soleran': 3, 'Mimeen': 3, 'Zajy': 2, 'Kashur': 1} >>> sorted ( vainqueur ( depouille ( urne_2 ))) ['Mimeen', 'Soleran'] La fonction vainqueur doit d\u00e9signer le nom du ou des gagnants. Elle prend en param\u00e8tre un dictionnaire dont la structure est celle du dictionnaire renvoy\u00e9 par la fonction depouille et renvoie un tableau. Ce tableau peut donc contenir plusieurs \u00e9l\u00e9ments s'il y a des artistes ex aequo. Compl\u00e9ter les fonctions depouille et vainqueur fournies dans l'IDE pour qu'elles renvoient les r\u00e9sultats attendus (l'ordre des artistes n'aura pas d'importance). Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlinebackslash-newlineurne = ['Oreilles sales', 'Oreilles sales', 'Oreilles sales',backslash-newline 'Extra Vomit', 'Lady Baba', 'Extra Vomit', 'Lady Baba',backslash-newline 'Extra Vomit', 'Lady Baba', 'Extra Vomit']backslash-newlinebackslash-newlineurnepython-underscore2 = ['Poons', 'DrRed', 'Soleran', 'Mimeen', 'Poons', 'Soleran', 'Mimeen', 'Zajy', 'Soleran', 'DrRed', 'Zajy', 'Kashur', 'Mimeen']backslash-newlinebackslash-newlinebackslash-newlineassert vainqueur(depouille(urne)) == ['Extra Vomit']backslash-newlineassert sorted(vainqueur(depouille(urnepython-underscore2))) == ['Mimeen', 'Soleran']backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlineurnepython-underscore3 = ['Soleran', 'Kashur', 'Poons', 'DrRed', 'Kashur', 'DrRed', 'Mimeen', 'Mimeen', 'Mimeen', 'Zajy', 'Mimeen', 'Poons', 'Soleran', 'Poons', 'Kashur', 'Zajy', 'DrRed', 'Soleran', 'DrRed', 'Kashur', 'Mimeen', 'Kashur', 'Mimeen', 'Kashur', 'Zajy', 'Poons', 'Kashur', 'Poons', 'Zajy', 'Soleran', 'DrRed', 'Mimeen', 'Zajy', 'DrRed', 'DrRed']backslash-newlinebackslash-newlineurnepython-underscore4 = ['Poons', 'Kashur', 'Poons', 'DrRed', 'Kashur', 'DrRed', 'Mimeen', 'Mimeen', 'Mimeen', 'Poons', 'Mimeen', 'Poons', 'Soleran', 'Poons', 'Kashur', 'Zajy', 'DrRed', 'Soleran', 'DrRed', 'Kashur', 'Mimeen', 'Kashur', 'Mimeen', 'Kashur', 'Zajy', 'Poons', 'Kashur', 'Poons', 'Zajy', 'Soleran', 'DrRed', 'Mimeen', 'Zajy', 'DrRed', 'DrRed']backslash-newlinebackslash-newlineassert sorted(vainqueur(depouille(urnepython-underscore3))) == ['DrRed', 'Kashur', 'Mimeen']backslash-newlineassert sorted(vainqueur(depouille(urnepython-underscore4))) == ['DrRed', 'Kashur', 'Mimeen', 'Poons']backslash-newlinebackslash-newline Valider 5/5 def depouille(urne):backslash-newline resultat = ...backslash-newline for bulletin in urne:backslash-newline if ...:backslash-newline resultat[bulletin] = ...backslash-newline else:backslash-newline ...backslash-newline return resultatbackslash-newlinebackslash-newlinedef vainqueur(effectifspython-underscorevotes):backslash-newline nbpython-underscorevotespython-underscoremax = 0backslash-newline for candidat in effectifspython-underscorevotes:backslash-newline nbpython-underscorevoix = ... backslash-newline if ... > ...:backslash-newline nbpython-underscorevotespython-underscoremax = ...backslash-newline gagnants = [nom for nom in effectifspython-underscorevotes if effectifspython-underscorevotes[nom] == ...]backslash-newline return ...backslash-newlinebackslash-newlineurne = ['Oreilles sales', 'Oreilles sales', 'Oreilles sales',backslash-newline 'Extra Vomit', 'Lady Baba', 'Extra Vomit', 'Lady Baba',backslash-newline 'Extra Vomit', 'Lady Baba', 'Extra Vomit']backslash-newlinebackslash-newlineurnepython-underscore2 = ['Poons', 'DrRed', 'Soleran', 'Mimeen', 'Poons', 'Soleran', 'Mimeen', 'Zajy', 'Soleran', 'DrRed', 'Zajy', 'Kashur', 'Mimeen']backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert vainqueur(depouille(urne)) == ['Extra Vomit']backslash-newlineassert sorted(vainqueur(depouille(urnepython-underscore2))) == ['Mimeen', 'Soleran']backslash-newlinebackslash-newline def depouille(urne):backslash-newline resultat = {}backslash-newline for bulletin in urne:backslash-newline if bulletin in resultat:backslash-newline resultat[bulletin] = resultat[bulletin] + 1backslash-newline else:backslash-newline resultat[bulletin] = 1backslash-newline return resultatbackslash-newlinebackslash-newlinedef vainqueur(effectifspython-underscorevotes):backslash-newline nbpython-underscorevotespython-underscoremax = 0backslash-newline for candidat in effectifspython-underscorevotes:backslash-newline nbpython-underscorevoix = effectifspython-underscorevotes[candidat] backslash-newline if nbpython-underscorevoix > nbpython-underscorevotespython-underscoremax:backslash-newline nbpython-underscorevotespython-underscoremax = nbpython-underscorevoixbackslash-newline gagnants = [nom for nom in effectifspython-underscorevotes if effectifspython-underscorevotes[nom] == nbpython-underscorevotespython-underscoremax]backslash-newline return gagnantsbackslash-newlinebackslash-newline A Z","title":"Meilleures apparitions dans un tableau"},{"location":"2-moyen/tableau_0_1/exo_REM/","text":"Commentaires \u2693\ufe0e Pas la peine d'\u00e9changer \u2693\ufe0e Normalement pour \u00e9changer 2 valeurs dans un tableau, il faut faire 3 affectations (ou une affectation double a, b = b, a ). Dans notre cas, puisqu'on sait que le tableau ne contient que des 0 ou des 1, dans le else on sait qu'il s'agit d'un 1. On peut doc se passer de l'\u00e9change et faire uniquement deux affectations : \ud83d\udc0d Script Python ... else : zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = 1 ... au lieu de : \ud83d\udc0d Script Python ... else : valeur = zeros_et_uns [ debut ] zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = valeur ... Compter \u2693\ufe0e On peut compter les 0 et \u00e9crire le bon nombre de 0 et de 1 apr\u00e8s.","title":"Commentaires"},{"location":"2-moyen/tableau_0_1/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/tableau_0_1/exo_REM/#pas-la-peine-dechanger","text":"Normalement pour \u00e9changer 2 valeurs dans un tableau, il faut faire 3 affectations (ou une affectation double a, b = b, a ). Dans notre cas, puisqu'on sait que le tableau ne contient que des 0 ou des 1, dans le else on sait qu'il s'agit d'un 1. On peut doc se passer de l'\u00e9change et faire uniquement deux affectations : \ud83d\udc0d Script Python ... else : zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = 1 ... au lieu de : \ud83d\udc0d Script Python ... else : valeur = zeros_et_uns [ debut ] zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = valeur ...","title":"Pas la peine d'\u00e9changer"},{"location":"2-moyen/tableau_0_1/exo_REM/#compter","text":"On peut compter les 0 et \u00e9crire le bon nombre de 0 et de 1 apr\u00e8s.","title":"Compter"},{"location":"2-moyen/tableau_0_1/sujet/","tags":["boucle","tri","a_trou"],"text":"Tri d'un tableau de 0 et de 1 \u2693\ufe0e On consid\u00e8re un tableau d'entiers zeros_et_uns (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Ci-dessous un sch\u00e9ma de la situation pendant le processus de s\u00e9paration des 0 et des 1 : \ud83d\udccb Texte debut de zone fin de zone non tri\u00e9e non tri\u00e9e | | v v ------------------------------------ | 0 ... 0 | zone non tri\u00e9e | 1 ... 1 | ------------------------------------ Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu'il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Exemples \ud83d\udc0d Console Python >>> tableau1 = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> separe ( tableau1 ) >>> tableau1 [0, 0, 0, 0, 1, 1, 1] \ud83d\udc0d Console Python >>> tableau2 = [ 1 , 1 , 1 , 0 , 0 , 0 ] >>> separe ( tableau2 ) >>> tableau2 [0, 0, 0, 1, 1, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinetableaupython-underscorevide = []backslash-newlinesepare(tableaupython-underscorevide)backslash-newlineassert tableaupython-underscorevide == []backslash-newlinebackslash-newlinequepython-underscore0 = [0]python-star100backslash-newlinesepare(quepython-underscore0)backslash-newlineassert quepython-underscore0 == [0]python-star100backslash-newlinebackslash-newlinequepython-underscore1 = [1]python-star100backslash-newlinesepare(quepython-underscore1)backslash-newlineassert quepython-underscore1 == [1]python-star100backslash-newlinebackslash-newlinemonopython-underscore0 = [0]backslash-newlinesepare(monopython-underscore0)backslash-newlineassert monopython-underscore0 == [0]backslash-newlinebackslash-newlinemonopython-underscore1 = [1]backslash-newlinesepare(monopython-underscore1)backslash-newlineassert monopython-underscore1 == [1]backslash-newlinebackslash-newlineduo = [1, 0]backslash-newlinesepare(duo)backslash-newlineassert duo == [0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscorea = [1, 0, 0, 0, 0, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscorea)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscorea == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscoreb = [0, 0, 1, 0, 0, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscoreb)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscoreb == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscorec = [0, 0, 0, 0, 0, 1]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscorec)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscorec == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore0python-underscorea = [0, 1, 1, 1, 1, 1]backslash-newlinesepare(unpython-underscoreseulpython-underscore0python-underscorea)backslash-newlineassert unpython-underscoreseulpython-underscore0python-underscorea == [0, 1, 1, 1, 1, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore0python-underscorec = [1, 1, 1, 1, 1, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore0python-underscorec)backslash-newlineassert unpython-underscoreseulpython-underscore0python-underscorec == [0, 1, 1, 1, 1, 1]backslash-newlinebackslash-newline Valider 5/5 def separe(zerospython-underscoreetpython-underscoreuns):backslash-newline \"\"\"place tous les 0 de zerospython-underscoreetpython-underscoreuns \u00c3 gauche et tous les 1 \u00c3 droite\"\"\"backslash-newline debut = ... # indice de d\u00c3\u00a9butbackslash-newline fin = ... # indice de finbackslash-newline while debut < fin:backslash-newline if zerospython-underscoreetpython-underscoreuns[debut] == 0:backslash-newline debut = ...backslash-newline else:backslash-newline zerospython-underscoreetpython-underscoreuns[debut] = ...backslash-newline ... = 1backslash-newline fin = ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline def separe(zerospython-underscoreetpython-underscoreuns):backslash-newline \"\"\"place tous les 0 de zerospython-underscoreetpython-underscoreuns \u00c3 gauche et tous les 1 \u00c3 droite\"\"\"backslash-newline debut = 0 # indice de d\u00c3\u00a9butbackslash-newline fin = len(zerospython-underscoreetpython-underscoreuns) - 1 # indice de finbackslash-newline while debut < fin:backslash-newline if zerospython-underscoreetpython-underscoreuns[debut] == 0:backslash-newline debut = debut + 1backslash-newline else:backslash-newline zerospython-underscoreetpython-underscoreuns[debut] = zerospython-underscoreetpython-underscoreuns[fin]backslash-newline zerospython-underscoreetpython-underscoreuns[fin] = 1backslash-newline fin = fin - 1backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Pas la peine d'\u00e9changer \u2693\ufe0e Normalement pour \u00e9changer 2 valeurs dans un tableau, il faut faire 3 affectations (ou une affectation double a, b = b, a ). Dans notre cas, puisqu'on sait que le tableau ne contient que des 0 ou des 1, dans le else on sait qu'il s'agit d'un 1. On peut doc se passer de l'\u00e9change et faire uniquement deux affectations : \ud83d\udc0d Script Python ... else : zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = 1 ... au lieu de : \ud83d\udc0d Script Python ... else : valeur = zeros_et_uns [ debut ] zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = valeur ... Compter \u2693\ufe0e On peut compter les 0 et \u00e9crire le bon nombre de 0 et de 1 apr\u00e8s. Z","title":"Tableau de 0 et 1"},{"location":"2-moyen/tableau_0_1/sujet/#tri-dun-tableau-de-0-et-de-1","text":"On consid\u00e8re un tableau d'entiers zeros_et_uns (type list dont les \u00e9l\u00e9ments sont des 0 ou des 1 ). On se propose de trier ce tableau selon l'algorithme suivant : \u00e0 chaque \u00e9tape du tri, le tableau est constitu\u00e9 de trois zones cons\u00e9cutives, la premi\u00e8re ne contenant que des 0 , la seconde n'\u00e9tant pas tri\u00e9e et la derni\u00e8re ne contenant que des 1 . Ci-dessous un sch\u00e9ma de la situation pendant le processus de s\u00e9paration des 0 et des 1 : \ud83d\udccb Texte debut de zone fin de zone non tri\u00e9e non tri\u00e9e | | v v ------------------------------------ | 0 ... 0 | zone non tri\u00e9e | 1 ... 1 | ------------------------------------ Tant que la zone non tri\u00e9e n'est pas r\u00e9duite \u00e0 un seul \u00e9l\u00e9ment, on regarde son premier \u00e9l\u00e9ment : si cet \u00e9l\u00e9ment vaut 0, on consid\u00e8re qu'il appartient d\u00e9sormais \u00e0 la zone ne contenant que des 0 ; si cet \u00e9l\u00e9ment vaut 1, il est \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment de la zone non tri\u00e9e et on consid\u00e8re alors qu'il appartient \u00e0 la zone ne contenant que des 1. Dans tous les cas, la longueur de la zone non tri\u00e9e diminue de 1. Exemples \ud83d\udc0d Console Python >>> tableau1 = [ 0 , 1 , 0 , 1 , 0 , 1 , 0 ] >>> separe ( tableau1 ) >>> tableau1 [0, 0, 0, 0, 1, 1, 1] \ud83d\udc0d Console Python >>> tableau2 = [ 1 , 1 , 1 , 0 , 0 , 0 ] >>> separe ( tableau2 ) >>> tableau2 [0, 0, 0, 1, 1, 1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinetableaupython-underscorevide = []backslash-newlinesepare(tableaupython-underscorevide)backslash-newlineassert tableaupython-underscorevide == []backslash-newlinebackslash-newlinequepython-underscore0 = [0]python-star100backslash-newlinesepare(quepython-underscore0)backslash-newlineassert quepython-underscore0 == [0]python-star100backslash-newlinebackslash-newlinequepython-underscore1 = [1]python-star100backslash-newlinesepare(quepython-underscore1)backslash-newlineassert quepython-underscore1 == [1]python-star100backslash-newlinebackslash-newlinemonopython-underscore0 = [0]backslash-newlinesepare(monopython-underscore0)backslash-newlineassert monopython-underscore0 == [0]backslash-newlinebackslash-newlinemonopython-underscore1 = [1]backslash-newlinesepare(monopython-underscore1)backslash-newlineassert monopython-underscore1 == [1]backslash-newlinebackslash-newlineduo = [1, 0]backslash-newlinesepare(duo)backslash-newlineassert duo == [0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscorea = [1, 0, 0, 0, 0, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscorea)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscorea == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscoreb = [0, 0, 1, 0, 0, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscoreb)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscoreb == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore1python-underscorec = [0, 0, 0, 0, 0, 1]backslash-newlinesepare(unpython-underscoreseulpython-underscore1python-underscorec)backslash-newlineassert unpython-underscoreseulpython-underscore1python-underscorec == [0, 0, 0, 0, 0, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore0python-underscorea = [0, 1, 1, 1, 1, 1]backslash-newlinesepare(unpython-underscoreseulpython-underscore0python-underscorea)backslash-newlineassert unpython-underscoreseulpython-underscore0python-underscorea == [0, 1, 1, 1, 1, 1]backslash-newlinebackslash-newlineunpython-underscoreseulpython-underscore0python-underscorec = [1, 1, 1, 1, 1, 0]backslash-newlinesepare(unpython-underscoreseulpython-underscore0python-underscorec)backslash-newlineassert unpython-underscoreseulpython-underscore0python-underscorec == [0, 1, 1, 1, 1, 1]backslash-newlinebackslash-newline Valider 5/5 def separe(zerospython-underscoreetpython-underscoreuns):backslash-newline \"\"\"place tous les 0 de zerospython-underscoreetpython-underscoreuns \u00c3 gauche et tous les 1 \u00c3 droite\"\"\"backslash-newline debut = ... # indice de d\u00c3\u00a9butbackslash-newline fin = ... # indice de finbackslash-newline while debut < fin:backslash-newline if zerospython-underscoreetpython-underscoreuns[debut] == 0:backslash-newline debut = ...backslash-newline else:backslash-newline zerospython-underscoreetpython-underscoreuns[debut] = ...backslash-newline ... = 1backslash-newline fin = ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline def separe(zerospython-underscoreetpython-underscoreuns):backslash-newline \"\"\"place tous les 0 de zerospython-underscoreetpython-underscoreuns \u00c3 gauche et tous les 1 \u00c3 droite\"\"\"backslash-newline debut = 0 # indice de d\u00c3\u00a9butbackslash-newline fin = len(zerospython-underscoreetpython-underscoreuns) - 1 # indice de finbackslash-newline while debut < fin:backslash-newline if zerospython-underscoreetpython-underscoreuns[debut] == 0:backslash-newline debut = debut + 1backslash-newline else:backslash-newline zerospython-underscoreetpython-underscoreuns[debut] = zerospython-underscoreetpython-underscoreuns[fin]backslash-newline zerospython-underscoreetpython-underscoreuns[fin] = 1backslash-newline fin = fin - 1backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableau1 = [0, 1, 0, 1, 0, 1, 0]backslash-newlinesepare(tableau1)backslash-newlineassert tableau1 == [0, 0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newlinetableau2 = [1, 1, 1, 0, 0, 0]backslash-newlinesepare(tableau2)backslash-newlineassert tableau2 == [0, 0, 0, 1, 1, 1]backslash-newlinebackslash-newline A","title":"Tri d'un tableau de 0 et de 1"},{"location":"2-moyen/tableau_0_1/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"2-moyen/tableau_0_1/sujet/#pas-la-peine-dechanger","text":"Normalement pour \u00e9changer 2 valeurs dans un tableau, il faut faire 3 affectations (ou une affectation double a, b = b, a ). Dans notre cas, puisqu'on sait que le tableau ne contient que des 0 ou des 1, dans le else on sait qu'il s'agit d'un 1. On peut doc se passer de l'\u00e9change et faire uniquement deux affectations : \ud83d\udc0d Script Python ... else : zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = 1 ... au lieu de : \ud83d\udc0d Script Python ... else : valeur = zeros_et_uns [ debut ] zeros_et_uns [ debut ] = zeros_et_uns [ fin ] zeros_et_uns [ fin ] = valeur ...","title":"Pas la peine d'\u00e9changer"},{"location":"2-moyen/tableau_0_1/sujet/#compter","text":"On peut compter les 0 et \u00e9crire le bon nombre de 0 et de 1 apr\u00e8s. Z","title":"Compter"},{"location":"2-moyen/transposition/sujet/","tags":["grille","compr\u00e9hension","a_trou"],"text":"Transposition de tableau 2D \u2693\ufe0e La transposition d'un tableau \u00e0 deux dimensions est une op\u00e9ration qui, concr\u00e8tement, \u00e9change le r\u00f4le des lignes et des colonnes. On l'utilise en math\u00e9matiques pour la multiplication de matrices. On l'utilise en infographie pour des transformations d'images. \\[\\begin{bmatrix} 0 & \\mathbf{1} & 1 & 1\\\\ 1 & \\mathbf{0} & 1 & 0\\\\ 0 & \\mathbf{0} & 0 & 1\\\\ \\end{bmatrix}\\] La tableau ci-dessus, donne par transposition \\[\\begin{bmatrix} 0 & 1 & 0\\\\ \\mathbf{1} & \\mathbf{0} & \\mathbf{0}\\\\ 1 & 1 & 0\\\\ 1 & 0 & 1\\\\ \\end{bmatrix}\\] La colonne d'indice 1 est devenue la ligne d'indice 1. \u00c9crire une fonction transposition qui renvoie la transposition d'un tableau \u00e0 deux dimensions grille : une liste Python contenant des listes d'\u00e9l\u00e9ments de m\u00eame type. Pour cela on utilisera des fonctions telles que : nb_lignes(grille) renvoie le nombre de lignes de la grille ; ligne(grille, i) renvoie la ligne d'indice i de la grille sous forme d'un tableau. nb_colonnes(grille) renvoie le nombre de colonnes de la grille ; colonne(grille, j) renvoie la colonne d'indice j de la grille sous forme d'un tableau. On garantit que pour grille : Il y a au moins une ligne et au moins une colonne. Toutes les lignes sont de m\u00eame longueur. Compl\u00e9ter le code : \ud83d\udc0d Script Python def nb_lignes ( grille ): return len ( ... ) def ligne ( grille , i ): return ... def nb_colonnes ( grille ): return ... def colonne ( grille , j ): return [ grille [ ... ][ ... ] for i in range ( ... )] def transposition ( tableau ): return [ ... for j in range ( ... )] Exemples \ud83d\udc0d Console Python >>> grille = [ ... [ 0 , 1 , 1 , 1 ], ... [ 1 , 0 , 1 , 0 ], ... [ 0 , 0 , 0 , 1 ], ... ] >>> nb_lignes ( grille ) 3 >>> ligne ( grille , 0 ) [0, 1, 1, 1] >>> nb_colonnes ( grille ) 4 >>> colonne ( grille , 1 ) [1, 0, 0] >>> t_grille = [ ... [ 0 , 1 , 0 ], ... [ 1 , 0 , 0 ], ... [ 1 , 1 , 0 ], ... [ 1 , 0 , 1 ], ... ] >>> transposition ( grille ) == t_grille True >>> transposition ( t_grille ) == grille True \ud83d\udc0d Console Python >>> grille = [ ... [ '#' , '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' , '#' ], ... [ '.' , '.' , '#' , '#' , '#' ], ... [ '#' , '.' , '#' , '#' , '#' ], ... ] >>> nb_lignes ( grille ) 4 >>> ligne ( grille , 3 ) ['#', '.', '#', '#', '#'] >>> nb_colonnes ( grille ) 5 >>> colonne ( grille , 0 ) ['#', '#', '.', '#'] >>> t_grille = [ ... [ '#' , '#' , '.' , '#' ], ... [ '#' , '#' , '.' , '.' ], ... [ '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' ], ... ] >>> transposition ( grille ) == t_grille True >>> transposition ( t_grille ) == grille True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlineunepython-underscorecolonne = [backslash-newline [(1, 2, 9)],backslash-newline [(3, 4, 9)],backslash-newline [(5, 6, 9)],backslash-newline [(7, 8, 9)],backslash-newline]backslash-newlineunepython-underscoreligne = [backslash-newline [(1, 2, 9), (3, 4, 9), (5, 6, 9), (7, 8, 9)],backslash-newline]backslash-newlineassert nbpython-underscorelignes(unepython-underscorecolonne) == len(unepython-underscorecolonne)backslash-newlineassert nbpython-underscorecolonnes(unepython-underscorecolonne) == len(unepython-underscorecolonne[0])backslash-newlineassert ligne(unepython-underscorecolonne, 0) == unepython-underscorecolonne[0]backslash-newlineassert colonne(unepython-underscorecolonne, 0) == [unepython-underscorecolonne[i][0] for i in range(len(unepython-underscorecolonne))]backslash-newlineassert transposition(unepython-underscoreligne) == unepython-underscorecolonnebackslash-newlineassert transposition(unepython-underscorecolonne) == unepython-underscorelignebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorelignes(grille):backslash-newline return len(...)backslash-newlinebackslash-newlinedef ligne(grille, i):backslash-newline return ...backslash-newlinebackslash-newlinedef nbpython-underscorecolonnes(grille):backslash-newline return ...backslash-newlinebackslash-newlinedef colonne(grille, j):backslash-newline return [grille[...][...] for i in range(...)]backslash-newlinebackslash-newlinedef transposition(tableau):backslash-newline return [... for j in range(...)]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newline def nbpython-underscorelignes(grille):backslash-newline return len(grille)backslash-newlinebackslash-newlinedef ligne(grille, i):backslash-newline return grille[i]backslash-newlinebackslash-newlinedef nbpython-underscorecolonnes(grille):backslash-newline return len(grille[0])backslash-newlinebackslash-newlinedef colonne(grille, j):backslash-newline return [grille[i][j] for i in range(nbpython-underscorelignes(grille))]backslash-newlinebackslash-newlinedef transposition(tableau):backslash-newline return [colonne(tableau, j) for j in range(nbpython-underscorecolonnes(tableau))]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newline A Z","title":"Transposition"},{"location":"2-moyen/transposition/sujet/#transposition-de-tableau-2d","text":"La transposition d'un tableau \u00e0 deux dimensions est une op\u00e9ration qui, concr\u00e8tement, \u00e9change le r\u00f4le des lignes et des colonnes. On l'utilise en math\u00e9matiques pour la multiplication de matrices. On l'utilise en infographie pour des transformations d'images. \\[\\begin{bmatrix} 0 & \\mathbf{1} & 1 & 1\\\\ 1 & \\mathbf{0} & 1 & 0\\\\ 0 & \\mathbf{0} & 0 & 1\\\\ \\end{bmatrix}\\] La tableau ci-dessus, donne par transposition \\[\\begin{bmatrix} 0 & 1 & 0\\\\ \\mathbf{1} & \\mathbf{0} & \\mathbf{0}\\\\ 1 & 1 & 0\\\\ 1 & 0 & 1\\\\ \\end{bmatrix}\\] La colonne d'indice 1 est devenue la ligne d'indice 1. \u00c9crire une fonction transposition qui renvoie la transposition d'un tableau \u00e0 deux dimensions grille : une liste Python contenant des listes d'\u00e9l\u00e9ments de m\u00eame type. Pour cela on utilisera des fonctions telles que : nb_lignes(grille) renvoie le nombre de lignes de la grille ; ligne(grille, i) renvoie la ligne d'indice i de la grille sous forme d'un tableau. nb_colonnes(grille) renvoie le nombre de colonnes de la grille ; colonne(grille, j) renvoie la colonne d'indice j de la grille sous forme d'un tableau. On garantit que pour grille : Il y a au moins une ligne et au moins une colonne. Toutes les lignes sont de m\u00eame longueur. Compl\u00e9ter le code : \ud83d\udc0d Script Python def nb_lignes ( grille ): return len ( ... ) def ligne ( grille , i ): return ... def nb_colonnes ( grille ): return ... def colonne ( grille , j ): return [ grille [ ... ][ ... ] for i in range ( ... )] def transposition ( tableau ): return [ ... for j in range ( ... )] Exemples \ud83d\udc0d Console Python >>> grille = [ ... [ 0 , 1 , 1 , 1 ], ... [ 1 , 0 , 1 , 0 ], ... [ 0 , 0 , 0 , 1 ], ... ] >>> nb_lignes ( grille ) 3 >>> ligne ( grille , 0 ) [0, 1, 1, 1] >>> nb_colonnes ( grille ) 4 >>> colonne ( grille , 1 ) [1, 0, 0] >>> t_grille = [ ... [ 0 , 1 , 0 ], ... [ 1 , 0 , 0 ], ... [ 1 , 1 , 0 ], ... [ 1 , 0 , 1 ], ... ] >>> transposition ( grille ) == t_grille True >>> transposition ( t_grille ) == grille True \ud83d\udc0d Console Python >>> grille = [ ... [ '#' , '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' , '#' ], ... [ '.' , '.' , '#' , '#' , '#' ], ... [ '#' , '.' , '#' , '#' , '#' ], ... ] >>> nb_lignes ( grille ) 4 >>> ligne ( grille , 3 ) ['#', '.', '#', '#', '#'] >>> nb_colonnes ( grille ) 5 >>> colonne ( grille , 0 ) ['#', '#', '.', '#'] >>> t_grille = [ ... [ '#' , '#' , '.' , '#' ], ... [ '#' , '#' , '.' , '.' ], ... [ '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' ], ... [ '#' , '#' , '#' , '#' ], ... ] >>> transposition ( grille ) == t_grille True >>> transposition ( t_grille ) == grille True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinebackslash-newlineunepython-underscorecolonne = [backslash-newline [(1, 2, 9)],backslash-newline [(3, 4, 9)],backslash-newline [(5, 6, 9)],backslash-newline [(7, 8, 9)],backslash-newline]backslash-newlineunepython-underscoreligne = [backslash-newline [(1, 2, 9), (3, 4, 9), (5, 6, 9), (7, 8, 9)],backslash-newline]backslash-newlineassert nbpython-underscorelignes(unepython-underscorecolonne) == len(unepython-underscorecolonne)backslash-newlineassert nbpython-underscorecolonnes(unepython-underscorecolonne) == len(unepython-underscorecolonne[0])backslash-newlineassert ligne(unepython-underscorecolonne, 0) == unepython-underscorecolonne[0]backslash-newlineassert colonne(unepython-underscorecolonne, 0) == [unepython-underscorecolonne[i][0] for i in range(len(unepython-underscorecolonne))]backslash-newlineassert transposition(unepython-underscoreligne) == unepython-underscorecolonnebackslash-newlineassert transposition(unepython-underscorecolonne) == unepython-underscorelignebackslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorelignes(grille):backslash-newline return len(...)backslash-newlinebackslash-newlinedef ligne(grille, i):backslash-newline return ...backslash-newlinebackslash-newlinedef nbpython-underscorecolonnes(grille):backslash-newline return ...backslash-newlinebackslash-newlinedef colonne(grille, j):backslash-newline return [grille[...][...] for i in range(...)]backslash-newlinebackslash-newlinedef transposition(tableau):backslash-newline return [... for j in range(...)]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newline def nbpython-underscorelignes(grille):backslash-newline return len(grille)backslash-newlinebackslash-newlinedef ligne(grille, i):backslash-newline return grille[i]backslash-newlinebackslash-newlinedef nbpython-underscorecolonnes(grille):backslash-newline return len(grille[0])backslash-newlinebackslash-newlinedef colonne(grille, j):backslash-newline return [grille[i][j] for i in range(nbpython-underscorelignes(grille))]backslash-newlinebackslash-newlinedef transposition(tableau):backslash-newline return [colonne(tableau, j) for j in range(nbpython-underscorecolonnes(tableau))]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinegrille = [backslash-newline [0, 1, 1, 1],backslash-newline [1, 0, 1, 0],backslash-newline [0, 0, 0, 1],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 3backslash-newlineassert ligne(grille, 0) == [0, 1, 1, 1]backslash-newlineassert nbpython-underscorecolonnes(grille) == 4backslash-newlineassert colonne(grille, 1) == [1, 0, 0]backslash-newlinetpython-underscoregrille = [backslash-newline [0, 1, 0],backslash-newline [1, 0, 0],backslash-newline [1, 1, 0],backslash-newline [1, 0, 1],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newlinegrille = [backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#', '#'],backslash-newline ['.', '.', '#', '#', '#'],backslash-newline ['#', '.', '#', '#', '#'],backslash-newline]backslash-newlineassert nbpython-underscorelignes(grille) == 4backslash-newlineassert ligne(grille, 3) == ['#', '.', '#', '#', '#']backslash-newlineassert nbpython-underscorecolonnes(grille) == 5backslash-newlineassert colonne(grille, 0) == ['#', '#', '.', '#']backslash-newlinetpython-underscoregrille = [backslash-newline ['#', '#', '.', '#'],backslash-newline ['#', '#', '.', '.'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline ['#', '#', '#', '#'],backslash-newline]backslash-newlineassert transposition(grille) == tpython-underscoregrillebackslash-newlineassert transposition(tpython-underscoregrille) == grillebackslash-newlinebackslash-newline A Z","title":"Transposition de tableau 2D"},{"location":"2-moyen/tri_bulles/sujet/","tags":["a_trou","tri"],"text":"Tri \u00e0 bulles d'un tableau \u2693\ufe0e Principe du tri \u00e0 bulles On parcourt le tableau de la fin vers le d\u00e9but, avec la variable d'indice \\(i\\) . Pour chaque parcours avec \\(i\\) , on parcourt le tableau avec un indice \\(j\\) en allant du d\u00e9but jusqu'\u00e0 \\(i\\) (ou presque) ; si deux \u00e9l\u00e9ments cons\u00e9cutifs autour de l'indice \\(j\\) sont mal rang\u00e9s, on les \u00e9change. Objectifs : \u00c9crire une fonction telle que tri_bulles(nombres) op\u00e8re un tri en place du tableau nombres . La fonction ne renvoie rien, (\u00e0 part None ) ; inutile de placer return . Le tableau nombres est modifi\u00e9 par la fonction ; on parle donc de tri en place. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python def tri_bulles ( nombres ): n = len ( nombres ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if nombres [ j ] > nombres [ ... ]: # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changer ... Exemples \ud83d\udc0d Console Python >>> nb_premiers = [ 2 , 11 , 3 , 7 , 5 ] >>> tri_bulles ( nb_premiers ) >>> nb_premiers [2, 3, 5, 7, 11] \ud83d\udc0d Console Python >>> seul = [ 42 ] >>> tri_bulles ( seul ) >>> seul [42] \ud83d\udc0d Console Python >>> vide = [] >>> tri_bulles ( vide ) >>> vide [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinefrom random import samplebackslash-newlinefor i in range(10):backslash-newline nombres = list(sample(range(10python-starpython-star9), 100+i))backslash-newline attendu = sorted(nombres)backslash-newline tripython-underscorebulles(nombres)backslash-newline assert len(nombres) == len(attendu), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newline for a, b, in zip(nombres, attendu):backslash-newline assert a == b, \"Erreur lors du tri\"backslash-newlinebackslash-newline Valider 5/5 def tripython-underscorebulles(nombres):backslash-newline n = len(nombres)backslash-newline for i in range(..., ..., -1):backslash-newline for j in range(i):backslash-newline if nombres[j] > nombres[...]:backslash-newline # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changerbackslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline def tripython-underscorebulles(nombres):backslash-newline n = len(nombres)backslash-newline for i in range(n - 1, -1, -1):backslash-newline for j in range(i):backslash-newline if nombres[j] > nombres[j + 1]:backslash-newline # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changerbackslash-newline nombres[j], nombres[j + 1] = nombres[j + 1], nombres[j]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline A Z","title":"Tri \u00e0 bulles"},{"location":"2-moyen/tri_bulles/sujet/#tri-a-bulles-dun-tableau","text":"Principe du tri \u00e0 bulles On parcourt le tableau de la fin vers le d\u00e9but, avec la variable d'indice \\(i\\) . Pour chaque parcours avec \\(i\\) , on parcourt le tableau avec un indice \\(j\\) en allant du d\u00e9but jusqu'\u00e0 \\(i\\) (ou presque) ; si deux \u00e9l\u00e9ments cons\u00e9cutifs autour de l'indice \\(j\\) sont mal rang\u00e9s, on les \u00e9change. Objectifs : \u00c9crire une fonction telle que tri_bulles(nombres) op\u00e8re un tri en place du tableau nombres . La fonction ne renvoie rien, (\u00e0 part None ) ; inutile de placer return . Le tableau nombres est modifi\u00e9 par la fonction ; on parle donc de tri en place. Compl\u00e9ter le code Python ci-dessous qui impl\u00e9mente la fonction tri_bulles . \ud83d\udc0d Script Python def tri_bulles ( nombres ): n = len ( nombres ) for i in range ( ... , ... , - 1 ): for j in range ( i ): if nombres [ j ] > nombres [ ... ]: # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changer ... Exemples \ud83d\udc0d Console Python >>> nb_premiers = [ 2 , 11 , 3 , 7 , 5 ] >>> tri_bulles ( nb_premiers ) >>> nb_premiers [2, 3, 5, 7, 11] \ud83d\udc0d Console Python >>> seul = [ 42 ] >>> tri_bulles ( seul ) >>> seul [42] \ud83d\udc0d Console Python >>> vide = [] >>> tri_bulles ( vide ) >>> vide [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinefrom random import samplebackslash-newlinefor i in range(10):backslash-newline nombres = list(sample(range(10python-starpython-star9), 100+i))backslash-newline attendu = sorted(nombres)backslash-newline tripython-underscorebulles(nombres)backslash-newline assert len(nombres) == len(attendu), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newline for a, b, in zip(nombres, attendu):backslash-newline assert a == b, \"Erreur lors du tri\"backslash-newlinebackslash-newline Valider 5/5 def tripython-underscorebulles(nombres):backslash-newline n = len(nombres)backslash-newline for i in range(..., ..., -1):backslash-newline for j in range(i):backslash-newline if nombres[j] > nombres[...]:backslash-newline # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changerbackslash-newline ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline def tripython-underscorebulles(nombres):backslash-newline n = len(nombres)backslash-newline for i in range(n - 1, -1, -1):backslash-newline for j in range(i):backslash-newline if nombres[j] > nombres[j + 1]:backslash-newline # nombres[j] et nombre[j + 1] \u00c3 \u00c3\u00a9changerbackslash-newline nombres[j], nombres[j + 1] = nombres[j + 1], nombres[j]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinenbpython-underscorepremiers = [2, 11, 3, 7, 5]backslash-newlinenbpython-underscorepremierspython-underscoretrie = [2, 3, 5, 7, 11]backslash-newlinetripython-underscorebulles(nbpython-underscorepremiers)backslash-newlineassert len(nbpython-underscorepremiers) == len(nbpython-underscorepremierspython-underscoretrie), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newlinefor a, b, in zip(nbpython-underscorepremiers, nbpython-underscorepremierspython-underscoretrie):backslash-newline assert a == b, \"Erreur lors du tri de [2, 11, 3, 7, 5]\"backslash-newlinebackslash-newlinebackslash-newlineseul = [42]backslash-newlineseulpython-underscoretrie = [42]backslash-newlinetripython-underscorebulles(seul)backslash-newlineassert len(seul) == 1, \"Erreur, le tableau [42] ne doit pas changer de taille\"backslash-newlineassert seul[0] == 42, \"Erreur, un \u00c3\u00a9l\u00c3\u00a9ment seul est d\u00c3\u00a9j\u00c3 tri\u00c3\u00a9\"backslash-newlinebackslash-newline A Z","title":"Tri \u00e0 bulles d'un tableau"},{"location":"2-moyen/tri_denombrement/exo_REM/","text":"Commentaires \u2693\ufe0e Il s'agit d'un tri original car de complexit\u00e9 lin\u00e9aire. Avantageux sur ce point, il l'est moins sur les deux point suivants : cet algorithme ne s'applique qu'aux valeurs enti\u00e8res positives ou nulles il n\u00e9cessite de cr\u00e9er un tableau annexe contenant les effectifs ce qui peut consommer de la m\u00e9moire (imaginez le tri d'un tableau des deux nombres 0 et 1000 : le tableau effectifs contient 1001 cellules !) \ud83d\udc0d Script Python def maximum ( nombres ): maxi = 0 for nb in nombres : if nb > maxi : maxi = nb return maxi def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 nombres_tries = [] for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries La fonction maximum est classique : on initialise le maximum \u00e0 0 puis on lit l'ensemble des valeurs. Pour la fonction tri_denombrement : on commence par chercher la valeur maximale on cr\u00e9e ensuite le tableau effectifs contenant maximum + 1 fois le nombre 0 on lit ensuite l'ensemble des valeurs de nombres et on incr\u00e9mente la cellule effectifs[nb] correspondante on cr\u00e9e une liste vide nombres_tries on remplit cette liste vide : on parcourt tous les entiers n entre 0 et maxi pour chacun d'entre eux, on ajoute autant de fois que n\u00e9cessaire leur valeur dans nombres_tries le nombre d'ajout \u00e0 faire est donn\u00e9 par l'effectif du nombre : effectif[n] Comme on a cr\u00e9\u00e9 une nouvelle liste pour stocker les valeurs tri\u00e9es, on la renvoie \u00e0 la fin. Remarques : Avec Python, il est possible \u00e0 l'aide de enumerate de parcourir une liste en r\u00e9cup\u00e9rant \u00e0 chaque it\u00e9ration les couples (indice, valeur) . En utilisant cette technique le boucle principale deviendrait : \ud83d\udc0d Script Python for n , eff in enumerate ( effectifs ): for _ in range ( eff ): nombres_tries . append ( n ) Une version en place du tri va r\u00e9\u00e9crire les valeurs tri\u00e9es directement dans la liste de d\u00e9part. Pour ce faire, il faut garder trace de l'indice o\u00f9 l'on doit \u00e9crire la prochaine valeur : \ud83d\udc0d Script Python def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 rang = 0 for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres [ rang ] = n return nombres On renvoie la liste nombres afin de rester dans le cadre de l'\u00e9nonc\u00e9 mais ce n'est ici pas indispensable. On utilise ici une version de l'algorithme utilisant un tableau (un liste avec Python) pour stocker les effectifs. Comme mentionn\u00e9 plus haut cette approche est peu efficace dans certains cas en termes d'utilisation de la m\u00e9moire. On pourrait de fa\u00e7on plus efficace utiliser un dictionnaire Python. Dans ce cas, il est inutile de rechercher le maximum et le code devient : \ud83d\udc0d Script Python def tri_denombrement_dico ( nombres ): effectifs = {} for nb in nombres : if nb in effectifs : effectifs [ nb ] += 1 else : effectifs [ nb ] = 1 nombres_tries = [] for n in effectifs : for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries \ud83d\udccb Texte * En utilisant la m\u00e9thode `items` des dictionnaire qui renvoie les couples `(cl\u00e9, valeur)` on pourrait m\u00eame faire :","title":"Commentaires"},{"location":"2-moyen/tri_denombrement/exo_REM/#commentaires","text":"Il s'agit d'un tri original car de complexit\u00e9 lin\u00e9aire. Avantageux sur ce point, il l'est moins sur les deux point suivants : cet algorithme ne s'applique qu'aux valeurs enti\u00e8res positives ou nulles il n\u00e9cessite de cr\u00e9er un tableau annexe contenant les effectifs ce qui peut consommer de la m\u00e9moire (imaginez le tri d'un tableau des deux nombres 0 et 1000 : le tableau effectifs contient 1001 cellules !) \ud83d\udc0d Script Python def maximum ( nombres ): maxi = 0 for nb in nombres : if nb > maxi : maxi = nb return maxi def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 nombres_tries = [] for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries La fonction maximum est classique : on initialise le maximum \u00e0 0 puis on lit l'ensemble des valeurs. Pour la fonction tri_denombrement : on commence par chercher la valeur maximale on cr\u00e9e ensuite le tableau effectifs contenant maximum + 1 fois le nombre 0 on lit ensuite l'ensemble des valeurs de nombres et on incr\u00e9mente la cellule effectifs[nb] correspondante on cr\u00e9e une liste vide nombres_tries on remplit cette liste vide : on parcourt tous les entiers n entre 0 et maxi pour chacun d'entre eux, on ajoute autant de fois que n\u00e9cessaire leur valeur dans nombres_tries le nombre d'ajout \u00e0 faire est donn\u00e9 par l'effectif du nombre : effectif[n] Comme on a cr\u00e9\u00e9 une nouvelle liste pour stocker les valeurs tri\u00e9es, on la renvoie \u00e0 la fin. Remarques : Avec Python, il est possible \u00e0 l'aide de enumerate de parcourir une liste en r\u00e9cup\u00e9rant \u00e0 chaque it\u00e9ration les couples (indice, valeur) . En utilisant cette technique le boucle principale deviendrait : \ud83d\udc0d Script Python for n , eff in enumerate ( effectifs ): for _ in range ( eff ): nombres_tries . append ( n ) Une version en place du tri va r\u00e9\u00e9crire les valeurs tri\u00e9es directement dans la liste de d\u00e9part. Pour ce faire, il faut garder trace de l'indice o\u00f9 l'on doit \u00e9crire la prochaine valeur : \ud83d\udc0d Script Python def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 rang = 0 for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres [ rang ] = n return nombres On renvoie la liste nombres afin de rester dans le cadre de l'\u00e9nonc\u00e9 mais ce n'est ici pas indispensable. On utilise ici une version de l'algorithme utilisant un tableau (un liste avec Python) pour stocker les effectifs. Comme mentionn\u00e9 plus haut cette approche est peu efficace dans certains cas en termes d'utilisation de la m\u00e9moire. On pourrait de fa\u00e7on plus efficace utiliser un dictionnaire Python. Dans ce cas, il est inutile de rechercher le maximum et le code devient : \ud83d\udc0d Script Python def tri_denombrement_dico ( nombres ): effectifs = {} for nb in nombres : if nb in effectifs : effectifs [ nb ] += 1 else : effectifs [ nb ] = 1 nombres_tries = [] for n in effectifs : for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries \ud83d\udccb Texte * En utilisant la m\u00e9thode `items` des dictionnaire qui renvoie les couples `(cl\u00e9, valeur)` on pourrait m\u00eame faire :","title":"Commentaires"},{"location":"2-moyen/tri_denombrement/sujet/","text":"tri extremum Tri par d\u00e9nombrement \u2693\ufe0e Dans cet exercice on s'interdit d'utiliser max , sort et sorted On souhaite dans cet exercice trier des tableaux de nombres entiers positifs ou nuls. Les tableaux seront repr\u00e9sent\u00e9s par des listes Python. Pour ce faire on utilise l'algorithme du tri par d\u00e9nombrement . Ls \u00e9tapes de cet algorithme sont les suivantes : d\u00e9terminer la valeur maximale dans la tableau nombres cr\u00e9er une tableau effectifs contenant les effectifs dans le tableau initial de tous les entiers entre 0 et le maximum cr\u00e9er une nouvelle liste vide parcourir le tableau effectifs et ajouter autant de fois que n\u00e9cessaire chaque indice dans la nouvelle liste Lors de la derni\u00e8re \u00e9tape, si l'effectif \u00e0 l'indice 3 vaut 2, cela signifie que la valeur 3 est pr\u00e9sente 2 fois dans le tableau initial : on l'ajoute donc 2 fois dans la nouvelle liste. Exemple On souhaite trier le tableau nombres [4, 5, 4, 2] : La valeur maximale est 5 Le tableau effectifs est : indices 0 1 2 3 4 5 effectifs 0 0 1 0 2 1 Ce tableau comporte bien 6 valeurs Le 1 \u00e0 l'indice 2 signifie que le nombre 2 appara\u00eet 1 fois dans le tableau On cr\u00e9e une liste vide On parcourt effectifs : \u00e0 l'indice 0 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 1 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 2 on trouve l'effectif 1 : on ajoute 1 fois le nombre 2 dans la liste \u00e0 l'indice 3 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 4 on trouve l'effectif 2 : on ajoute 2 fois le nombre 4 dans la liste \u00e0 l'indice 5 on trouve l'effectif 1 : on ajoute 1 fois le nombre 5 dans la liste Comme on cr\u00e9e une nouvelle liste de nombres tri\u00e9s, on n'oubliera pas de renvoyer celle-ci \u00e0 la fin du tri. Remarque Il est aussi possible d'\u00e9crire les valeurs tri\u00e9es par dessus la liste de d\u00e9part au lieu de cr\u00e9er une nouvelle liste. Afin de r\u00e9ussir les tests propos\u00e9s dans cet exercice on prendra quand-m\u00eame soin de renvoyer la liste modifi\u00e9e . Vous devez \u00e9crire deux fonctions : maximum prend en argument une liste de nombres et renvoie la valeur maximale dans celle-ci tri_denombrement prend en argument une liste de nombres et la trie en appliquant l'algorithme d\u00e9crit plus haut. Cette fonction renverra une liste contenant les m\u00eames valeurs tri\u00e9es dans l'ordre croissant Exemples \ud83d\udc0d Console Python >>> liste = [ 4 , 5 , 4 , 2 ] >>> assert tri_denombrement ( liste ) == [ 2 , 4 , 4 , 5 ] >>> liste = [ 5 , 4 , 3 , 2 , 1 ] >>> assert tri_denombrement ( liste ) == [ 1 , 2 , 3 , 4 , 5 ] >>> liste = [] >>> assert tri_denombrement ( liste ) == [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlineassert tripython-underscoredenombrement(liste) == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlineassert tripython-underscoredenombrement(liste) == []backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineliste = [4, 4, 4]backslash-newlineassert tripython-underscoredenombrement(liste) == [4, 4, 4]backslash-newlineliste = [k for k in range(100, -1, -1)]backslash-newlineassert tripython-underscoredenombrement(liste) == list(range(101))backslash-newlineliste = [1, 2]python-star10backslash-newlineassert tripython-underscoredenombrement(liste) == [1]python-star10+[2]python-star10backslash-newlineliste = [10python-starpython-star3, 0]backslash-newlineassert tripython-underscoredenombrement(liste) == [0, 10python-starpython-star3]backslash-newline Valider 5/5 def maximum(nombres):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinedef tripython-underscoredenombrement(nombres):backslash-newline maxi = ...backslash-newlinebackslash-newline effectifs = [0] python-star (maxi + 1)backslash-newlinebackslash-newline for nb in nombres:backslash-newline ...backslash-newlinebackslash-newline # On cr\u00c3\u00a9e une nouvelle listebackslash-newline # pour stocker les nombres tri\u00c3\u00a9sbackslash-newline nombrespython-underscoretries = []backslash-newline for n in range(maxi + 1):backslash-newline for i in ...:backslash-newline ...backslash-newlinebackslash-newline return nombrespython-underscoretriesbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == []backslash-newlinebackslash-newline def maximum(nombres):backslash-newline maxi = 0backslash-newline for nb in nombres:backslash-newline if nb > maxi:backslash-newline maxi = nbbackslash-newline return maxibackslash-newlinebackslash-newlinebackslash-newlinedef tripython-underscoredenombrement(nombres):backslash-newline maxi = maximum(nombres)backslash-newlinebackslash-newline effectifs = [0] python-star (maxi + 1)backslash-newlinebackslash-newline for nb in nombres:backslash-newline effectifs[nb] += 1backslash-newlinebackslash-newline nombrespython-underscoretries = []backslash-newline for n in range(maxi + 1):backslash-newline for i in range(effectifs[n]):backslash-newline nombrespython-underscoretries.append(n)backslash-newlinebackslash-newline return nombrespython-underscoretriesbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlineassert tripython-underscoredenombrement(liste) == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlineassert tripython-underscoredenombrement(liste) == []backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineliste = [4, 4, 4]backslash-newlineassert tripython-underscoredenombrement(liste) == [4, 4, 4]backslash-newlineliste = [k for k in range(100, -1, -1)]backslash-newlineassert tripython-underscoredenombrement(liste) == list(range(101))backslash-newlineliste = [1, 2]python-star10backslash-newlineassert tripython-underscoredenombrement(liste) == [1]python-star10+[2]python-star10backslash-newlineliste = [10python-starpython-star3, 0]backslash-newlineassert tripython-underscoredenombrement(liste) == [0, 10python-starpython-star3]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Il s'agit d'un tri original car de complexit\u00e9 lin\u00e9aire. Avantageux sur ce point, il l'est moins sur les deux point suivants : cet algorithme ne s'applique qu'aux valeurs enti\u00e8res positives ou nulles il n\u00e9cessite de cr\u00e9er un tableau annexe contenant les effectifs ce qui peut consommer de la m\u00e9moire (imaginez le tri d'un tableau des deux nombres 0 et 1000 : le tableau effectifs contient 1001 cellules !) {{ py('exo_corr', 0, '# TESTS') }} La fonction maximum est classique : on initialise le maximum \u00e0 0 puis on lit l'ensemble des valeurs. Pour la fonction tri_denombrement : on commence par chercher la valeur maximale on cr\u00e9e ensuite le tableau effectifs contenant maximum + 1 fois le nombre 0 on lit ensuite l'ensemble des valeurs de nombres et on incr\u00e9mente la cellule effectifs[nb] correspondante on cr\u00e9e une liste vide nombres_tries on remplit cette liste vide : on parcourt tous les entiers n entre 0 et maxi pour chacun d'entre eux, on ajoute autant de fois que n\u00e9cessaire leur valeur dans nombres_tries le nombre d'ajout \u00e0 faire est donn\u00e9 par l'effectif du nombre : effectif[n] Comme on a cr\u00e9\u00e9 une nouvelle liste pour stocker les valeurs tri\u00e9es, on la renvoie \u00e0 la fin. Remarques : Avec Python, il est possible \u00e0 l'aide de enumerate de parcourir une liste en r\u00e9cup\u00e9rant \u00e0 chaque it\u00e9ration les couples (indice, valeur) . En utilisant cette technique le boucle principale deviendrait : \ud83d\udc0d Script Python for n , eff in enumerate ( effectifs ): for _ in range ( eff ): nombres_tries . append ( n ) Une version en place du tri va r\u00e9\u00e9crire les valeurs tri\u00e9es directement dans la liste de d\u00e9part. Pour ce faire, il faut garder trace de l'indice o\u00f9 l'on doit \u00e9crire la prochaine valeur : \ud83d\udc0d Script Python def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 rang = 0 for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres [ rang ] = n return nombres On renvoie la liste nombres afin de rester dans le cadre de l'\u00e9nonc\u00e9 mais ce n'est ici pas indispensable. On utilise ici une version de l'algorithme utilisant un tableau (un liste avec Python) pour stocker les effectifs. Comme mentionn\u00e9 plus haut cette approche est peu efficace dans certains cas en termes d'utilisation de la m\u00e9moire. On pourrait de fa\u00e7on plus efficace utiliser un dictionnaire Python. Dans ce cas, il est inutile de rechercher le maximum et le code devient : \ud83d\udc0d Script Python def tri_denombrement_dico ( nombres ): effectifs = {} for nb in nombres : if nb in effectifs : effectifs [ nb ] += 1 else : effectifs [ nb ] = 1 nombres_tries = [] for n in effectifs : for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries \ud83d\udccb Texte * En utilisant la m\u00e9thode `items` des dictionnaire qui renvoie les couples `(cl\u00e9, valeur)` on pourrait m\u00eame faire : Z","title":"Tri par d\u00e9nombrement"},{"location":"2-moyen/tri_denombrement/sujet/#tri-par-denombrement","text":"Dans cet exercice on s'interdit d'utiliser max , sort et sorted On souhaite dans cet exercice trier des tableaux de nombres entiers positifs ou nuls. Les tableaux seront repr\u00e9sent\u00e9s par des listes Python. Pour ce faire on utilise l'algorithme du tri par d\u00e9nombrement . Ls \u00e9tapes de cet algorithme sont les suivantes : d\u00e9terminer la valeur maximale dans la tableau nombres cr\u00e9er une tableau effectifs contenant les effectifs dans le tableau initial de tous les entiers entre 0 et le maximum cr\u00e9er une nouvelle liste vide parcourir le tableau effectifs et ajouter autant de fois que n\u00e9cessaire chaque indice dans la nouvelle liste Lors de la derni\u00e8re \u00e9tape, si l'effectif \u00e0 l'indice 3 vaut 2, cela signifie que la valeur 3 est pr\u00e9sente 2 fois dans le tableau initial : on l'ajoute donc 2 fois dans la nouvelle liste. Exemple On souhaite trier le tableau nombres [4, 5, 4, 2] : La valeur maximale est 5 Le tableau effectifs est : indices 0 1 2 3 4 5 effectifs 0 0 1 0 2 1 Ce tableau comporte bien 6 valeurs Le 1 \u00e0 l'indice 2 signifie que le nombre 2 appara\u00eet 1 fois dans le tableau On cr\u00e9e une liste vide On parcourt effectifs : \u00e0 l'indice 0 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 1 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 2 on trouve l'effectif 1 : on ajoute 1 fois le nombre 2 dans la liste \u00e0 l'indice 3 on trouve l'effectif 0 : on ne fait rien \u00e0 l'indice 4 on trouve l'effectif 2 : on ajoute 2 fois le nombre 4 dans la liste \u00e0 l'indice 5 on trouve l'effectif 1 : on ajoute 1 fois le nombre 5 dans la liste Comme on cr\u00e9e une nouvelle liste de nombres tri\u00e9s, on n'oubliera pas de renvoyer celle-ci \u00e0 la fin du tri. Remarque Il est aussi possible d'\u00e9crire les valeurs tri\u00e9es par dessus la liste de d\u00e9part au lieu de cr\u00e9er une nouvelle liste. Afin de r\u00e9ussir les tests propos\u00e9s dans cet exercice on prendra quand-m\u00eame soin de renvoyer la liste modifi\u00e9e . Vous devez \u00e9crire deux fonctions : maximum prend en argument une liste de nombres et renvoie la valeur maximale dans celle-ci tri_denombrement prend en argument une liste de nombres et la trie en appliquant l'algorithme d\u00e9crit plus haut. Cette fonction renverra une liste contenant les m\u00eames valeurs tri\u00e9es dans l'ordre croissant Exemples \ud83d\udc0d Console Python >>> liste = [ 4 , 5 , 4 , 2 ] >>> assert tri_denombrement ( liste ) == [ 2 , 4 , 4 , 5 ] >>> liste = [ 5 , 4 , 3 , 2 , 1 ] >>> assert tri_denombrement ( liste ) == [ 1 , 2 , 3 , 4 , 5 ] >>> liste = [] >>> assert tri_denombrement ( liste ) == [] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlineassert tripython-underscoredenombrement(liste) == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlineassert tripython-underscoredenombrement(liste) == []backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineliste = [4, 4, 4]backslash-newlineassert tripython-underscoredenombrement(liste) == [4, 4, 4]backslash-newlineliste = [k for k in range(100, -1, -1)]backslash-newlineassert tripython-underscoredenombrement(liste) == list(range(101))backslash-newlineliste = [1, 2]python-star10backslash-newlineassert tripython-underscoredenombrement(liste) == [1]python-star10+[2]python-star10backslash-newlineliste = [10python-starpython-star3, 0]backslash-newlineassert tripython-underscoredenombrement(liste) == [0, 10python-starpython-star3]backslash-newline Valider 5/5 def maximum(nombres):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinedef tripython-underscoredenombrement(nombres):backslash-newline maxi = ...backslash-newlinebackslash-newline effectifs = [0] python-star (maxi + 1)backslash-newlinebackslash-newline for nb in nombres:backslash-newline ...backslash-newlinebackslash-newline # On cr\u00c3\u00a9e une nouvelle listebackslash-newline # pour stocker les nombres tri\u00c3\u00a9sbackslash-newline nombrespython-underscoretries = []backslash-newline for n in range(maxi + 1):backslash-newline for i in ...:backslash-newline ...backslash-newlinebackslash-newline return nombrespython-underscoretriesbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlinetripython-underscoredenombrement(liste)backslash-newlineassert liste == []backslash-newlinebackslash-newline def maximum(nombres):backslash-newline maxi = 0backslash-newline for nb in nombres:backslash-newline if nb > maxi:backslash-newline maxi = nbbackslash-newline return maxibackslash-newlinebackslash-newlinebackslash-newlinedef tripython-underscoredenombrement(nombres):backslash-newline maxi = maximum(nombres)backslash-newlinebackslash-newline effectifs = [0] python-star (maxi + 1)backslash-newlinebackslash-newline for nb in nombres:backslash-newline effectifs[nb] += 1backslash-newlinebackslash-newline nombrespython-underscoretries = []backslash-newline for n in range(maxi + 1):backslash-newline for i in range(effectifs[n]):backslash-newline nombrespython-underscoretries.append(n)backslash-newlinebackslash-newline return nombrespython-underscoretriesbackslash-newlinebackslash-newlinebackslash-newline# Testsbackslash-newlineliste = [4, 5, 4, 2]backslash-newlineassert tripython-underscoredenombrement(liste) == [2, 4, 4, 5]backslash-newlineliste = [3, 8, 7, 3, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [3, 3, 5, 7, 8]backslash-newlineliste = [1, 2, 3, 4, 5]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = [5, 4, 3, 2, 1]backslash-newlineassert tripython-underscoredenombrement(liste) == [1, 2, 3, 4, 5]backslash-newlineliste = []backslash-newlineassert tripython-underscoredenombrement(liste) == []backslash-newlinebackslash-newline# Tests suppl\u00c3\u00a9mentairesbackslash-newlineliste = [4, 4, 4]backslash-newlineassert tripython-underscoredenombrement(liste) == [4, 4, 4]backslash-newlineliste = [k for k in range(100, -1, -1)]backslash-newlineassert tripython-underscoredenombrement(liste) == list(range(101))backslash-newlineliste = [1, 2]python-star10backslash-newlineassert tripython-underscoredenombrement(liste) == [1]python-star10+[2]python-star10backslash-newlineliste = [10python-starpython-star3, 0]backslash-newlineassert tripython-underscoredenombrement(liste) == [0, 10python-starpython-star3]backslash-newlinebackslash-newline A","title":"Tri par d\u00e9nombrement"},{"location":"2-moyen/tri_denombrement/sujet/#commentaires","text":"Il s'agit d'un tri original car de complexit\u00e9 lin\u00e9aire. Avantageux sur ce point, il l'est moins sur les deux point suivants : cet algorithme ne s'applique qu'aux valeurs enti\u00e8res positives ou nulles il n\u00e9cessite de cr\u00e9er un tableau annexe contenant les effectifs ce qui peut consommer de la m\u00e9moire (imaginez le tri d'un tableau des deux nombres 0 et 1000 : le tableau effectifs contient 1001 cellules !) {{ py('exo_corr', 0, '# TESTS') }} La fonction maximum est classique : on initialise le maximum \u00e0 0 puis on lit l'ensemble des valeurs. Pour la fonction tri_denombrement : on commence par chercher la valeur maximale on cr\u00e9e ensuite le tableau effectifs contenant maximum + 1 fois le nombre 0 on lit ensuite l'ensemble des valeurs de nombres et on incr\u00e9mente la cellule effectifs[nb] correspondante on cr\u00e9e une liste vide nombres_tries on remplit cette liste vide : on parcourt tous les entiers n entre 0 et maxi pour chacun d'entre eux, on ajoute autant de fois que n\u00e9cessaire leur valeur dans nombres_tries le nombre d'ajout \u00e0 faire est donn\u00e9 par l'effectif du nombre : effectif[n] Comme on a cr\u00e9\u00e9 une nouvelle liste pour stocker les valeurs tri\u00e9es, on la renvoie \u00e0 la fin. Remarques : Avec Python, il est possible \u00e0 l'aide de enumerate de parcourir une liste en r\u00e9cup\u00e9rant \u00e0 chaque it\u00e9ration les couples (indice, valeur) . En utilisant cette technique le boucle principale deviendrait : \ud83d\udc0d Script Python for n , eff in enumerate ( effectifs ): for _ in range ( eff ): nombres_tries . append ( n ) Une version en place du tri va r\u00e9\u00e9crire les valeurs tri\u00e9es directement dans la liste de d\u00e9part. Pour ce faire, il faut garder trace de l'indice o\u00f9 l'on doit \u00e9crire la prochaine valeur : \ud83d\udc0d Script Python def tri_denombrement ( nombres ): maxi = maximum ( nombres ) effectifs = [ 0 ] * ( maxi + 1 ) for nb in nombres : effectifs [ nb ] += 1 rang = 0 for n in range ( maxi + 1 ): for i in range ( effectifs [ n ]): nombres [ rang ] = n return nombres On renvoie la liste nombres afin de rester dans le cadre de l'\u00e9nonc\u00e9 mais ce n'est ici pas indispensable. On utilise ici une version de l'algorithme utilisant un tableau (un liste avec Python) pour stocker les effectifs. Comme mentionn\u00e9 plus haut cette approche est peu efficace dans certains cas en termes d'utilisation de la m\u00e9moire. On pourrait de fa\u00e7on plus efficace utiliser un dictionnaire Python. Dans ce cas, il est inutile de rechercher le maximum et le code devient : \ud83d\udc0d Script Python def tri_denombrement_dico ( nombres ): effectifs = {} for nb in nombres : if nb in effectifs : effectifs [ nb ] += 1 else : effectifs [ nb ] = 1 nombres_tries = [] for n in effectifs : for i in range ( effectifs [ n ]): nombres_tries . append ( n ) return nombres_tries \ud83d\udccb Texte * En utilisant la m\u00e9thode `items` des dictionnaire qui renvoie les couples `(cl\u00e9, valeur)` on pourrait m\u00eame faire : Z","title":"Commentaires"},{"location":"2-moyen/tri_insertion/sujet/","text":"La m\u00e9thode du tri par insertion repose sur un double parcours de la liste \u00e0 trier : un parcours de gauche \u00e0 droite en commen\u00e7ant au deuxi\u00e8me \u00e9l\u00e9ment donne un indice \\(i\\) . On a la garantie que la liste jusqu'\u00e0 l'indice \\(i\\) exclu est tri\u00e9e ; on va parcourir de droite \u00e0 gauche la portion de liste \u00e0 gauche de \\(i\\) pour y ins\u00e9rer \u00e0 la bonne place l'\u00e9l\u00e9ment d'indice \\(i\\) La fonction tri_insertion suivante prend en argument un tableau d' entiers et trie ce tableau en utilisant la m\u00e9thode du tri par insertion. Il s'agit d'un tri en place, comme on l'a vu. Compl\u00e9ter cette fonction pour qu'elle r\u00e9ponde \u00e0 la sp\u00e9cification demand\u00e9e. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinetableaupython-underscore0 = [9, 5, 8, 7, 6] backslash-newlinetripython-underscoreinsertion(tableaupython-underscore0)backslash-newlineassert tableaupython-underscore0 == [5, 6, 7, 8, 9]backslash-newlinebackslash-newlinetableaupython-underscore1 = [2, 5, -1, 7, 0, 28]backslash-newlinetripython-underscoreinsertion(tableaupython-underscore1)backslash-newlineassert tableaupython-underscore1 == [-1, 0, 2, 5, 7, 28]backslash-newlinebackslash-newlinetableaupython-underscore2 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]backslash-newlinetripython-underscoreinsertion(tableaupython-underscore2)backslash-newlineassert tableaupython-underscore2 == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineunpython-underscoreseul = [9]backslash-newlinetripython-underscoreinsertion(unpython-underscoreseul)backslash-newlineassert unpython-underscoreseul == [9]backslash-newlinebackslash-newlinetableaupython-underscorevide = []backslash-newlinetripython-underscoreinsertion(tableaupython-underscorevide)backslash-newlineassert tableaupython-underscorevide == []backslash-newlinebackslash-newline# Autres testsbackslash-newlinebackslash-newlinefrom random import samplebackslash-newlinefor i in range(10):backslash-newline nombres = list(sample(range(10python-starpython-star9), 100+i))backslash-newline attendu = sorted(nombres)backslash-newline tripython-underscoreinsertion(nombres)backslash-newline assert len(nombres) == len(attendu), \"Erreur, le tableau ne doit pas changer de taille\"backslash-newline assert nombres == attendu, \"Erreur lors du tri\"backslash-newlinebackslash-newline Valider 5/5 backslash-newlinedef tripython-underscoreinsertion(entiers):backslash-newline n = len(entiers)backslash-newline for i in range(1, n):backslash-newline j = ...backslash-newline valeurpython-underscoreapython-underscoreinserer = entiers[...]backslash-newline while j > ... and valeurpython-underscoreapython-underscoreinserer < entiers[...]:backslash-newline entiers[j] = entiers[j-1]backslash-newline j = ...backslash-newline entiers[j] = ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinetableaupython-underscore0 = [9, 5, 8, 7, 6] backslash-newlinetripython-underscoreinsertion(tableaupython-underscore0)backslash-newlineassert tableaupython-underscore0 == [5, 6, 7, 8, 9]backslash-newlinebackslash-newlinetableaupython-underscore1 = [2, 5, -1, 7, 0, 28]backslash-newlinetripython-underscoreinsertion(tableaupython-underscore1)backslash-newlineassert tableaupython-underscore1 == [-1, 0, 2, 5, 7, 28]backslash-newlinebackslash-newlinetableaupython-underscore2 = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]backslash-newlinetripython-underscoreinsertion(tableaupython-underscore2)backslash-newlinetableaupython-underscore2 == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]backslash-newlinebackslash-newlineunpython-underscoreseul = [9]backslash-newlinetripython-underscoreinsertion(unpython-underscoreseul)backslash-newlineassert unpython-underscoreseul == [9]backslash-newlinebackslash-newlinetableaupython-underscorevide = []backslash-newlinetripython-underscoreinsertion(tableaupython-underscorevide)backslash-newlineassert tableaupython-underscorevide == []backslash-newlinebackslash-newline def tripython-underscoreinsertion(entiers):backslash-newline n = len(entiers)backslash-newline for i in range(1, n):backslash-newline j = ibackslash-newline valeurpython-underscoreapython-underscoreinserer = entiers[i]backslash-newline while j > 0 and valeurpython-underscoreapython-underscoreinserer < entiers[j - 1]:backslash-newline entiers[j] = entiers[j - 1]backslash-newline j = j - 1backslash-newline entiers[j] = valeurpython-underscoreapython-underscoreinsererbackslash-newlinebackslash-newline A Z","title":"Tri pas insertion"},{"location":"2-moyen/tri_pascal/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , n + 1 ): ligne_k = [ 1 ] for i in range ( 1 , k ): ligne_k . append ( triangle [ k - 1 ][ i - 1 ] + triangle [ k - 1 ][ i ]) ligne_k . append ( 1 ) triangle . append ( ligne_k ) return triangle On travaille par accumulation de lignes \u00e0 partir de la liste [[1]] qui contient la ligne 0 qui ne contient qu'un \u00e9l\u00e9ment. On fait faire \\(n\\) tours de boucles pour ajouter les lignes \\(1\\) incluse \u00e0 \\(n+1\\) exclue. Pour chaque ligne, le premier, comme le dernier terme sont ajout\u00e9s individuellement ; il s'agit de \\(1\\) . Les autres termes sont calcul\u00e9s en suivant la formule donn\u00e9e. Il faut faire attention aux indices. On calcule la ligne \\(k\\) , on utilise donc les coefficients de la ligne \\(k-1\\) . Ceux aux indices \\(i-1\\) et \\(i\\) ; au premier tour de boucle interne \\(i=1\\) , et on ajoute bien les termes d'indice 0 et 1.","title":"Commentaires"},{"location":"2-moyen/tri_pascal/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , n + 1 ): ligne_k = [ 1 ] for i in range ( 1 , k ): ligne_k . append ( triangle [ k - 1 ][ i - 1 ] + triangle [ k - 1 ][ i ]) ligne_k . append ( 1 ) triangle . append ( ligne_k ) return triangle On travaille par accumulation de lignes \u00e0 partir de la liste [[1]] qui contient la ligne 0 qui ne contient qu'un \u00e9l\u00e9ment. On fait faire \\(n\\) tours de boucles pour ajouter les lignes \\(1\\) incluse \u00e0 \\(n+1\\) exclue. Pour chaque ligne, le premier, comme le dernier terme sont ajout\u00e9s individuellement ; il s'agit de \\(1\\) . Les autres termes sont calcul\u00e9s en suivant la formule donn\u00e9e. Il faut faire attention aux indices. On calcule la ligne \\(k\\) , on utilise donc les coefficients de la ligne \\(k-1\\) . Ceux aux indices \\(i-1\\) et \\(i\\) ; au premier tour de boucle interne \\(i=1\\) , et on ajoute bien les termes d'indice 0 et 1.","title":"Commentaires"},{"location":"2-moyen/tri_pascal/sujet/","tags":["a_trou","maths","boucle"],"text":"Le triangle de Pascal \u2693\ufe0e On cherche \u00e0 construire le triangle de Pascal. Le triangle de Pascal Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre \\(1\\) . Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l'int\u00e9rieur du tableau s'obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus et au-dessus \u00e0 gauche, comme l'indique la figure suivante : Colonnes : 0 1 2 3 4 5 ligne 0 : \\(1\\) ligne 1 : \\(1\\) \\(1\\) ligne 2 : \\(1\\) \\(2\\) \\(1\\) ligne 3 : \\(1\\) \\(3\\) \\(3\\) \\(1\\) ligne 4 : \\(1\\) \\(4\\) \\(\\mathbf{6}\\) \\(\\mathbf{4}\\) \\(1\\) ligne 5 : \\(1\\) \\(5\\) \\(10\\) \\(\\mathbf{10}\\) \\(5\\) \\(1\\) Le second \\(10\\) s'obtient avec \\(6\\) en haut \u00e0 gauche, plus \\(4\\) juste au-dessus ; comme pour tous les nombres du tableau, sauf les \\(1\\) qui sont plac\u00e9s par d\u00e9finition. Objectif : \u00c9crire une fonction telle que pascal(n) renvoie la liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne n . Il y a \\((n+1)\\) lignes. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , ... ): ligne_k = [ ... ] for i in range ( 1 , k ): ligne_k . append ( triangle [ ... ][ i - 1 ] + triangle [ ... ][ ... ]) ligne_k . append ( ... ) triangle . append ( ligne_k ) return triangle Exemples \ud83d\udc0d Console Python >>> pascal ( 4 ) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> pascal ( 5 ) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert pascal(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]backslash-newlineassert pascal(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert pascal(0) == [[1]]backslash-newlineassert pascal(1) == [[1], [1, 1]]backslash-newlineassert pascal(10) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]]backslash-newlinebackslash-newline Valider 5/5 def pascal(n):backslash-newline triangle = [[1]]backslash-newline for k in range(1, ...):backslash-newline lignepython-underscorek = [...]backslash-newline for i in range(1, k):backslash-newline lignepython-underscorek.append(triangle[...][i - 1] + triangle[...][...])backslash-newline lignepython-underscorek.append(...)backslash-newline triangle.append(lignepython-underscorek)backslash-newline return trianglebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert pascal(4) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline]backslash-newlinebackslash-newlinebackslash-newlineassert pascal(5) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline [1, 5, 10, 10, 5, 1],backslash-newline]backslash-newlinebackslash-newline def pascal(n):backslash-newline triangle = [[1]]backslash-newline for k in range(1, n + 1):backslash-newline lignepython-underscorek = [1]backslash-newline for i in range(1, k):backslash-newline lignepython-underscorek.append(triangle[k - 1][i - 1] + triangle[k - 1][i])backslash-newline lignepython-underscorek.append(1)backslash-newline triangle.append(lignepython-underscorek)backslash-newline return trianglebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert pascal(4) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline]backslash-newlinebackslash-newlinebackslash-newlineassert pascal(5) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline [1, 5, 10, 10, 5, 1],backslash-newline]backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} On travaille par accumulation de lignes \u00e0 partir de la liste [[1]] qui contient la ligne 0 qui ne contient qu'un \u00e9l\u00e9ment. On fait faire \\(n\\) tours de boucles pour ajouter les lignes \\(1\\) incluse \u00e0 \\(n+1\\) exclue. Pour chaque ligne, le premier, comme le dernier terme sont ajout\u00e9s individuellement ; il s'agit de \\(1\\) . Les autres termes sont calcul\u00e9s en suivant la formule donn\u00e9e. Il faut faire attention aux indices. On calcule la ligne \\(k\\) , on utilise donc les coefficients de la ligne \\(k-1\\) . Ceux aux indices \\(i-1\\) et \\(i\\) ; au premier tour de boucle interne \\(i=1\\) , et on ajoute bien les termes d'indice 0 et 1. Z","title":"Triangle de Pascal"},{"location":"2-moyen/tri_pascal/sujet/#le-triangle-de-pascal","text":"On cherche \u00e0 construire le triangle de Pascal. Le triangle de Pascal Dans ce tableau de forme triangulaire, chaque ligne commence et se termine par le nombre \\(1\\) . Par ailleurs, la valeur qui occupe une case situ\u00e9e \u00e0 l'int\u00e9rieur du tableau s'obtient en ajoutant les valeurs des deux cases situ\u00e9es juste au-dessus et au-dessus \u00e0 gauche, comme l'indique la figure suivante : Colonnes : 0 1 2 3 4 5 ligne 0 : \\(1\\) ligne 1 : \\(1\\) \\(1\\) ligne 2 : \\(1\\) \\(2\\) \\(1\\) ligne 3 : \\(1\\) \\(3\\) \\(3\\) \\(1\\) ligne 4 : \\(1\\) \\(4\\) \\(\\mathbf{6}\\) \\(\\mathbf{4}\\) \\(1\\) ligne 5 : \\(1\\) \\(5\\) \\(10\\) \\(\\mathbf{10}\\) \\(5\\) \\(1\\) Le second \\(10\\) s'obtient avec \\(6\\) en haut \u00e0 gauche, plus \\(4\\) juste au-dessus ; comme pour tous les nombres du tableau, sauf les \\(1\\) qui sont plac\u00e9s par d\u00e9finition. Objectif : \u00c9crire une fonction telle que pascal(n) renvoie la liste correspondant au triangle de Pascal de la ligne 0 \u00e0 la ligne n . Il y a \\((n+1)\\) lignes. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python def pascal ( n ): triangle = [[ 1 ]] for k in range ( 1 , ... ): ligne_k = [ ... ] for i in range ( 1 , k ): ligne_k . append ( triangle [ ... ][ i - 1 ] + triangle [ ... ][ ... ]) ligne_k . append ( ... ) triangle . append ( ligne_k ) return triangle Exemples \ud83d\udc0d Console Python >>> pascal ( 4 ) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]] >>> pascal ( 5 ) [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlineassert pascal(4) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]backslash-newlineassert pascal(5) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1]]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert pascal(0) == [[1]]backslash-newlineassert pascal(1) == [[1], [1, 1]]backslash-newlineassert pascal(10) == [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1], [1, 9, 36, 84, 126, 126, 84, 36, 9, 1], [1, 10, 45, 120, 210, 252, 210, 120, 45, 10, 1]]backslash-newlinebackslash-newline Valider 5/5 def pascal(n):backslash-newline triangle = [[1]]backslash-newline for k in range(1, ...):backslash-newline lignepython-underscorek = [...]backslash-newline for i in range(1, k):backslash-newline lignepython-underscorek.append(triangle[...][i - 1] + triangle[...][...])backslash-newline lignepython-underscorek.append(...)backslash-newline triangle.append(lignepython-underscorek)backslash-newline return trianglebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert pascal(4) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline]backslash-newlinebackslash-newlinebackslash-newlineassert pascal(5) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline [1, 5, 10, 10, 5, 1],backslash-newline]backslash-newlinebackslash-newline def pascal(n):backslash-newline triangle = [[1]]backslash-newline for k in range(1, n + 1):backslash-newline lignepython-underscorek = [1]backslash-newline for i in range(1, k):backslash-newline lignepython-underscorek.append(triangle[k - 1][i - 1] + triangle[k - 1][i])backslash-newline lignepython-underscorek.append(1)backslash-newline triangle.append(lignepython-underscorek)backslash-newline return trianglebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert pascal(4) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline]backslash-newlinebackslash-newlinebackslash-newlineassert pascal(5) == [backslash-newline [1],backslash-newline [1, 1],backslash-newline [1, 2, 1],backslash-newline [1, 3, 3, 1],backslash-newline [1, 4, 6, 4, 1],backslash-newline [1, 5, 10, 10, 5, 1],backslash-newline]backslash-newlinebackslash-newline A","title":"Le triangle de Pascal"},{"location":"2-moyen/tri_pascal/sujet/#commentaires","text":"{{ py('exo_corr') }} On travaille par accumulation de lignes \u00e0 partir de la liste [[1]] qui contient la ligne 0 qui ne contient qu'un \u00e9l\u00e9ment. On fait faire \\(n\\) tours de boucles pour ajouter les lignes \\(1\\) incluse \u00e0 \\(n+1\\) exclue. Pour chaque ligne, le premier, comme le dernier terme sont ajout\u00e9s individuellement ; il s'agit de \\(1\\) . Les autres termes sont calcul\u00e9s en suivant la formule donn\u00e9e. Il faut faire attention aux indices. On calcule la ligne \\(k\\) , on utilise donc les coefficients de la ligne \\(k-1\\) . Ceux aux indices \\(i-1\\) et \\(i\\) ; au premier tour de boucle interne \\(i=1\\) , et on ajoute bien les termes d'indice 0 et 1. Z","title":"Commentaires"},{"location":"3-difficile/acacias/sujet/","tags":["prog.dynamique"],"text":"La communication des acacias \u2693\ufe0e M\u00e9canisme de synchronicit\u00e9 Une des observations les plus anciennes a \u00e9t\u00e9 faite sur les girafes par Wouter Van Hoven. Il a \u00e9tudi\u00e9 pendant 2 ans le comportement des girafes dans un parc national en Afrique du Sud. Les girafes ingurgitent environ 80 kg de feuilles par jour. Pourtant, lorsqu'elles arrivent sur un acacia, elles ne restent que quelques minutes, broutent que quelques feuilles puis vont vers un autre arbre. L'arbre a r\u00e9agi \u00e0 la pr\u00e9sence de la girafe en secr\u00e9tant des tanins. Ce sont des mol\u00e9cules am\u00e8res et toxiques pour les girafes. Mais en m\u00eame temps, l'acacia va \u00e9mettre de l'\u00e9thyl\u00e8ne, qui est un gaz qui va se d\u00e9placer dans l'air et informer les autres arbres qu'un pr\u00e9dateur est l\u00e0. Que vont faire les autres arbres ? Ils vont augmenter de mani\u00e8re pr\u00e9ventive leur teneur en tanin et se pr\u00e9parer \u00e0 l'arriv\u00e9e des girafes. On vous donne une liste de quantit\u00e9s de feuilles que pourrait manger une girafe sur un arbre \u00e0 un indice donn\u00e9 le long d'une ligne d'acacias. La seule contrainte, c'est que la girafe ne peut pas manger les feuilles sur deux arbres cons\u00e9cutifs, mais souhaite en manger le plus possible. \u00c9crire une fonction qui indique quelle quantit\u00e9 totale la girafe peut ingurgiter. Exemples \ud83d\udc0d Console Python >>> feuilles = [ 4 , 25 , 20 , 8 , 17 ] >>> max_manger ( feuilles ) 42 La girafe peut manger \\(25+17 = 42\\) feuilles au maximum. Prendre \\(4+20+17\\) n'en donne que \\(41\\) . \ud83d\udc0d Console Python >>> feuilles = [ 4 , 6 , 5 , 7 , 4 ] >>> max_manger ( feuilles ) 13 La girafe peut manger \\(4+5+4=13\\) ou bien \\(6+7=13\\) feuilles au maximum. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert maxpython-underscoremanger([9]) == 9backslash-newlineassert maxpython-underscoremanger([]) == 0backslash-newlinebackslash-newlinefeuilles = [0, 1] python-star 100backslash-newlineassert maxpython-underscoremanger(feuilles) == 100backslash-newlinefeuilles = [2, 1] python-star 100backslash-newlineassert maxpython-underscoremanger(feuilles) == 200backslash-newlinebackslash-newlinefeuilles = [1, 2, 1] python-star 20backslash-newlineassert maxpython-underscoremanger(feuilles) == 40backslash-newlinebackslash-newlinefeuilles = [1, 2, 3] python-star 20backslash-newlineassert maxpython-underscoremanger(feuilles) == 61backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def maxpython-underscoremanger(feuilles):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline def maxpython-underscoremanger(feuilles):backslash-newline n = len(feuilles)backslash-newline if n == 0:backslash-newline return 0backslash-newline maxipython-underscoresanspython-underscorei, maxipython-underscoreavecpython-underscorei = 0, feuilles[0]backslash-newline for i in range(1, n):backslash-newline maxipython-underscoresanspython-underscorei, maxipython-underscoreavecpython-underscorei = (backslash-newline max(maxipython-underscoreavecpython-underscorei, maxipython-underscoresanspython-underscorei),backslash-newline feuilles[i] + maxipython-underscoresanspython-underscoreibackslash-newline )backslash-newline return max(maxipython-underscoreavecpython-underscorei, maxipython-underscoresanspython-underscorei)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline A Z Indice 1 Se poser la question : \u00ab Combien peut-elle avoir mang\u00e9 au maximum \u00e0 la fin ? \u00bb C'est aussi se poser la question : \u00ab A-t-elle manger sur le dernier arbre ? \u00bb En effet, si on veut envisager une r\u00e9cursion, la question se pose... et donc r\u00e9cursivement aussi... Il faut donc envisager de savoir combien la girafe a pu manger au maximum en arrivant \u00e0 un arbre i : sans avoir mang\u00e9 sur le pr\u00e9c\u00e9dent, auquel cas elle pourra manger ici, en i en ayant mang\u00e9 au pr\u00e9c\u00e9dent, auquel cas elle ne pourra manger ici, en i Indice 2 On utilisera deux variables : maxi_sans_i : la quantit\u00e9 maximale que la girafe peut manger sans pouvoir manger \u00e0 la position i , maxi_avec_i : : la quantit\u00e9 maximale que la girafe peut manger avec la position i d\u00e9vor\u00e9e. Indice 3 On g\u00e8rera les cas avec peu d'arbres. Aucun arbre ; aucune feuille. On initialisera correctement les variables. On mettra en place avec prudence la r\u00e9cursion qui permet de progresser jusqu'au bout de la file d'arbres.","title":"communication des acacias"},{"location":"3-difficile/acacias/sujet/#la-communication-des-acacias","text":"M\u00e9canisme de synchronicit\u00e9 Une des observations les plus anciennes a \u00e9t\u00e9 faite sur les girafes par Wouter Van Hoven. Il a \u00e9tudi\u00e9 pendant 2 ans le comportement des girafes dans un parc national en Afrique du Sud. Les girafes ingurgitent environ 80 kg de feuilles par jour. Pourtant, lorsqu'elles arrivent sur un acacia, elles ne restent que quelques minutes, broutent que quelques feuilles puis vont vers un autre arbre. L'arbre a r\u00e9agi \u00e0 la pr\u00e9sence de la girafe en secr\u00e9tant des tanins. Ce sont des mol\u00e9cules am\u00e8res et toxiques pour les girafes. Mais en m\u00eame temps, l'acacia va \u00e9mettre de l'\u00e9thyl\u00e8ne, qui est un gaz qui va se d\u00e9placer dans l'air et informer les autres arbres qu'un pr\u00e9dateur est l\u00e0. Que vont faire les autres arbres ? Ils vont augmenter de mani\u00e8re pr\u00e9ventive leur teneur en tanin et se pr\u00e9parer \u00e0 l'arriv\u00e9e des girafes. On vous donne une liste de quantit\u00e9s de feuilles que pourrait manger une girafe sur un arbre \u00e0 un indice donn\u00e9 le long d'une ligne d'acacias. La seule contrainte, c'est que la girafe ne peut pas manger les feuilles sur deux arbres cons\u00e9cutifs, mais souhaite en manger le plus possible. \u00c9crire une fonction qui indique quelle quantit\u00e9 totale la girafe peut ingurgiter. Exemples \ud83d\udc0d Console Python >>> feuilles = [ 4 , 25 , 20 , 8 , 17 ] >>> max_manger ( feuilles ) 42 La girafe peut manger \\(25+17 = 42\\) feuilles au maximum. Prendre \\(4+20+17\\) n'en donne que \\(41\\) . \ud83d\udc0d Console Python >>> feuilles = [ 4 , 6 , 5 , 7 , 4 ] >>> max_manger ( feuilles ) 13 La girafe peut manger \\(4+5+4=13\\) ou bien \\(6+7=13\\) feuilles au maximum. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert maxpython-underscoremanger([9]) == 9backslash-newlineassert maxpython-underscoremanger([]) == 0backslash-newlinebackslash-newlinefeuilles = [0, 1] python-star 100backslash-newlineassert maxpython-underscoremanger(feuilles) == 100backslash-newlinefeuilles = [2, 1] python-star 100backslash-newlineassert maxpython-underscoremanger(feuilles) == 200backslash-newlinebackslash-newlinefeuilles = [1, 2, 1] python-star 20backslash-newlineassert maxpython-underscoremanger(feuilles) == 40backslash-newlinebackslash-newlinefeuilles = [1, 2, 3] python-star 20backslash-newlineassert maxpython-underscoremanger(feuilles) == 61backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def maxpython-underscoremanger(feuilles):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline def maxpython-underscoremanger(feuilles):backslash-newline n = len(feuilles)backslash-newline if n == 0:backslash-newline return 0backslash-newline maxipython-underscoresanspython-underscorei, maxipython-underscoreavecpython-underscorei = 0, feuilles[0]backslash-newline for i in range(1, n):backslash-newline maxipython-underscoresanspython-underscorei, maxipython-underscoreavecpython-underscorei = (backslash-newline max(maxipython-underscoreavecpython-underscorei, maxipython-underscoresanspython-underscorei),backslash-newline feuilles[i] + maxipython-underscoresanspython-underscoreibackslash-newline )backslash-newline return max(maxipython-underscoreavecpython-underscorei, maxipython-underscoresanspython-underscorei)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlinefeuilles = [4, 25, 20, 8, 17]backslash-newlineassert maxpython-underscoremanger(feuilles) == 42backslash-newlinebackslash-newlinebackslash-newlinefeuilles = [4, 6, 5, 7, 4]backslash-newlineassert maxpython-underscoremanger(feuilles) == 13backslash-newlinebackslash-newline A Z Indice 1 Se poser la question : \u00ab Combien peut-elle avoir mang\u00e9 au maximum \u00e0 la fin ? \u00bb C'est aussi se poser la question : \u00ab A-t-elle manger sur le dernier arbre ? \u00bb En effet, si on veut envisager une r\u00e9cursion, la question se pose... et donc r\u00e9cursivement aussi... Il faut donc envisager de savoir combien la girafe a pu manger au maximum en arrivant \u00e0 un arbre i : sans avoir mang\u00e9 sur le pr\u00e9c\u00e9dent, auquel cas elle pourra manger ici, en i en ayant mang\u00e9 au pr\u00e9c\u00e9dent, auquel cas elle ne pourra manger ici, en i Indice 2 On utilisera deux variables : maxi_sans_i : la quantit\u00e9 maximale que la girafe peut manger sans pouvoir manger \u00e0 la position i , maxi_avec_i : : la quantit\u00e9 maximale que la girafe peut manger avec la position i d\u00e9vor\u00e9e. Indice 3 On g\u00e8rera les cas avec peu d'arbres. Aucun arbre ; aucune feuille. On initialisera correctement les variables. On mettra en place avec prudence la r\u00e9cursion qui permet de progresser jusqu'au bout de la file d'arbres.","title":"La communication des acacias"},{"location":"3-difficile/eratosthene_2/exo_REM/","text":"Commentaires \u2693\ufe0e Force brute \u2693\ufe0e \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante. Premi\u00e8re version du crible \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible Deuxi\u00e8me version \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) . Troisi\u00e8me version \u2693\ufe0e Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice...","title":"Commentaires"},{"location":"3-difficile/eratosthene_2/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/eratosthene_2/exo_REM/#force-brute","text":"\ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante.","title":"Force brute"},{"location":"3-difficile/eratosthene_2/exo_REM/#premiere-version-du-crible","text":"\ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible","title":"Premi\u00e8re version du crible"},{"location":"3-difficile/eratosthene_2/exo_REM/#deuxieme-version","text":"\ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) .","title":"Deuxi\u00e8me version"},{"location":"3-difficile/eratosthene_2/exo_REM/#troisieme-version","text":"Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice...","title":"Troisi\u00e8me version"},{"location":"3-difficile/eratosthene_2/sujet/","text":"Crible d'\u00c9ratosth\u00e8ne \u2693\ufe0e Objectif : obtenir la primalit\u00e9 des nombres de \\(2\\) jusqu'\u00e0 \\(n\\) . Nombres premiers D\u00e9finition : Un nombre \\(p\\) est premier si c'est un entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(2\\) qui n'a que deux diviseurs : \\(1\\) et lui-m\u00eame. D'apr\u00e8s la d\u00e9finition, on peut \u00e9crire directement \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True On peut d\u00e9duire la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(20\\) . \ud83d\udc0d Console Python >>> [ n for n in range ( 20 ) if est_premier ( n )] [2, 3, 5, 7, 11, 13, 17, 19] Cette m\u00e9thode est lente. Am\u00e9liorations du crible classique \u2693\ufe0e On peut rassembler la primalit\u00e9 des nombres inf\u00e9rieurs \u00e0 \\(20\\) dans un tableau de bool\u00e9ens : \ud83d\udc0d Console Python >>> # indice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 >>> primalite = [ False , False , True , True , False , True , False , True , False , False , False , True , False , True , False , False , False , True , False , True ] >>> primalite [ 5 ] True >>> primalite [ 6 ] False Objectif : Construire rapidement un tel tableau. M\u00e9thode : On peut utiliser le crible d'\u00c9ratosth\u00e8ne. Il existe plusieurs variantes, voici une version interm\u00e9diaire. Vous avez d\u00e9j\u00e0 rencontr\u00e9 une premi\u00e8re version qui ressemble \u00e0 : \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible On peut v\u00e9rifier ceci avec les tests \ud83d\udc0d Console Python >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> primalite_brute = [ est_premier ( i ) for i in range ( limite )] >>> primalite == primalite_brute True L'objectif de l'exercice est d'am\u00e9liorer la fonction eratosthene en suivant les conseils suivants : Remplacer la ligne for p in range ( 2 , n ): par une structure avec une boucle while . Remplacer la ligne for kp in range ( 2 * p , n , p ): par for kp in range ( p * p , n , p ): , en effet les multiples de \\(2p\\) inclus \u00e0 \\(p^2\\) exclu ont d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. En d\u00e9duire que quand \\(p\u00d7p >= n\\) il n'y plus de nouveaux multiples \u00e0 cocher. Ils ont tous d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. C'est une propri\u00e9t\u00e9 math\u00e9matique : \u00ab Si un entier \\(n\\) est compos\u00e9, alors il poss\u00e8de un diviseur premier inf\u00e9rieur ou \u00e9gal \u00e0 \\(\\sqrt{n}\\) \u00bb. Modifier la boucle while en cons\u00e9quence. Tester votre fonction eratosthene_V2 en la confrontant \u00e0 eratosthene et \u00e0 une m\u00e9thode par force brute. G\u00e9n\u00e9ration des nombres premiers \u2693\ufe0e Quand vous aurez termin\u00e9, vous pourrez tester une astuce avec Python pour g\u00e9n\u00e9rer la liste des nombres premiers \u00e0 partir du tableau de bool\u00e9ens primalite . Lire la documentation au sujet de itertools.compress \ud83d\udc0d Console Python >>> from itertools import compress >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> list ( compress ( range ( limite ), primalite )) [2, 3, 5, 7, 11, 13, 17 ,19] Pour tester cela, construire une fonction telle que somme_premiers(n) renvoie la somme des nombres premiers strictement inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> somme_premiers ( 5 ) 5 >>> somme_premiers ( 20 ) 77 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef SOMMEpython-underscorepremiers(n):backslash-newline return sum(p for p in range(n) if ESTpython-underscorepremier(p))backslash-newlinebackslash-newlinebackslash-newlinefor n in range(100):backslash-newline attendu = SOMMEpython-underscorepremiers(n)backslash-newline assert sommepython-underscorepremiers(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def sommepython-underscorepremiers(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newline def estpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline for p in range(2, n):backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV2(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(ppython-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV3(n):backslash-newline crible = bytearray([True]) python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline crible[ppython-starp:n:p] = bytearray([False]) python-star len(crible[ppython-starp:n:p])backslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinefrom itertools import compressbackslash-newlinebackslash-newlinedef sommepython-underscorepremiers(n):backslash-newline if n < 2:backslash-newline return 0backslash-newline primalite = eratosthenepython-underscoreV2(n)backslash-newline return sum(compress(range(n), primalite))backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newline# tests \u00c3 cr\u00c3\u00a9erbackslash-newlinebackslash-newlinefor limite in range(20):backslash-newline primalite = eratosthene(limite)backslash-newline primalitepython-underscoreV3 = eratosthenepython-underscoreV3(limite)backslash-newline primalitepython-underscorebrute = [estpython-underscorepremier(i) for i in range(limite)]backslash-newline assert list(primalitepython-underscoreV3) == primalite == primalitepython-underscorebrute, f\"{limite}, {list(primalitepython-underscoreV3)} {primalite}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Force brute \u2693\ufe0e \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante. Premi\u00e8re version du crible \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible Deuxi\u00e8me version \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) . Troisi\u00e8me version \u2693\ufe0e Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice... Z Vous ajouterez tous les tests utiles aux diff\u00e9rentes \u00e9tapes.","title":"Crible d'\u00c9ratosth\u00e8ne V2"},{"location":"3-difficile/eratosthene_2/sujet/#crible-deratosthene","text":"Objectif : obtenir la primalit\u00e9 des nombres de \\(2\\) jusqu'\u00e0 \\(n\\) . Nombres premiers D\u00e9finition : Un nombre \\(p\\) est premier si c'est un entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(2\\) qui n'a que deux diviseurs : \\(1\\) et lui-m\u00eame. D'apr\u00e8s la d\u00e9finition, on peut \u00e9crire directement \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True On peut d\u00e9duire la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(20\\) . \ud83d\udc0d Console Python >>> [ n for n in range ( 20 ) if est_premier ( n )] [2, 3, 5, 7, 11, 13, 17, 19] Cette m\u00e9thode est lente.","title":"Crible d'\u00c9ratosth\u00e8ne"},{"location":"3-difficile/eratosthene_2/sujet/#ameliorations-du-crible-classique","text":"On peut rassembler la primalit\u00e9 des nombres inf\u00e9rieurs \u00e0 \\(20\\) dans un tableau de bool\u00e9ens : \ud83d\udc0d Console Python >>> # indice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 >>> primalite = [ False , False , True , True , False , True , False , True , False , False , False , True , False , True , False , False , False , True , False , True ] >>> primalite [ 5 ] True >>> primalite [ 6 ] False Objectif : Construire rapidement un tel tableau. M\u00e9thode : On peut utiliser le crible d'\u00c9ratosth\u00e8ne. Il existe plusieurs variantes, voici une version interm\u00e9diaire. Vous avez d\u00e9j\u00e0 rencontr\u00e9 une premi\u00e8re version qui ressemble \u00e0 : \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible On peut v\u00e9rifier ceci avec les tests \ud83d\udc0d Console Python >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> primalite_brute = [ est_premier ( i ) for i in range ( limite )] >>> primalite == primalite_brute True L'objectif de l'exercice est d'am\u00e9liorer la fonction eratosthene en suivant les conseils suivants : Remplacer la ligne for p in range ( 2 , n ): par une structure avec une boucle while . Remplacer la ligne for kp in range ( 2 * p , n , p ): par for kp in range ( p * p , n , p ): , en effet les multiples de \\(2p\\) inclus \u00e0 \\(p^2\\) exclu ont d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. En d\u00e9duire que quand \\(p\u00d7p >= n\\) il n'y plus de nouveaux multiples \u00e0 cocher. Ils ont tous d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. C'est une propri\u00e9t\u00e9 math\u00e9matique : \u00ab Si un entier \\(n\\) est compos\u00e9, alors il poss\u00e8de un diviseur premier inf\u00e9rieur ou \u00e9gal \u00e0 \\(\\sqrt{n}\\) \u00bb. Modifier la boucle while en cons\u00e9quence. Tester votre fonction eratosthene_V2 en la confrontant \u00e0 eratosthene et \u00e0 une m\u00e9thode par force brute.","title":"Am\u00e9liorations du crible classique"},{"location":"3-difficile/eratosthene_2/sujet/#generation-des-nombres-premiers","text":"Quand vous aurez termin\u00e9, vous pourrez tester une astuce avec Python pour g\u00e9n\u00e9rer la liste des nombres premiers \u00e0 partir du tableau de bool\u00e9ens primalite . Lire la documentation au sujet de itertools.compress \ud83d\udc0d Console Python >>> from itertools import compress >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> list ( compress ( range ( limite ), primalite )) [2, 3, 5, 7, 11, 13, 17 ,19] Pour tester cela, construire une fonction telle que somme_premiers(n) renvoie la somme des nombres premiers strictement inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> somme_premiers ( 5 ) 5 >>> somme_premiers ( 20 ) 77 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef SOMMEpython-underscorepremiers(n):backslash-newline return sum(p for p in range(n) if ESTpython-underscorepremier(p))backslash-newlinebackslash-newlinebackslash-newlinefor n in range(100):backslash-newline attendu = SOMMEpython-underscorepremiers(n)backslash-newline assert sommepython-underscorepremiers(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def sommepython-underscorepremiers(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newline def estpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline for p in range(2, n):backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV2(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(ppython-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV3(n):backslash-newline crible = bytearray([True]) python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline crible[ppython-starp:n:p] = bytearray([False]) python-star len(crible[ppython-starp:n:p])backslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinefrom itertools import compressbackslash-newlinebackslash-newlinedef sommepython-underscorepremiers(n):backslash-newline if n < 2:backslash-newline return 0backslash-newline primalite = eratosthenepython-underscoreV2(n)backslash-newline return sum(compress(range(n), primalite))backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newline# tests \u00c3 cr\u00c3\u00a9erbackslash-newlinebackslash-newlinefor limite in range(20):backslash-newline primalite = eratosthene(limite)backslash-newline primalitepython-underscoreV3 = eratosthenepython-underscoreV3(limite)backslash-newline primalitepython-underscorebrute = [estpython-underscorepremier(i) for i in range(limite)]backslash-newline assert list(primalitepython-underscoreV3) == primalite == primalitepython-underscorebrute, f\"{limite}, {list(primalitepython-underscoreV3)} {primalite}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A","title":"G\u00e9n\u00e9ration des nombres premiers"},{"location":"3-difficile/eratosthene_2/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/eratosthene_2/sujet/#force-brute","text":"\ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante.","title":"Force brute"},{"location":"3-difficile/eratosthene_2/sujet/#premiere-version-du-crible","text":"\ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible","title":"Premi\u00e8re version du crible"},{"location":"3-difficile/eratosthene_2/sujet/#deuxieme-version","text":"\ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) .","title":"Deuxi\u00e8me version"},{"location":"3-difficile/eratosthene_2/sujet/#troisieme-version","text":"Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice... Z Vous ajouterez tous les tests utiles aux diff\u00e9rentes \u00e9tapes.","title":"Troisi\u00e8me version"},{"location":"3-difficile/est_carre_magique/sujet/","tags":["maths+","boucle","grille"],"text":"Carr\u00e9s magiques normaux d'ordre n \u2693\ufe0e Un carr\u00e9 magique normal d'ordre \\(n\\) est une grille carr\u00e9e remplie de tous les entiers de \\(1\\) \u00e0 \\(n^2\\) , telle que les sommes suivantes sont \u00e9gales : la somme des nombres de chaque ligne, la somme des nombres de chaque colonne, la somme des nombres des deux diagonales. Carr\u00e9 magique d'ordre \\(3\\) \ud83d\udc0d Script Python ex_ordre_3 = [ [ 2 , 7 , 6 ], [ 9 , 5 , 1 ], [ 4 , 3 , 8 ], ] Voici un exemple avec tous les entiers de \\(1\\) \u00e0 9$. la somme de chaque ligne est \u00e9gale \u00e0 \\(15\\) \\(2+7+6 = 15\\) \\(9+5+1 = 15\\) \\(4+3+8 = 15\\) la somme de chaque colonne est \u00e9gale \u00e0 \\(15\\) ; \\(2+9+4 = 15\\) \\(7+5+3 = 15\\) \\(6+1+8 = 15\\) la somme de chaque diagonale est \u00e9gale \u00e0 \\(15\\) . \\(2+5+8 = 15\\) \\(4+5+6 = 15\\) Carr\u00e9 magique d'ordre \\(4\\) \ud83d\udc0d Script Python ex_ordre_4 = [ [ 16 , 3 , 2 , 13 ], [ 5 , 10 , 11 , 8 ], [ 9 , 6 , 7 , 12 ], [ 4 , 15 , 14 , 1 ], ] Ce carr\u00e9 magique \u00e9tait connu du peintre allemand Albrecht D\u00fcrer, qui l'a inclus dans sa gravure Melencolia . \u00c9crire une fonction telle que est_carre_magique(carre) renvoie un bool\u00e9en, la r\u00e9ponse \u00e0 la question : carre est-il un carr\u00e9 magique normal ? On garantit que carre est un tableau 2D de forme carr\u00e9e, rempli d'entiers ; il y a autant de lignes que de colonnes et toutes les lignes ont le m\u00eame nombre de colonnes. Exemples \ud83d\udc0d Console Python >>> ex_ordre_3 = [ ... [ 2 , 7 , 6 ], ... [ 9 , 5 , 1 ], ... [ 4 , 3 , 8 ], ... ] >>> est_carre_magique ( ex_ordre_3 ) True \ud83d\udc0d Console Python >>> contre_ex_ordre_2 = [ ... [ 2 , 2 ], ... [ 2 , 2 ], ... ] >>> est_carre_magique ( contre_ex_ordre_2 ) False \ud83d\udc0d Console Python >>> ex_ordre_4 = [ ... [ 16 , 3 , 2 , 13 ], ... [ 5 , 10 , 11 , 8 ], ... [ 9 , 6 , 7 , 12 ], ... [ 4 , 15 , 14 , 1 ], ... ] >>> est_carre_magique ( ex_ordre_4 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newline# ordre 3backslash-newlineassert estpython-underscorecarrepython-underscoremagique([[2, 7, 6], [9, 5, 1], [4, 3, 8],])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[1, 6, 5], [8, 4, 0], [3, 2, 7],]), \"0 est pr\u00c3\u00a9sent ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[3, 8, 7], [10, 6, 2], [5, 4, 9],]), \"1 est absent ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[1, 1, 1], [1, 1, 1], [1, 1, 1],]), \"beaucoup d'absents ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[4, 3, 8], [2, 7, 6], [9, 5, 1],]), \"erreur avec les diagonales\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[7, 6, 2], [5, 1, 9], [3, 8, 4],]), \"erreur avec les diagonales\"backslash-newlinebackslash-newline# ordre 1backslash-newlineassert estpython-underscorecarrepython-underscoremagique([[1]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[0]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[-1]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[2]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[128]])backslash-newlinebackslash-newline# ordre n impairbackslash-newlinedef magiquepython-underscoref(i, j, n):backslash-newline assert n%2 == 1backslash-newline return n python-star ((i + j + (n-3)//2)%n) + ((i + 2python-starj - 2) % n) + 1backslash-newlinebackslash-newlinedef rotation(carre):backslash-newline n = len(carre)backslash-newline carre = [[carre[n-1-j][i] for j in range(n)] for i in range(n)]backslash-newlinebackslash-newlinedef switch(carre):backslash-newline # on inverse deux lignes extremes et deux colonnes extremesbackslash-newline n = len(carre)backslash-newline carre[0], carre[-1] = carre[-1], carre[0]backslash-newline for i in range(n):backslash-newline carre[i][0], carre[i][-1] = carre[i][-1], carre[i][0]backslash-newlinebackslash-newlinefor n in range(3, 21, 2):backslash-newline carre = [[magiquepython-underscoref(i, j, n) for j in range(1, n+1)] for i in range(1, 1+n)]backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline carre[0][-1] += 1backslash-newline carre[0][-2] -= 1backslash-newline carre[1][-1] -= 1backslash-newline carre[1][-2] += 1backslash-newline carre[-1][0] -= 1backslash-newline carre[-1][1] += 1backslash-newline carre[-2][0] += 1backslash-newline carre[-2][1] -= 1backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline# ordre n pairbackslash-newlinebackslash-newlinesoleil = [backslash-newline [ 6, 32, 3, 34, 35, 1],backslash-newline [ 7, 11, 27, 28, 8, 30],backslash-newline [19, 14, 16, 15, 23, 24],backslash-newline [18, 20, 22, 21, 17, 13],backslash-newline [25, 29, 10, 9, 26, 12],backslash-newline [36, 5, 33, 4, 2, 31],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(soleil), \"Erreur avec le carr\u00c3\u00a9 dit 'du Soleil'\"backslash-newlinebackslash-newlinefranklin = [backslash-newline [52, 61, 4, 13, 20, 29, 36, 45],backslash-newline [14, 3, 62, 51, 46, 35, 30, 19],backslash-newline [53, 60, 5, 12, 21, 28, 37, 44],backslash-newline [11, 6, 59, 54, 43, 38, 27, 22],backslash-newline [55, 58, 7, 10, 23, 26, 39, 42],backslash-newline [ 9, 8, 57, 56, 41, 40, 25, 24],backslash-newline [50, 63, 2, 15, 18, 31, 34, 47],backslash-newline [16, 1, 64, 49, 48, 33, 32, 17],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(soleil), \"Erreur avec le carr\u00c3\u00a9 de Benjamin Franklin\"backslash-newlinebackslash-newlinedef magiquepython-underscore4(n):backslash-newline assert n%4 == 0backslash-newlinebackslash-newline def case(i, j):backslash-newline if ((i + j + 1) % 4 == 0) or ((i - j) % 4 == 0):backslash-newline return 1 + i + npython-starjbackslash-newline else:backslash-newline return n python-star n - (i + npython-starj)backslash-newlinebackslash-newline return [[case(i, j) for j in range(n)] for i in range(n)]backslash-newlinebackslash-newlinefor n in range(4, 21, 4):backslash-newline carre = magiquepython-underscore4(n)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline carre[0][-1] += 1backslash-newline carre[0][-2] -= 1backslash-newline carre[1][-1] -= 1backslash-newline carre[1][-2] += 1backslash-newline carre[-1][0] -= 1backslash-newline carre[-1][1] += 1backslash-newline carre[-2][0] += 1backslash-newline carre[-2][1] -= 1backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def estpython-underscorecarrepython-underscoremagique(carre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newlinebackslash-newline def estpython-underscorecarrepython-underscoremagique(carre):backslash-newline n = len(carre)backslash-newline somme = n python-star (npython-starn + 1) // 2backslash-newlinebackslash-newline # test des lignesbackslash-newline for i in range(n):backslash-newline sommepython-underscorei = sum(carre[i][j] for j in range(n))backslash-newline if sommepython-underscorei != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test des colonnesbackslash-newline for j in range(n):backslash-newline sommepython-underscorej = sum(carre[i][j] for i in range(n))backslash-newline if sommepython-underscorej != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test des diagonalesbackslash-newline sommepython-underscored1 = sum(carre[i][i] for i in range(n))backslash-newline if sommepython-underscored1 != somme:backslash-newline return Falsebackslash-newline sommepython-underscored2 = sum(carre[i][n - 1 - i] for i in range(n))backslash-newline if sommepython-underscored2 != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test pr\u00c3\u00a9sence uniquebackslash-newline dejapython-underscorevu = [False] python-star (npython-starn + 1)backslash-newline for i in range(n):backslash-newline for j in range(n):backslash-newline if not(1 <= carre[i][j] <= npython-starn):backslash-newline return Falsebackslash-newlinebackslash-newline if dejapython-underscorevu[carre[i][j]]:backslash-newline return Falsebackslash-newline dejapython-underscorevu[carre[i][j]] = Truebackslash-newlinebackslash-newline return Truebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A Z Indice 1 En utilisant la formule \\(1+2+3+\\cdots+n^2 = \\dfrac{n^2(n^2+1)}{2}\\) , il est possible de d\u00e9terminer la somme commune d'un carr\u00e9 magique normal d'ordre \\(n\\) , sans m\u00eame avoir lu une seule ligne du tableau. Indice 2 On pourra proc\u00e9der par \u00e9tapes. \u00c0 chaque test qui \u00e9choue, la fonction peut renvoyer False . \u00c0 la fin, si tous les crit\u00e8res sont valid\u00e9s, la fonction renvoie True . Indice 3 Pour v\u00e9rifier la pr\u00e9sence unique des nombres de \\(1\\) \u00e0 \\(n^2\\) , on pourra utiliser un tableau de bool\u00e9en deja_vu de longueur \\(n^2+1\\) . On pensera \u00e0 tester au passage que les entiers sont bien de \\(1\\) \u00e0 \\(n^2\\) .","title":"Carr\u00e9s magiques normaux d'ordre n"},{"location":"3-difficile/est_carre_magique/sujet/#carres-magiques-normaux-dordre-n","text":"Un carr\u00e9 magique normal d'ordre \\(n\\) est une grille carr\u00e9e remplie de tous les entiers de \\(1\\) \u00e0 \\(n^2\\) , telle que les sommes suivantes sont \u00e9gales : la somme des nombres de chaque ligne, la somme des nombres de chaque colonne, la somme des nombres des deux diagonales. Carr\u00e9 magique d'ordre \\(3\\) \ud83d\udc0d Script Python ex_ordre_3 = [ [ 2 , 7 , 6 ], [ 9 , 5 , 1 ], [ 4 , 3 , 8 ], ] Voici un exemple avec tous les entiers de \\(1\\) \u00e0 9$. la somme de chaque ligne est \u00e9gale \u00e0 \\(15\\) \\(2+7+6 = 15\\) \\(9+5+1 = 15\\) \\(4+3+8 = 15\\) la somme de chaque colonne est \u00e9gale \u00e0 \\(15\\) ; \\(2+9+4 = 15\\) \\(7+5+3 = 15\\) \\(6+1+8 = 15\\) la somme de chaque diagonale est \u00e9gale \u00e0 \\(15\\) . \\(2+5+8 = 15\\) \\(4+5+6 = 15\\) Carr\u00e9 magique d'ordre \\(4\\) \ud83d\udc0d Script Python ex_ordre_4 = [ [ 16 , 3 , 2 , 13 ], [ 5 , 10 , 11 , 8 ], [ 9 , 6 , 7 , 12 ], [ 4 , 15 , 14 , 1 ], ] Ce carr\u00e9 magique \u00e9tait connu du peintre allemand Albrecht D\u00fcrer, qui l'a inclus dans sa gravure Melencolia . \u00c9crire une fonction telle que est_carre_magique(carre) renvoie un bool\u00e9en, la r\u00e9ponse \u00e0 la question : carre est-il un carr\u00e9 magique normal ? On garantit que carre est un tableau 2D de forme carr\u00e9e, rempli d'entiers ; il y a autant de lignes que de colonnes et toutes les lignes ont le m\u00eame nombre de colonnes. Exemples \ud83d\udc0d Console Python >>> ex_ordre_3 = [ ... [ 2 , 7 , 6 ], ... [ 9 , 5 , 1 ], ... [ 4 , 3 , 8 ], ... ] >>> est_carre_magique ( ex_ordre_3 ) True \ud83d\udc0d Console Python >>> contre_ex_ordre_2 = [ ... [ 2 , 2 ], ... [ 2 , 2 ], ... ] >>> est_carre_magique ( contre_ex_ordre_2 ) False \ud83d\udc0d Console Python >>> ex_ordre_4 = [ ... [ 16 , 3 , 2 , 13 ], ... [ 5 , 10 , 11 , 8 ], ... [ 9 , 6 , 7 , 12 ], ... [ 4 , 15 , 14 , 1 ], ... ] >>> est_carre_magique ( ex_ordre_4 ) True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newline# ordre 3backslash-newlineassert estpython-underscorecarrepython-underscoremagique([[2, 7, 6], [9, 5, 1], [4, 3, 8],])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[1, 6, 5], [8, 4, 0], [3, 2, 7],]), \"0 est pr\u00c3\u00a9sent ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[3, 8, 7], [10, 6, 2], [5, 4, 9],]), \"1 est absent ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[1, 1, 1], [1, 1, 1], [1, 1, 1],]), \"beaucoup d'absents ; interdit\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[4, 3, 8], [2, 7, 6], [9, 5, 1],]), \"erreur avec les diagonales\"backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[7, 6, 2], [5, 1, 9], [3, 8, 4],]), \"erreur avec les diagonales\"backslash-newlinebackslash-newline# ordre 1backslash-newlineassert estpython-underscorecarrepython-underscoremagique([[1]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[0]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[-1]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[2]])backslash-newlineassert not estpython-underscorecarrepython-underscoremagique([[128]])backslash-newlinebackslash-newline# ordre n impairbackslash-newlinedef magiquepython-underscoref(i, j, n):backslash-newline assert n%2 == 1backslash-newline return n python-star ((i + j + (n-3)//2)%n) + ((i + 2python-starj - 2) % n) + 1backslash-newlinebackslash-newlinedef rotation(carre):backslash-newline n = len(carre)backslash-newline carre = [[carre[n-1-j][i] for j in range(n)] for i in range(n)]backslash-newlinebackslash-newlinedef switch(carre):backslash-newline # on inverse deux lignes extremes et deux colonnes extremesbackslash-newline n = len(carre)backslash-newline carre[0], carre[-1] = carre[-1], carre[0]backslash-newline for i in range(n):backslash-newline carre[i][0], carre[i][-1] = carre[i][-1], carre[i][0]backslash-newlinebackslash-newlinefor n in range(3, 21, 2):backslash-newline carre = [[magiquepython-underscoref(i, j, n) for j in range(1, n+1)] for i in range(1, 1+n)]backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline carre[0][-1] += 1backslash-newline carre[0][-2] -= 1backslash-newline carre[1][-1] -= 1backslash-newline carre[1][-2] += 1backslash-newline carre[-1][0] -= 1backslash-newline carre[-1][1] += 1backslash-newline carre[-2][0] += 1backslash-newline carre[-2][1] -= 1backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline# ordre n pairbackslash-newlinebackslash-newlinesoleil = [backslash-newline [ 6, 32, 3, 34, 35, 1],backslash-newline [ 7, 11, 27, 28, 8, 30],backslash-newline [19, 14, 16, 15, 23, 24],backslash-newline [18, 20, 22, 21, 17, 13],backslash-newline [25, 29, 10, 9, 26, 12],backslash-newline [36, 5, 33, 4, 2, 31],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(soleil), \"Erreur avec le carr\u00c3\u00a9 dit 'du Soleil'\"backslash-newlinebackslash-newlinefranklin = [backslash-newline [52, 61, 4, 13, 20, 29, 36, 45],backslash-newline [14, 3, 62, 51, 46, 35, 30, 19],backslash-newline [53, 60, 5, 12, 21, 28, 37, 44],backslash-newline [11, 6, 59, 54, 43, 38, 27, 22],backslash-newline [55, 58, 7, 10, 23, 26, 39, 42],backslash-newline [ 9, 8, 57, 56, 41, 40, 25, 24],backslash-newline [50, 63, 2, 15, 18, 31, 34, 47],backslash-newline [16, 1, 64, 49, 48, 33, 32, 17],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(soleil), \"Erreur avec le carr\u00c3\u00a9 de Benjamin Franklin\"backslash-newlinebackslash-newlinedef magiquepython-underscore4(n):backslash-newline assert n%4 == 0backslash-newlinebackslash-newline def case(i, j):backslash-newline if ((i + j + 1) % 4 == 0) or ((i - j) % 4 == 0):backslash-newline return 1 + i + npython-starjbackslash-newline else:backslash-newline return n python-star n - (i + npython-starj)backslash-newlinebackslash-newline return [[case(i, j) for j in range(n)] for i in range(n)]backslash-newlinebackslash-newlinefor n in range(4, 21, 4):backslash-newline carre = magiquepython-underscore4(n)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline carre[0][-1] += 1backslash-newline carre[0][-2] -= 1backslash-newline carre[1][-1] -= 1backslash-newline carre[1][-2] += 1backslash-newline carre[-1][0] -= 1backslash-newline carre[-1][1] += 1backslash-newline carre[-2][0] += 1backslash-newline carre[-2][1] -= 1backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline switch(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newline rotation(carre)backslash-newline assert not estpython-underscorecarrepython-underscoremagique(carre), f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def estpython-underscorecarrepython-underscoremagique(carre):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newlinebackslash-newline def estpython-underscorecarrepython-underscoremagique(carre):backslash-newline n = len(carre)backslash-newline somme = n python-star (npython-starn + 1) // 2backslash-newlinebackslash-newline # test des lignesbackslash-newline for i in range(n):backslash-newline sommepython-underscorei = sum(carre[i][j] for j in range(n))backslash-newline if sommepython-underscorei != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test des colonnesbackslash-newline for j in range(n):backslash-newline sommepython-underscorej = sum(carre[i][j] for i in range(n))backslash-newline if sommepython-underscorej != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test des diagonalesbackslash-newline sommepython-underscored1 = sum(carre[i][i] for i in range(n))backslash-newline if sommepython-underscored1 != somme:backslash-newline return Falsebackslash-newline sommepython-underscored2 = sum(carre[i][n - 1 - i] for i in range(n))backslash-newline if sommepython-underscored2 != somme:backslash-newline return Falsebackslash-newlinebackslash-newline # test pr\u00c3\u00a9sence uniquebackslash-newline dejapython-underscorevu = [False] python-star (npython-starn + 1)backslash-newline for i in range(n):backslash-newline for j in range(n):backslash-newline if not(1 <= carre[i][j] <= npython-starn):backslash-newline return Falsebackslash-newlinebackslash-newline if dejapython-underscorevu[carre[i][j]]:backslash-newline return Falsebackslash-newline dejapython-underscorevu[carre[i][j]] = Truebackslash-newlinebackslash-newline return Truebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore3 = [backslash-newline [2, 7, 6],backslash-newline [9, 5, 1],backslash-newline [4, 3, 8],backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore3)backslash-newlinebackslash-newlinecontrepython-underscoreexpython-underscoreordrepython-underscore2 = [backslash-newline [2, 2],backslash-newline [2, 2],backslash-newline]backslash-newlineassert not estpython-underscorecarrepython-underscoremagique(contrepython-underscoreexpython-underscoreordrepython-underscore2)backslash-newlinebackslash-newlineexpython-underscoreordrepython-underscore4 = [backslash-newline [16, 3, 2, 13],backslash-newline [ 5, 10, 11, 8],backslash-newline [ 9, 6, 7, 12],backslash-newline [ 4, 15, 14, 1], backslash-newline]backslash-newlineassert estpython-underscorecarrepython-underscoremagique(expython-underscoreordrepython-underscore4)backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A Z Indice 1 En utilisant la formule \\(1+2+3+\\cdots+n^2 = \\dfrac{n^2(n^2+1)}{2}\\) , il est possible de d\u00e9terminer la somme commune d'un carr\u00e9 magique normal d'ordre \\(n\\) , sans m\u00eame avoir lu une seule ligne du tableau. Indice 2 On pourra proc\u00e9der par \u00e9tapes. \u00c0 chaque test qui \u00e9choue, la fonction peut renvoyer False . \u00c0 la fin, si tous les crit\u00e8res sont valid\u00e9s, la fonction renvoie True . Indice 3 Pour v\u00e9rifier la pr\u00e9sence unique des nombres de \\(1\\) \u00e0 \\(n^2\\) , on pourra utiliser un tableau de bool\u00e9en deja_vu de longueur \\(n^2+1\\) . On pensera \u00e0 tester au passage que les entiers sont bien de \\(1\\) \u00e0 \\(n^2\\) .","title":"Carr\u00e9s magiques normaux d'ordre n"},{"location":"3-difficile/fact1_nb_zeros/exo_REM/","text":"Commentaires \u2693\ufe0e Version simple \u2693\ufe0e \ud83d\udc0d Script Python nb_zeros_factorielle = [ 0 ] def nb_zeros ( n ): resultat = 0 while n % 10 == 0 : n //= 10 resultat += 1 return resultat factorielle = 1 for n in range ( 1 , 1000 ): factorielle *= n suivant = nb_zeros ( factorielle ) nb_zeros_factorielle . append ( suivant ) Ici, on appelle la fonction nb_zeros sur un nombre factoriel qui est tr\u00e8s grand . Version efficace \u2693\ufe0e \ud83d\udc0d Script Python def nb_facteurs_5 ( n ): resultat = 0 while n % 5 == 0 : n //= 5 resultat += 1 return resultat nb_zeros_factorielle = [ 0 ] for n in range ( 1 , 1000 ): apport = nb_facteurs_5 ( n ) suivant = nb_zeros_factorielle [ n - 1 ] + apport nb_zeros_factorielle . append ( suivant ) Cette version ressemble beaucoup \u00e0 la pr\u00e9c\u00e9dente ; presque la m\u00eame fonction. La diff\u00e9rence essentielle est qu'ici nb_facteurs est appel\u00e9 avec un nombre petit en param\u00e8tre. \u00c0 m\u00e9diter. Cette diff\u00e9rence subtile est tr\u00e8s importante. Ici, on gagne s\u00e9rieusement en efficacit\u00e9 gr\u00e2ce \u00e0 la taille r\u00e9duite du param\u00e8tre dont le cout est plus faible \u00e0 traiter.","title":"Commentaires"},{"location":"3-difficile/fact1_nb_zeros/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/fact1_nb_zeros/exo_REM/#version-simple","text":"\ud83d\udc0d Script Python nb_zeros_factorielle = [ 0 ] def nb_zeros ( n ): resultat = 0 while n % 10 == 0 : n //= 10 resultat += 1 return resultat factorielle = 1 for n in range ( 1 , 1000 ): factorielle *= n suivant = nb_zeros ( factorielle ) nb_zeros_factorielle . append ( suivant ) Ici, on appelle la fonction nb_zeros sur un nombre factoriel qui est tr\u00e8s grand .","title":"Version simple"},{"location":"3-difficile/fact1_nb_zeros/exo_REM/#version-efficace","text":"\ud83d\udc0d Script Python def nb_facteurs_5 ( n ): resultat = 0 while n % 5 == 0 : n //= 5 resultat += 1 return resultat nb_zeros_factorielle = [ 0 ] for n in range ( 1 , 1000 ): apport = nb_facteurs_5 ( n ) suivant = nb_zeros_factorielle [ n - 1 ] + apport nb_zeros_factorielle . append ( suivant ) Cette version ressemble beaucoup \u00e0 la pr\u00e9c\u00e9dente ; presque la m\u00eame fonction. La diff\u00e9rence essentielle est qu'ici nb_facteurs est appel\u00e9 avec un nombre petit en param\u00e8tre. \u00c0 m\u00e9diter. Cette diff\u00e9rence subtile est tr\u00e8s importante. Ici, on gagne s\u00e9rieusement en efficacit\u00e9 gr\u00e2ce \u00e0 la taille r\u00e9duite du param\u00e8tre dont le cout est plus faible \u00e0 traiter.","title":"Version efficace"},{"location":"3-difficile/fact1_nb_zeros/sujet/","tags":["maths","prog.dynamique"],"text":"Nombre de z\u00e9ros de n factoriel ; n petit \u2693\ufe0e On rappelle que, pour \\(n\\) un entier naturel, la factorielle de \\(n\\) se note \\(n!\\) et se d\u00e9finit comme le produit des entiers de \\(1\\) \u00e0 \\(n\\) . \\(0! = 1\\) , comme un produit vide. \\(1! = 1\\) \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(11! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\u00d78\u00d79\u00d710\u00d711 = 39916800\\) \\(42! = 1405006117752879898543142606244511569936384000000000\\) On constate que \\(3!\\) se termine par aucun z\u00e9ro. \\(11!\\) se termine par 2 z\u00e9ros. \\(42!\\) se termine par 9 z\u00e9ros. Construire un tableau de longueur 1000, tel que nb_zeros_factorielle[n] contient le nombre de z\u00e9ros dans l'\u00e9criture d\u00e9cimale de \\(n!\\) , pour \\(n\\) entier inf\u00e9rieur \u00e0 \\(1000\\) . Exemples \ud83d\udc0d Console Python >>> nb_zeros_factorielle [ 3 ] 0 >>> nb_zeros_factorielle [ 11 ] 2 >>> nb_zeros_factorielle [ 42 ] 9 >>> len ( nb_zeros_factorielle ) >= 1000 True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineNBpython-underscoreZEROS = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 84, 84, 84, 84, 84, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 93, 93, 93, 93, 93, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 103, 103, 103, 103, 103, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 108, 108, 108, 108, 108, 109, 109, 109, 109, 109, 111, 111, 111, 111, 111, 112, 112, 112, 112, 112, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 119, 119, 119, 119, 119, 120, 120, 120, 120, 120, 121, 121, 121, 121, 121, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 127, 127, 127, 127, 127, 128, 128, 128, 128, 128, 130, 130, 130, 130, 130, 131, 131, 131, 131, 131, 132, 132, 132, 132, 132, 133, 133, 133, 133, 133, 134, 134, 134, 134, 134, 136, 136, 136, 136, 136, 137, 137, 137, 137, 137, 138, 138, 138, 138, 138, 139, 139, 139, 139, 139, 140, 140, 140, 140, 140, 142, 142, 142, 142, 142, 143, 143, 143, 143, 143, 144, 144, 144, 144, 144, 145, 145, 145, 145, 145, 146, 146, 146, 146, 146, 148, 148, 148, 148, 148, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 151, 151, 151, 151, 151, 152, 152, 152, 152, 152, 156, 156, 156, 156, 156, 157, 157, 157, 157, 157, 158, 158, 158, 158, 158, 159, 159, 159, 159, 159, 160, 160, 160, 160, 160, 162, 162, 162, 162, 162, 163, 163, 163, 163, 163, 164, 164, 164, 164, 164, 165, 165, 165, 165, 165, 166, 166, 166, 166, 166, 168, 168, 168, 168, 168, 169, 169, 169, 169, 169, 170, 170, 170, 170, 170, 171, 171, 171, 171, 171, 172, 172, 172, 172, 172, 174, 174, 174, 174, 174, 175, 175, 175, 175, 175, 176, 176, 176, 176, 176, 177, 177, 177, 177, 177, 178, 178, 178, 178, 178, 180, 180, 180, 180, 180, 181, 181, 181, 181, 181, 182, 182, 182, 182, 182, 183, 183, 183, 183, 183, 184, 184, 184, 184, 184, 187, 187, 187, 187, 187, 188, 188, 188, 188, 188, 189, 189, 189, 189, 189, 190, 190, 190, 190, 190, 191, 191, 191, 191, 191, 193, 193, 193, 193, 193, 194, 194, 194, 194, 194, 195, 195, 195, 195, 195, 196, 196, 196, 196, 196, 197, 197, 197, 197, 197, 199, 199, 199, 199, 199, 200, 200, 200, 200, 200, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 203, 203, 203, 203, 203, 205, 205, 205, 205, 205, 206, 206, 206, 206, 206, 207, 207, 207, 207, 207, 208, 208, 208, 208, 208, 209, 209, 209, 209, 209, 211, 211, 211, 211, 211, 212, 212, 212, 212, 212, 213, 213, 213, 213, 213, 214, 214, 214, 214, 214, 215, 215, 215, 215, 215, 218, 218, 218, 218, 218, 219, 219, 219, 219, 219, 220, 220, 220, 220, 220, 221, 221, 221, 221, 221, 222, 222, 222, 222, 222, 224, 224, 224, 224, 224, 225, 225, 225, 225, 225, 226, 226, 226, 226, 226, 227, 227, 227, 227, 227, 228, 228, 228, 228, 228, 230, 230, 230, 230, 230, 231, 231, 231, 231, 231, 232, 232, 232, 232, 232, 233, 233, 233, 233, 233, 234, 234, 234, 234, 234, 236, 236, 236, 236, 236, 237, 237, 237, 237, 237, 238, 238, 238, 238, 238, 239, 239, 239, 239, 239, 240, 240, 240, 240, 240, 242, 242, 242, 242, 242, 243, 243, 243, 243, 243, 244, 244, 244, 244, 244, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246]backslash-newlinebackslash-newlinefor n, attendu in enumerate(NBpython-underscoreZEROS):backslash-newline assert nbpython-underscorezerospython-underscorefactorielle[n] == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 nbpython-underscorezerospython-underscorefactorielle = [...]backslash-newline...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newline nbpython-underscorezerospython-underscorefactorielle = [0]backslash-newlinebackslash-newlinedef nbpython-underscorezeros(n):backslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n //= 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinefactorielle = 1backslash-newlinefor n in range(1, 1000):backslash-newline factorielle python-star= nbackslash-newline suivant = nbpython-underscorezeros(factorielle)backslash-newline nbpython-underscorezerospython-underscorefactorielle.append(suivant)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version simple \u2693\ufe0e \ud83d\udc0d Script Python nb_zeros_factorielle = [ 0 ] def nb_zeros ( n ): resultat = 0 while n % 10 == 0 : n //= 10 resultat += 1 return resultat factorielle = 1 for n in range ( 1 , 1000 ): factorielle *= n suivant = nb_zeros ( factorielle ) nb_zeros_factorielle . append ( suivant ) Ici, on appelle la fonction nb_zeros sur un nombre factoriel qui est tr\u00e8s grand . Version efficace \u2693\ufe0e \ud83d\udc0d Script Python def nb_facteurs_5 ( n ): resultat = 0 while n % 5 == 0 : n //= 5 resultat += 1 return resultat nb_zeros_factorielle = [ 0 ] for n in range ( 1 , 1000 ): apport = nb_facteurs_5 ( n ) suivant = nb_zeros_factorielle [ n - 1 ] + apport nb_zeros_factorielle . append ( suivant ) Cette version ressemble beaucoup \u00e0 la pr\u00e9c\u00e9dente ; presque la m\u00eame fonction. La diff\u00e9rence essentielle est qu'ici nb_facteurs est appel\u00e9 avec un nombre petit en param\u00e8tre. \u00c0 m\u00e9diter. Cette diff\u00e9rence subtile est tr\u00e8s importante. Ici, on gagne s\u00e9rieusement en efficacit\u00e9 gr\u00e2ce \u00e0 la taille r\u00e9duite du param\u00e8tre dont le cout est plus faible \u00e0 traiter. Z Indice 1 Pour une version facile, on pourra utiliser une fonction qui renvoie le nombre de z\u00e9ros d'un entier, on passera en argument la factorielle d'un entier. Apr\u00e8s avoir r\u00e9ussi. Tenter une version efficace avec l'indice 2. Indice 2 Pour une version efficace, on cherchera \u00e0 calculer l'augmentation du nombre de z\u00e9ros, d'une factorielle \u00e0 une autre, en fonction du nouveau facteur. Il s'agit du nombre de fois que l'on peut diviser par 5 ce nouveau facteur.","title":"Nombre de z\u00e9ros de n! (1)"},{"location":"3-difficile/fact1_nb_zeros/sujet/#nombre-de-zeros-de-n-factoriel-n-petit","text":"On rappelle que, pour \\(n\\) un entier naturel, la factorielle de \\(n\\) se note \\(n!\\) et se d\u00e9finit comme le produit des entiers de \\(1\\) \u00e0 \\(n\\) . \\(0! = 1\\) , comme un produit vide. \\(1! = 1\\) \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(11! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\u00d78\u00d79\u00d710\u00d711 = 39916800\\) \\(42! = 1405006117752879898543142606244511569936384000000000\\) On constate que \\(3!\\) se termine par aucun z\u00e9ro. \\(11!\\) se termine par 2 z\u00e9ros. \\(42!\\) se termine par 9 z\u00e9ros. Construire un tableau de longueur 1000, tel que nb_zeros_factorielle[n] contient le nombre de z\u00e9ros dans l'\u00e9criture d\u00e9cimale de \\(n!\\) , pour \\(n\\) entier inf\u00e9rieur \u00e0 \\(1000\\) . Exemples \ud83d\udc0d Console Python >>> nb_zeros_factorielle [ 3 ] 0 >>> nb_zeros_factorielle [ 11 ] 2 >>> nb_zeros_factorielle [ 42 ] 9 >>> len ( nb_zeros_factorielle ) >= 1000 True Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineNBpython-underscoreZEROS = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 47, 47, 47, 47, 47, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 62, 62, 62, 62, 62, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 66, 66, 66, 66, 66, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 83, 83, 83, 83, 83, 84, 84, 84, 84, 84, 86, 86, 86, 86, 86, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90, 93, 93, 93, 93, 93, 94, 94, 94, 94, 94, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 99, 99, 99, 99, 99, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 102, 102, 102, 102, 102, 103, 103, 103, 103, 103, 105, 105, 105, 105, 105, 106, 106, 106, 106, 106, 107, 107, 107, 107, 107, 108, 108, 108, 108, 108, 109, 109, 109, 109, 109, 111, 111, 111, 111, 111, 112, 112, 112, 112, 112, 113, 113, 113, 113, 113, 114, 114, 114, 114, 114, 115, 115, 115, 115, 115, 117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 119, 119, 119, 119, 119, 120, 120, 120, 120, 120, 121, 121, 121, 121, 121, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 126, 126, 126, 126, 126, 127, 127, 127, 127, 127, 128, 128, 128, 128, 128, 130, 130, 130, 130, 130, 131, 131, 131, 131, 131, 132, 132, 132, 132, 132, 133, 133, 133, 133, 133, 134, 134, 134, 134, 134, 136, 136, 136, 136, 136, 137, 137, 137, 137, 137, 138, 138, 138, 138, 138, 139, 139, 139, 139, 139, 140, 140, 140, 140, 140, 142, 142, 142, 142, 142, 143, 143, 143, 143, 143, 144, 144, 144, 144, 144, 145, 145, 145, 145, 145, 146, 146, 146, 146, 146, 148, 148, 148, 148, 148, 149, 149, 149, 149, 149, 150, 150, 150, 150, 150, 151, 151, 151, 151, 151, 152, 152, 152, 152, 152, 156, 156, 156, 156, 156, 157, 157, 157, 157, 157, 158, 158, 158, 158, 158, 159, 159, 159, 159, 159, 160, 160, 160, 160, 160, 162, 162, 162, 162, 162, 163, 163, 163, 163, 163, 164, 164, 164, 164, 164, 165, 165, 165, 165, 165, 166, 166, 166, 166, 166, 168, 168, 168, 168, 168, 169, 169, 169, 169, 169, 170, 170, 170, 170, 170, 171, 171, 171, 171, 171, 172, 172, 172, 172, 172, 174, 174, 174, 174, 174, 175, 175, 175, 175, 175, 176, 176, 176, 176, 176, 177, 177, 177, 177, 177, 178, 178, 178, 178, 178, 180, 180, 180, 180, 180, 181, 181, 181, 181, 181, 182, 182, 182, 182, 182, 183, 183, 183, 183, 183, 184, 184, 184, 184, 184, 187, 187, 187, 187, 187, 188, 188, 188, 188, 188, 189, 189, 189, 189, 189, 190, 190, 190, 190, 190, 191, 191, 191, 191, 191, 193, 193, 193, 193, 193, 194, 194, 194, 194, 194, 195, 195, 195, 195, 195, 196, 196, 196, 196, 196, 197, 197, 197, 197, 197, 199, 199, 199, 199, 199, 200, 200, 200, 200, 200, 201, 201, 201, 201, 201, 202, 202, 202, 202, 202, 203, 203, 203, 203, 203, 205, 205, 205, 205, 205, 206, 206, 206, 206, 206, 207, 207, 207, 207, 207, 208, 208, 208, 208, 208, 209, 209, 209, 209, 209, 211, 211, 211, 211, 211, 212, 212, 212, 212, 212, 213, 213, 213, 213, 213, 214, 214, 214, 214, 214, 215, 215, 215, 215, 215, 218, 218, 218, 218, 218, 219, 219, 219, 219, 219, 220, 220, 220, 220, 220, 221, 221, 221, 221, 221, 222, 222, 222, 222, 222, 224, 224, 224, 224, 224, 225, 225, 225, 225, 225, 226, 226, 226, 226, 226, 227, 227, 227, 227, 227, 228, 228, 228, 228, 228, 230, 230, 230, 230, 230, 231, 231, 231, 231, 231, 232, 232, 232, 232, 232, 233, 233, 233, 233, 233, 234, 234, 234, 234, 234, 236, 236, 236, 236, 236, 237, 237, 237, 237, 237, 238, 238, 238, 238, 238, 239, 239, 239, 239, 239, 240, 240, 240, 240, 240, 242, 242, 242, 242, 242, 243, 243, 243, 243, 243, 244, 244, 244, 244, 244, 245, 245, 245, 245, 245, 246, 246, 246, 246, 246]backslash-newlinebackslash-newlinefor n, attendu in enumerate(NBpython-underscoreZEROS):backslash-newline assert nbpython-underscorezerospython-underscorefactorielle[n] == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 nbpython-underscorezerospython-underscorefactorielle = [...]backslash-newline...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newline nbpython-underscorezerospython-underscorefactorielle = [0]backslash-newlinebackslash-newlinedef nbpython-underscorezeros(n):backslash-newline resultat = 0backslash-newline while n % 10 == 0:backslash-newline n //= 10backslash-newline resultat += 1backslash-newline return resultatbackslash-newlinebackslash-newlinefactorielle = 1backslash-newlinefor n in range(1, 1000):backslash-newline factorielle python-star= nbackslash-newline suivant = nbpython-underscorezeros(factorielle)backslash-newline nbpython-underscorezerospython-underscorefactorielle.append(suivant)backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[3] == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[11] == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle[42] == 9backslash-newlinebackslash-newlineassert len(nbpython-underscorezerospython-underscorefactorielle) >= 1000backslash-newlinebackslash-newline A","title":"Nombre de z\u00e9ros de n factoriel ; n petit"},{"location":"3-difficile/fact1_nb_zeros/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/fact1_nb_zeros/sujet/#version-simple","text":"\ud83d\udc0d Script Python nb_zeros_factorielle = [ 0 ] def nb_zeros ( n ): resultat = 0 while n % 10 == 0 : n //= 10 resultat += 1 return resultat factorielle = 1 for n in range ( 1 , 1000 ): factorielle *= n suivant = nb_zeros ( factorielle ) nb_zeros_factorielle . append ( suivant ) Ici, on appelle la fonction nb_zeros sur un nombre factoriel qui est tr\u00e8s grand .","title":"Version simple"},{"location":"3-difficile/fact1_nb_zeros/sujet/#version-efficace","text":"\ud83d\udc0d Script Python def nb_facteurs_5 ( n ): resultat = 0 while n % 5 == 0 : n //= 5 resultat += 1 return resultat nb_zeros_factorielle = [ 0 ] for n in range ( 1 , 1000 ): apport = nb_facteurs_5 ( n ) suivant = nb_zeros_factorielle [ n - 1 ] + apport nb_zeros_factorielle . append ( suivant ) Cette version ressemble beaucoup \u00e0 la pr\u00e9c\u00e9dente ; presque la m\u00eame fonction. La diff\u00e9rence essentielle est qu'ici nb_facteurs est appel\u00e9 avec un nombre petit en param\u00e8tre. \u00c0 m\u00e9diter. Cette diff\u00e9rence subtile est tr\u00e8s importante. Ici, on gagne s\u00e9rieusement en efficacit\u00e9 gr\u00e2ce \u00e0 la taille r\u00e9duite du param\u00e8tre dont le cout est plus faible \u00e0 traiter. Z Indice 1 Pour une version facile, on pourra utiliser une fonction qui renvoie le nombre de z\u00e9ros d'un entier, on passera en argument la factorielle d'un entier. Apr\u00e8s avoir r\u00e9ussi. Tenter une version efficace avec l'indice 2. Indice 2 Pour une version efficace, on cherchera \u00e0 calculer l'augmentation du nombre de z\u00e9ros, d'une factorielle \u00e0 une autre, en fonction du nouveau facteur. Il s'agit du nombre de fois que l'on peut diviser par 5 ce nouveau facteur.","title":"Version efficace"},{"location":"3-difficile/nb_catalan_2/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python # Initialisation da la suite des r\u00c3\u00a9sultats catalan_mem = [ 1 ] La premi\u00e8re partie \u00e0 compl\u00e9ter est \u00e0 la fin return catalan_mem [ n ] , on souhaite la valeur d'indice \\(n\\) de cette liste. Ou bien n >= len ( catalan_mem ) auquel cas on peut r\u00e9pondre directement, sinon, il faut le calculer et l'ajouter \u00e0 la liste, ce qui se fait \u00e0 la ligne pr\u00e9c\u00e9dente. somme_cas est une somme des cas, initialis\u00e9e \u00e0 \\(0\\) \u00e0 la ligne 6. Il y a \\(n\\) cas \u00e0 \u00e9tudier de \\((0, n-1)\\) , \\((1, n-2)\\) , \\(\\cdots\\) , \\((n-2, 1)\\) , \\((n-1, 0)\\) . La boucle for i in range ( n ): fera bien \\(n\\) tours. au premier tour \\(i=0\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1\\) au tour suivant \\(i=1\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-2\\) de mani\u00e8re g\u00e9n\u00e9rale, l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1-i\\) La formule pour le cas en \\(i\\) est donc nb_arbres_binaires ( i ) * nb_arbres_binaires ( n - 1 - i ) Justifions le commentaire ligne 9 # Ici, catalan_mem sera de longueur n Si on est entr\u00e9 dans la structure conditionnelle, c'est que n < len(catalan_mem) Mais \u00e0 l'issue de la boucle nb_arbres_binaires(n - 1) a \u00e9t\u00e9 appel\u00e9, et donc catalan_mem a d\u00e9j\u00e0 \u00e9t\u00e9 mis \u00e0 jour de mani\u00e8re r\u00e9cursive, et il est donc de longueur n . On peut ainsi compl\u00e9ter la ligne 10 catalan_mem . append ( somme_cas ) . Il existe d'autres m\u00e9thodes de calcul, plus efficaces.","title":"Commentaires"},{"location":"3-difficile/nb_catalan_2/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python # Initialisation da la suite des r\u00c3\u00a9sultats catalan_mem = [ 1 ] La premi\u00e8re partie \u00e0 compl\u00e9ter est \u00e0 la fin return catalan_mem [ n ] , on souhaite la valeur d'indice \\(n\\) de cette liste. Ou bien n >= len ( catalan_mem ) auquel cas on peut r\u00e9pondre directement, sinon, il faut le calculer et l'ajouter \u00e0 la liste, ce qui se fait \u00e0 la ligne pr\u00e9c\u00e9dente. somme_cas est une somme des cas, initialis\u00e9e \u00e0 \\(0\\) \u00e0 la ligne 6. Il y a \\(n\\) cas \u00e0 \u00e9tudier de \\((0, n-1)\\) , \\((1, n-2)\\) , \\(\\cdots\\) , \\((n-2, 1)\\) , \\((n-1, 0)\\) . La boucle for i in range ( n ): fera bien \\(n\\) tours. au premier tour \\(i=0\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1\\) au tour suivant \\(i=1\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-2\\) de mani\u00e8re g\u00e9n\u00e9rale, l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1-i\\) La formule pour le cas en \\(i\\) est donc nb_arbres_binaires ( i ) * nb_arbres_binaires ( n - 1 - i ) Justifions le commentaire ligne 9 # Ici, catalan_mem sera de longueur n Si on est entr\u00e9 dans la structure conditionnelle, c'est que n < len(catalan_mem) Mais \u00e0 l'issue de la boucle nb_arbres_binaires(n - 1) a \u00e9t\u00e9 appel\u00e9, et donc catalan_mem a d\u00e9j\u00e0 \u00e9t\u00e9 mis \u00e0 jour de mani\u00e8re r\u00e9cursive, et il est donc de longueur n . On peut ainsi compl\u00e9ter la ligne 10 catalan_mem . append ( somme_cas ) . Il existe d'autres m\u00e9thodes de calcul, plus efficaces.","title":"Commentaires"},{"location":"3-difficile/nb_catalan_2/sujet/","tags":["maths","r\u00e9cursivit\u00e9","arbre"],"text":"\u00c9num\u00e9ration des arbres binaires de taille n \u2693\ufe0e Il y a 1 arbre binaire de taille 0. Il y a 1 arbre binaire de taille 1. Il y a 2 arbres binaires de taille 2. Il y a 5 arbres binaires de taille 3. Il y a 14 arbres binaires de taille 4. Arbres binaires de taille 4 Les 14 arbres binaires de taille 4, peuvent \u00eatre r\u00e9partis en fonction de la taille des sous arbres. Il y a un n\u0153ud racine et 3 autres n\u0153uds \u00e0 r\u00e9partir \u00e0 gauche ( \\(t_g\\) ) et \u00e0 droite ( \\(t_d\\) ). \\[(1 + t_g + t_d = 4)\\] \\((t_g=0, t_d=3)\\) \\((t_g=1, t_d=2)\\) \\((t_g=2, t_d=1)\\) \\((t_g=3, t_d=0)\\) Objectif : \u00e9crire une fonction telle que nb_arbres_binaires(n) renvoie le nombre d'arbres binaires de taille n . Il existe plusieurs m\u00e9thodes de calcul. Voici une m\u00e9thode p\u00e9dagogique pour calculer ce nombre en fonction de n . Il s'agit des nombres de Catalan. Si la taille \\(n\\) vaut z\u00e9ro, renvoyer \\(1\\) . Il y a un seul arbre \u00e0 z\u00e9ro n\u0153ud, un arbre vide. Sinon, l'arbre poss\u00e8de une racine et deux sous-arbres. Les tailles possibles pour les sous-arbres sont : \\(0\\) \u00e0 gauche et \\(n-1\\) \u00e0 droite \\(1\\) \u00e0 gauche et \\(n-2\\) \u00e0 droite \\(2\\) \u00e0 gauche et \\(n-3\\) \u00e0 droite ... \\(n-3\\) \u00e0 gauche et \\(2\\) \u00e0 droite \\(n-2\\) \u00e0 gauche et \\(1\\) \u00e0 droite \\(n-1\\) \u00e0 gauche et \\(0\\) \u00e0 droite renvoyer la somme du nombre d'arbres dans chaque cas. Indices Pour un arbre binaire de taille \\(5\\) , il y a un n\u0153ud racine et \\(4\\) autres n\u0153uds. Ces derniers peuvent se r\u00e9partir en \\((0, 4)\\) , \\((1, 3)\\) , \\((2, 2)\\) , \\((3, 1)\\) , \\((4, 0)\\) \u00e0 gauche et \u00e0 droite. Pour \\((0, 4)\\) , il y a \\(1\\) sous-arbre \u00e0 gauche possible, \u00e0 0 n\u0153ud, \\(14\\) sous-arbres \u00e0 droite possibles \u00e0 4 n\u0153uds, ainsi \\(1\u00d714\\) possibilit\u00e9s de choisir un arbre binaire de taille \\(0\\) \u00e0 gauche et de taille \\(4\\) \u00e0 droite. Pour \\((1, 3)\\) , il y a \\(1\\) sous-arbre \u00e0 gauche possible \u00e0 1 n\u0153ud, \\(5\\) sous-arbres \u00e0 droite possibles \u00e0 3 n\u0153uds, donc \\(1\u00d75\\) possibilit\u00e9s pour ce cas. Pour \\((2, 2)\\) , il y a \\(2\u00d72\\) possibilit\u00e9s. Pour \\((3, 1)\\) , il y a \\(5\u00d71\\) possibilit\u00e9s. Pour \\((4, 0)\\) , il y a \\(14\u00d71\\) possibilit\u00e9s. Il y a donc \\(1\u00d714 + 1\u00d75 + 2\u00d72 + 5\u00d71 + 14\u00d71 = 42\\) arbres binaires de taille \\(5\\) . On stocke les r\u00e9sultats qui sont utilis\u00e9s souvent dans une liste catalan_mem , cette liste commence avec [1, 1, 2, 5, 14, 42] . Il est tr\u00e8s utile de mettre \u00e0 jour cette liste d\u00e8s que possible. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python # Initialisation da la suite des r\u00c3\u00a9sultats catalan_mem = [ 1 ] def nb_arbres_binaires ( n ): if n >= len ( catalan_mem ): somme_cas = ... for i in range ( ... ): somme_cas += nb_arbres_binaires ( ... ) * ... # Ici, catalan_mem sera de longueur n catalan_mem . append ( ... ) return catalan_mem [ ... ] Exemples \ud83d\udc0d Console Python >>> nb_arbres_binaires ( 3 ) 5 >>> nb_arbres_binaires ( 4 ) 14 >>> nb_arbres_binaires ( 5 ) 42 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineCATALAN = [backslash-newline 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,backslash-newline 208012, 742900, 2674440, 9694845, 35357670, 129644790,backslash-newline 477638700, 1767263190, 6564120420, 24466267020, 91482563640,backslash-newline 343059613650, 1289904147324, 4861946401452, 18367353072152,backslash-newline 69533550916004, 263747951750360, 1002242216651368, 3814986502092304backslash-newline]backslash-newlinebackslash-newlinefor (n, catalanpython-underscoren) in enumerate(CATALAN):backslash-newline assert nbpython-underscorearbrespython-underscorebinaires(n) == catalanpython-underscoren, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 # Initialisation da la suite des r\u00c3\u00a9sultatsbackslash-newlinecatalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef nbpython-underscorearbrespython-underscorebinaires(n):backslash-newline if n >= len(catalanpython-underscoremem):backslash-newline sommepython-underscorecas = ...backslash-newline for i in range(...):backslash-newline sommepython-underscorecas += nbpython-underscorearbrespython-underscorebinaires(...) python-star ...backslash-newline # Ici, catalanpython-underscoremem sera de longueur nbackslash-newline catalanpython-underscoremem.append(...)backslash-newline return catalanpython-underscoremem[...]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newline # Initialisation da la suite des r\u00c3\u00a9sultatsbackslash-newlinecatalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef nbpython-underscorearbrespython-underscorebinaires(n):backslash-newline if n >= len(catalanpython-underscoremem):backslash-newline sommepython-underscorecas = 0backslash-newline for i in range(n):backslash-newline sommepython-underscorecas += nbpython-underscorearbrespython-underscorebinaires(i) python-star nbpython-underscorearbrespython-underscorebinaires(n - 1 - i)backslash-newline # Ici, catalanpython-underscoremem sera de longueur nbackslash-newline catalanpython-underscoremem.append(sommepython-underscorecas)backslash-newline return catalanpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} La premi\u00e8re partie \u00e0 compl\u00e9ter est \u00e0 la fin return catalan_mem [ n ] , on souhaite la valeur d'indice \\(n\\) de cette liste. Ou bien n >= len ( catalan_mem ) auquel cas on peut r\u00e9pondre directement, sinon, il faut le calculer et l'ajouter \u00e0 la liste, ce qui se fait \u00e0 la ligne pr\u00e9c\u00e9dente. somme_cas est une somme des cas, initialis\u00e9e \u00e0 \\(0\\) \u00e0 la ligne 6. Il y a \\(n\\) cas \u00e0 \u00e9tudier de \\((0, n-1)\\) , \\((1, n-2)\\) , \\(\\cdots\\) , \\((n-2, 1)\\) , \\((n-1, 0)\\) . La boucle for i in range ( n ): fera bien \\(n\\) tours. au premier tour \\(i=0\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1\\) au tour suivant \\(i=1\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-2\\) de mani\u00e8re g\u00e9n\u00e9rale, l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1-i\\) La formule pour le cas en \\(i\\) est donc nb_arbres_binaires ( i ) * nb_arbres_binaires ( n - 1 - i ) Justifions le commentaire ligne 9 # Ici, catalan_mem sera de longueur n Si on est entr\u00e9 dans la structure conditionnelle, c'est que n < len(catalan_mem) Mais \u00e0 l'issue de la boucle nb_arbres_binaires(n - 1) a \u00e9t\u00e9 appel\u00e9, et donc catalan_mem a d\u00e9j\u00e0 \u00e9t\u00e9 mis \u00e0 jour de mani\u00e8re r\u00e9cursive, et il est donc de longueur n . On peut ainsi compl\u00e9ter la ligne 10 catalan_mem . append ( somme_cas ) . Il existe d'autres m\u00e9thodes de calcul, plus efficaces. Z","title":"Nombres de Catalan II"},{"location":"3-difficile/nb_catalan_2/sujet/#enumeration-des-arbres-binaires-de-taille-n","text":"Il y a 1 arbre binaire de taille 0. Il y a 1 arbre binaire de taille 1. Il y a 2 arbres binaires de taille 2. Il y a 5 arbres binaires de taille 3. Il y a 14 arbres binaires de taille 4. Arbres binaires de taille 4 Les 14 arbres binaires de taille 4, peuvent \u00eatre r\u00e9partis en fonction de la taille des sous arbres. Il y a un n\u0153ud racine et 3 autres n\u0153uds \u00e0 r\u00e9partir \u00e0 gauche ( \\(t_g\\) ) et \u00e0 droite ( \\(t_d\\) ). \\[(1 + t_g + t_d = 4)\\] \\((t_g=0, t_d=3)\\) \\((t_g=1, t_d=2)\\) \\((t_g=2, t_d=1)\\) \\((t_g=3, t_d=0)\\) Objectif : \u00e9crire une fonction telle que nb_arbres_binaires(n) renvoie le nombre d'arbres binaires de taille n . Il existe plusieurs m\u00e9thodes de calcul. Voici une m\u00e9thode p\u00e9dagogique pour calculer ce nombre en fonction de n . Il s'agit des nombres de Catalan. Si la taille \\(n\\) vaut z\u00e9ro, renvoyer \\(1\\) . Il y a un seul arbre \u00e0 z\u00e9ro n\u0153ud, un arbre vide. Sinon, l'arbre poss\u00e8de une racine et deux sous-arbres. Les tailles possibles pour les sous-arbres sont : \\(0\\) \u00e0 gauche et \\(n-1\\) \u00e0 droite \\(1\\) \u00e0 gauche et \\(n-2\\) \u00e0 droite \\(2\\) \u00e0 gauche et \\(n-3\\) \u00e0 droite ... \\(n-3\\) \u00e0 gauche et \\(2\\) \u00e0 droite \\(n-2\\) \u00e0 gauche et \\(1\\) \u00e0 droite \\(n-1\\) \u00e0 gauche et \\(0\\) \u00e0 droite renvoyer la somme du nombre d'arbres dans chaque cas. Indices Pour un arbre binaire de taille \\(5\\) , il y a un n\u0153ud racine et \\(4\\) autres n\u0153uds. Ces derniers peuvent se r\u00e9partir en \\((0, 4)\\) , \\((1, 3)\\) , \\((2, 2)\\) , \\((3, 1)\\) , \\((4, 0)\\) \u00e0 gauche et \u00e0 droite. Pour \\((0, 4)\\) , il y a \\(1\\) sous-arbre \u00e0 gauche possible, \u00e0 0 n\u0153ud, \\(14\\) sous-arbres \u00e0 droite possibles \u00e0 4 n\u0153uds, ainsi \\(1\u00d714\\) possibilit\u00e9s de choisir un arbre binaire de taille \\(0\\) \u00e0 gauche et de taille \\(4\\) \u00e0 droite. Pour \\((1, 3)\\) , il y a \\(1\\) sous-arbre \u00e0 gauche possible \u00e0 1 n\u0153ud, \\(5\\) sous-arbres \u00e0 droite possibles \u00e0 3 n\u0153uds, donc \\(1\u00d75\\) possibilit\u00e9s pour ce cas. Pour \\((2, 2)\\) , il y a \\(2\u00d72\\) possibilit\u00e9s. Pour \\((3, 1)\\) , il y a \\(5\u00d71\\) possibilit\u00e9s. Pour \\((4, 0)\\) , il y a \\(14\u00d71\\) possibilit\u00e9s. Il y a donc \\(1\u00d714 + 1\u00d75 + 2\u00d72 + 5\u00d71 + 14\u00d71 = 42\\) arbres binaires de taille \\(5\\) . On stocke les r\u00e9sultats qui sont utilis\u00e9s souvent dans une liste catalan_mem , cette liste commence avec [1, 1, 2, 5, 14, 42] . Il est tr\u00e8s utile de mettre \u00e0 jour cette liste d\u00e8s que possible. Compl\u00e9ter le code suivant : \ud83d\udc0d Script Python # Initialisation da la suite des r\u00c3\u00a9sultats catalan_mem = [ 1 ] def nb_arbres_binaires ( n ): if n >= len ( catalan_mem ): somme_cas = ... for i in range ( ... ): somme_cas += nb_arbres_binaires ( ... ) * ... # Ici, catalan_mem sera de longueur n catalan_mem . append ( ... ) return catalan_mem [ ... ] Exemples \ud83d\udc0d Console Python >>> nb_arbres_binaires ( 3 ) 5 >>> nb_arbres_binaires ( 4 ) 14 >>> nb_arbres_binaires ( 5 ) 42 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineCATALAN = [backslash-newline 1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786,backslash-newline 208012, 742900, 2674440, 9694845, 35357670, 129644790,backslash-newline 477638700, 1767263190, 6564120420, 24466267020, 91482563640,backslash-newline 343059613650, 1289904147324, 4861946401452, 18367353072152,backslash-newline 69533550916004, 263747951750360, 1002242216651368, 3814986502092304backslash-newline]backslash-newlinebackslash-newlinefor (n, catalanpython-underscoren) in enumerate(CATALAN):backslash-newline assert nbpython-underscorearbrespython-underscorebinaires(n) == catalanpython-underscoren, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 # Initialisation da la suite des r\u00c3\u00a9sultatsbackslash-newlinecatalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef nbpython-underscorearbrespython-underscorebinaires(n):backslash-newline if n >= len(catalanpython-underscoremem):backslash-newline sommepython-underscorecas = ...backslash-newline for i in range(...):backslash-newline sommepython-underscorecas += nbpython-underscorearbrespython-underscorebinaires(...) python-star ...backslash-newline # Ici, catalanpython-underscoremem sera de longueur nbackslash-newline catalanpython-underscoremem.append(...)backslash-newline return catalanpython-underscoremem[...]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newline # Initialisation da la suite des r\u00c3\u00a9sultatsbackslash-newlinecatalanpython-underscoremem = [1]backslash-newlinebackslash-newlinedef nbpython-underscorearbrespython-underscorebinaires(n):backslash-newline if n >= len(catalanpython-underscoremem):backslash-newline sommepython-underscorecas = 0backslash-newline for i in range(n):backslash-newline sommepython-underscorecas += nbpython-underscorearbrespython-underscorebinaires(i) python-star nbpython-underscorearbrespython-underscorebinaires(n - 1 - i)backslash-newline # Ici, catalanpython-underscoremem sera de longueur nbackslash-newline catalanpython-underscoremem.append(sommepython-underscorecas)backslash-newline return catalanpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(3) == 5backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(4) == 14backslash-newlineassert nbpython-underscorearbrespython-underscorebinaires(5) == 42backslash-newlinebackslash-newline A","title":"\u00c9num\u00e9ration des arbres binaires de taille n"},{"location":"3-difficile/nb_catalan_2/sujet/#commentaires","text":"{{ py('exo_corr') }} La premi\u00e8re partie \u00e0 compl\u00e9ter est \u00e0 la fin return catalan_mem [ n ] , on souhaite la valeur d'indice \\(n\\) de cette liste. Ou bien n >= len ( catalan_mem ) auquel cas on peut r\u00e9pondre directement, sinon, il faut le calculer et l'ajouter \u00e0 la liste, ce qui se fait \u00e0 la ligne pr\u00e9c\u00e9dente. somme_cas est une somme des cas, initialis\u00e9e \u00e0 \\(0\\) \u00e0 la ligne 6. Il y a \\(n\\) cas \u00e0 \u00e9tudier de \\((0, n-1)\\) , \\((1, n-2)\\) , \\(\\cdots\\) , \\((n-2, 1)\\) , \\((n-1, 0)\\) . La boucle for i in range ( n ): fera bien \\(n\\) tours. au premier tour \\(i=0\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1\\) au tour suivant \\(i=1\\) , l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-2\\) de mani\u00e8re g\u00e9n\u00e9rale, l'autre \u00e9l\u00e9ment du couple devra \u00eatre \\(n-1-i\\) La formule pour le cas en \\(i\\) est donc nb_arbres_binaires ( i ) * nb_arbres_binaires ( n - 1 - i ) Justifions le commentaire ligne 9 # Ici, catalan_mem sera de longueur n Si on est entr\u00e9 dans la structure conditionnelle, c'est que n < len(catalan_mem) Mais \u00e0 l'issue de la boucle nb_arbres_binaires(n - 1) a \u00e9t\u00e9 appel\u00e9, et donc catalan_mem a d\u00e9j\u00e0 \u00e9t\u00e9 mis \u00e0 jour de mani\u00e8re r\u00e9cursive, et il est donc de longueur n . On peut ainsi compl\u00e9ter la ligne 10 catalan_mem . append ( somme_cas ) . Il existe d'autres m\u00e9thodes de calcul, plus efficaces. Z","title":"Commentaires"},{"location":"3-difficile/nb_chemins_grille/exo_REM/","text":"Commentaires \u2693\ufe0e Version du sujet \u2693\ufe0e \ud83d\udc0d Script Python nb_chemins_mem = dict () Une adaptation directe des indications de l'\u00e9nonc\u00e9. Compl\u00e9ments \u2693\ufe0e Un chemin pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) peut \u00eatre d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de 4 'E' et 3 'N' . Par exemple, \"EENENNE\" d\u00e9crit Il y a autant de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) que de chaines de caract\u00e8res compos\u00e9es de 4 'E' et 3 'N' . Comment les compter ? Il y a \\(4+3 = 7\\) caract\u00e8res. Il y a \\(4\\) choix possibles parmi les 7 places pour placer les 'E' . Ensuite, les 'N' prennent les 3 places restantes, sans avoir le choix, de mani\u00e8re unique. Le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) est le nombre de fa\u00e7ons de choisir 4 places parmi 7. De mani\u00e8re g\u00e9n\u00e9rale, le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((n, m)\\) est le nombre de fa\u00e7ons de choisir \\(n\\) places parmi \\(n+m\\) . En cours de math\u00e9matiques, on peut voir que ce nombre est : \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Par exemple, \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = \\dfrac{5\u00d7\\cancel{6}\u00d77}{1\u00d7\\cancel{2\u00d73}} = 35\\]","title":"Commentaires"},{"location":"3-difficile/nb_chemins_grille/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/nb_chemins_grille/exo_REM/#version-du-sujet","text":"\ud83d\udc0d Script Python nb_chemins_mem = dict () Une adaptation directe des indications de l'\u00e9nonc\u00e9.","title":"Version du sujet"},{"location":"3-difficile/nb_chemins_grille/exo_REM/#complements","text":"Un chemin pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) peut \u00eatre d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de 4 'E' et 3 'N' . Par exemple, \"EENENNE\" d\u00e9crit Il y a autant de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) que de chaines de caract\u00e8res compos\u00e9es de 4 'E' et 3 'N' . Comment les compter ? Il y a \\(4+3 = 7\\) caract\u00e8res. Il y a \\(4\\) choix possibles parmi les 7 places pour placer les 'E' . Ensuite, les 'N' prennent les 3 places restantes, sans avoir le choix, de mani\u00e8re unique. Le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) est le nombre de fa\u00e7ons de choisir 4 places parmi 7. De mani\u00e8re g\u00e9n\u00e9rale, le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((n, m)\\) est le nombre de fa\u00e7ons de choisir \\(n\\) places parmi \\(n+m\\) . En cours de math\u00e9matiques, on peut voir que ce nombre est : \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Par exemple, \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = \\dfrac{5\u00d7\\cancel{6}\u00d77}{1\u00d7\\cancel{2\u00d73}} = 35\\]","title":"Compl\u00e9ments"},{"location":"3-difficile/nb_chemins_grille/sujet/","tags":["maths","r\u00e9cursivit\u00e9","dictionnaire","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des chemins dans une petite grille \u2693\ufe0e Dans une grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) Ceux passant par \\((3, 3)\\) , il y en a 20. Ceux passant par \\((4, 2)\\) , il y en a 15. \u00c9crire une fonction telle que nb_chemins(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on remarquera : Si n ou m est nul, alors le seul chemin est en ligne droite, la r\u00e9ponse est 1 , sinon : n et m sont non nuls et les chemins qui vont en (n, m) se r\u00e9partissent en deux cat\u00e9gories : ceux qui venaient de (n - 1, m ) , ceux qui venaient de (n , m - 1) , ces deux cat\u00e9gories sont distinctes et se comptent bien par r\u00e9cursivit\u00e9. On utilisera un dictionnaire pour m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. On compl\u00e8tera le code : \ud83d\udc0d Script Python nb_chemins_mem = dict () def nb_chemins ( n , m ): if ( n , m ) not in nb_chemins_mem : if ( n == 0 ) or ( ... ): resultat = ... else : resultat = ( nb_chemins ( ... , ... ) + ... ) nb_chemins_mem [( n , m )] = ... return ... Exemples \ud83d\udc0d Console Python >>> nb_chemins ( 3 , 3 ) 20 >>> nb_chemins ( 4 , 2 ) 15 >>> nb_chemins ( 4 , 3 ) 35 Contraintes : Ici, \\(0\\leqslant n \\leqslant 20\\) et \\(0\\leqslant m \\leqslant 20\\) . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineNBpython-underscoreCHEMINS = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, ],backslash-newline [1, 2, 3, 4, 5, 6, 7, 8, 9, ],backslash-newline [1, 3, 6, 10, 15, 21, 28, 36, 45, ],backslash-newline [1, 4, 10, 20, 35, 56, 84, 120, 165, ],backslash-newline [1, 5, 15, 35, 70, 126, 210, 330, 495, ],backslash-newline [1, 6, 21, 56, 126, 252, 462, 792, 1287, ],backslash-newline [1, 7, 28, 84, 210, 462, 924, 1716, 3003, ],backslash-newline [1, 8, 36, 120, 330, 792, 1716, 3432, 6435, ],backslash-newline [1, 9, 45, 165, 495, 1287, 3003, 6435, 12870, ],backslash-newline]backslash-newlinebackslash-newlinefor n in range(9):backslash-newline for m in range(9):backslash-newline attendu = NBpython-underscoreCHEMINS[n][m]backslash-newline assert nbpython-underscorechemins(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}.\"backslash-newlinebackslash-newline Valider 5/5 nbpython-underscorecheminspython-underscoremem = dict()backslash-newlinebackslash-newlinedef nbpython-underscorechemins(n, m):backslash-newline if (n, m) not in nbpython-underscorecheminspython-underscoremem:backslash-newline if (n == 0) or (...):backslash-newline resultat = ...backslash-newline else:backslash-newline resultat = (backslash-newline nbpython-underscorechemins(..., ...)backslash-newline + ...backslash-newline )backslash-newline nbpython-underscorecheminspython-underscoremem[(n, m)] = ...backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline nbpython-underscorecheminspython-underscoremem = dict()backslash-newlinebackslash-newlinedef nbpython-underscorechemins(n, m):backslash-newline if (n, m) not in nbpython-underscorecheminspython-underscoremem:backslash-newline if (n == 0) or (m == 0):backslash-newline resultat = 1backslash-newline else:backslash-newline resultat = (backslash-newline nbpython-underscorechemins(n - 1, m )backslash-newline + nbpython-underscorechemins(n, m - 1)backslash-newline )backslash-newline nbpython-underscorecheminspython-underscoremem[(n, m)] = resultatbackslash-newline return nbpython-underscorecheminspython-underscoremem[(n, m)]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Version du sujet \u2693\ufe0e {{ py('exo_corr') }} Une adaptation directe des indications de l'\u00e9nonc\u00e9. Compl\u00e9ments \u2693\ufe0e Un chemin pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) peut \u00eatre d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de 4 'E' et 3 'N' . Par exemple, \"EENENNE\" d\u00e9crit Il y a autant de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) que de chaines de caract\u00e8res compos\u00e9es de 4 'E' et 3 'N' . Comment les compter ? Il y a \\(4+3 = 7\\) caract\u00e8res. Il y a \\(4\\) choix possibles parmi les 7 places pour placer les 'E' . Ensuite, les 'N' prennent les 3 places restantes, sans avoir le choix, de mani\u00e8re unique. Le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) est le nombre de fa\u00e7ons de choisir 4 places parmi 7. De mani\u00e8re g\u00e9n\u00e9rale, le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((n, m)\\) est le nombre de fa\u00e7ons de choisir \\(n\\) places parmi \\(n+m\\) . En cours de math\u00e9matiques, on peut voir que ce nombre est : \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Par exemple, \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = \\dfrac{5\u00d7\\cancel{6}\u00d77}{1\u00d7\\cancel{2\u00d73}} = 35\\] Z","title":"Nombres de chemins dans une grille"},{"location":"3-difficile/nb_chemins_grille/sujet/#enumeration-des-chemins-dans-une-petite-grille","text":"Dans une grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) Ceux passant par \\((3, 3)\\) , il y en a 20. Ceux passant par \\((4, 2)\\) , il y en a 15. \u00c9crire une fonction telle que nb_chemins(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on remarquera : Si n ou m est nul, alors le seul chemin est en ligne droite, la r\u00e9ponse est 1 , sinon : n et m sont non nuls et les chemins qui vont en (n, m) se r\u00e9partissent en deux cat\u00e9gories : ceux qui venaient de (n - 1, m ) , ceux qui venaient de (n , m - 1) , ces deux cat\u00e9gories sont distinctes et se comptent bien par r\u00e9cursivit\u00e9. On utilisera un dictionnaire pour m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. On compl\u00e8tera le code : \ud83d\udc0d Script Python nb_chemins_mem = dict () def nb_chemins ( n , m ): if ( n , m ) not in nb_chemins_mem : if ( n == 0 ) or ( ... ): resultat = ... else : resultat = ( nb_chemins ( ... , ... ) + ... ) nb_chemins_mem [( n , m )] = ... return ... Exemples \ud83d\udc0d Console Python >>> nb_chemins ( 3 , 3 ) 20 >>> nb_chemins ( 4 , 2 ) 15 >>> nb_chemins ( 4 , 3 ) 35 Contraintes : Ici, \\(0\\leqslant n \\leqslant 20\\) et \\(0\\leqslant m \\leqslant 20\\) . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineNBpython-underscoreCHEMINS = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1, ],backslash-newline [1, 2, 3, 4, 5, 6, 7, 8, 9, ],backslash-newline [1, 3, 6, 10, 15, 21, 28, 36, 45, ],backslash-newline [1, 4, 10, 20, 35, 56, 84, 120, 165, ],backslash-newline [1, 5, 15, 35, 70, 126, 210, 330, 495, ],backslash-newline [1, 6, 21, 56, 126, 252, 462, 792, 1287, ],backslash-newline [1, 7, 28, 84, 210, 462, 924, 1716, 3003, ],backslash-newline [1, 8, 36, 120, 330, 792, 1716, 3432, 6435, ],backslash-newline [1, 9, 45, 165, 495, 1287, 3003, 6435, 12870, ],backslash-newline]backslash-newlinebackslash-newlinefor n in range(9):backslash-newline for m in range(9):backslash-newline attendu = NBpython-underscoreCHEMINS[n][m]backslash-newline assert nbpython-underscorechemins(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}.\"backslash-newlinebackslash-newline Valider 5/5 nbpython-underscorecheminspython-underscoremem = dict()backslash-newlinebackslash-newlinedef nbpython-underscorechemins(n, m):backslash-newline if (n, m) not in nbpython-underscorecheminspython-underscoremem:backslash-newline if (n == 0) or (...):backslash-newline resultat = ...backslash-newline else:backslash-newline resultat = (backslash-newline nbpython-underscorechemins(..., ...)backslash-newline + ...backslash-newline )backslash-newline nbpython-underscorecheminspython-underscoremem[(n, m)] = ...backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline nbpython-underscorecheminspython-underscoremem = dict()backslash-newlinebackslash-newlinedef nbpython-underscorechemins(n, m):backslash-newline if (n, m) not in nbpython-underscorecheminspython-underscoremem:backslash-newline if (n == 0) or (m == 0):backslash-newline resultat = 1backslash-newline else:backslash-newline resultat = (backslash-newline nbpython-underscorechemins(n - 1, m )backslash-newline + nbpython-underscorechemins(n, m - 1)backslash-newline )backslash-newline nbpython-underscorecheminspython-underscoremem[(n, m)] = resultatbackslash-newline return nbpython-underscorecheminspython-underscoremem[(n, m)]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlinebackslash-newline A","title":"\u00c9num\u00e9ration des chemins dans une petite grille"},{"location":"3-difficile/nb_chemins_grille/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"3-difficile/nb_chemins_grille/sujet/#version-du-sujet","text":"{{ py('exo_corr') }} Une adaptation directe des indications de l'\u00e9nonc\u00e9.","title":"Version du sujet"},{"location":"3-difficile/nb_chemins_grille/sujet/#complements","text":"Un chemin pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) peut \u00eatre d\u00e9crit par une chaine de caract\u00e8res compos\u00e9e de 4 'E' et 3 'N' . Par exemple, \"EENENNE\" d\u00e9crit Il y a autant de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) que de chaines de caract\u00e8res compos\u00e9es de 4 'E' et 3 'N' . Comment les compter ? Il y a \\(4+3 = 7\\) caract\u00e8res. Il y a \\(4\\) choix possibles parmi les 7 places pour placer les 'E' . Ensuite, les 'N' prennent les 3 places restantes, sans avoir le choix, de mani\u00e8re unique. Le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) est le nombre de fa\u00e7ons de choisir 4 places parmi 7. De mani\u00e8re g\u00e9n\u00e9rale, le nombre de chemins pour aller de \\((0, 0)\\) \u00e0 \\((n, m)\\) est le nombre de fa\u00e7ons de choisir \\(n\\) places parmi \\(n+m\\) . En cours de math\u00e9matiques, on peut voir que ce nombre est : \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Par exemple, \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = \\dfrac{5\u00d7\\cancel{6}\u00d77}{1\u00d7\\cancel{2\u00d73}} = 35\\] Z","title":"Compl\u00e9ments"},{"location":"3-difficile/nb_delannoy/sujet/","tags":["maths+","r\u00e9cursivit\u00e9","dictionnaire","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des chemins de Delannoy \u2693\ufe0e Dans une grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. \u2197 Aller au Nord-Est en diagonale, sur le prochain n\u0153ud. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((3, 3)\\) \u00c9crire une fonction telle que delannoy(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on remarquera : Si n ou m est nul, alors le seul chemin est en ligne droite, la r\u00e9ponse est 1 , sinon : - n et m sont non nuls et les chemins qui vont en (n, m) se r\u00e9partissent en trois cat\u00e9gories : - ceux qui venaient de (n - 1, m ) , - ceux qui venaient de (n , m - 1) , - ceux qui venaient de (n - 1, m - 1) , ces trois cat\u00e9gories sont distinctes et se comptent bien par r\u00e9cursivit\u00e9. On utilisera un dictionnaire pour m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. On compl\u00e8tera le code : \ud83d\udc0d Script Python delannoy_mem = dict () def delannoy ( n , m ): if ( n , m ) not in delannoy_mem : if ( n == 0 ) or ( ... ): resultat = ... else : resultat = ... delannoy_mem [( n , m )] = ... return ... Exemples \ud83d\udc0d Console Python >>> delannoy ( 3 , 3 ) 63 >>> delannoy ( 2 , 1 ) 5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineDELANNOY = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 3, 5, 7, 9, 11, 13, 15, 17],backslash-newline [1, 5, 13, 25, 41, 61, 85, 113, 145],backslash-newline [1, 7, 25, 63, 129, 231, 377, 575, 833],backslash-newline [1, 9, 41, 129, 321, 681, 1289, 2241, 3649],backslash-newline [1, 11, 61, 231, 681, 1683, 3653, 7183, 13073],backslash-newline [1, 13, 85, 377, 1289, 3653, 8989, 19825, 40081],backslash-newline [1, 15, 113, 575, 2241, 7183, 19825, 48639, 108545],backslash-newline [1, 17, 145, 833, 3649, 13073, 40081, 108545, 265729],backslash-newline]backslash-newlinebackslash-newlinefor n in range(9):backslash-newline for m in range(9):backslash-newline attendu = DELANNOY[n][m]backslash-newline assert delannoy(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}.\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 delannoypython-underscoremem = dict()backslash-newlinebackslash-newlinedef delannoy(n, m):backslash-newline if (n, m) not in delannoypython-underscoremem:backslash-newline if (n == 0) or (...):backslash-newline resultat = ...backslash-newline else:backslash-newline resultat = ...backslash-newline delannoypython-underscoremem[(n, m)] = ...backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newline delannoypython-underscoremem = dict()backslash-newlinebackslash-newlinedef delannoy(n, m):backslash-newline if (n, m) not in delannoypython-underscoremem:backslash-newline if (n == 0) or (m == 0):backslash-newline resultat = 1backslash-newline else:backslash-newline resultat = (backslash-newline delannoy(n - 1, m )backslash-newline + delannoy(n, m - 1)backslash-newline + delannoy(n - 1, m - 1)backslash-newline )backslash-newline delannoypython-underscoremem[(n, m)] = resultatbackslash-newline return delannoypython-underscoremem[(n, m)]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newline A Z","title":"Nombres de Delannoy"},{"location":"3-difficile/nb_delannoy/sujet/#enumeration-des-chemins-de-delannoy","text":"Dans une grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. \u2197 Aller au Nord-Est en diagonale, sur le prochain n\u0153ud. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((3, 3)\\) \u00c9crire une fonction telle que delannoy(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on remarquera : Si n ou m est nul, alors le seul chemin est en ligne droite, la r\u00e9ponse est 1 , sinon : - n et m sont non nuls et les chemins qui vont en (n, m) se r\u00e9partissent en trois cat\u00e9gories : - ceux qui venaient de (n - 1, m ) , - ceux qui venaient de (n , m - 1) , - ceux qui venaient de (n - 1, m - 1) , ces trois cat\u00e9gories sont distinctes et se comptent bien par r\u00e9cursivit\u00e9. On utilisera un dictionnaire pour m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. On compl\u00e8tera le code : \ud83d\udc0d Script Python delannoy_mem = dict () def delannoy ( n , m ): if ( n , m ) not in delannoy_mem : if ( n == 0 ) or ( ... ): resultat = ... else : resultat = ... delannoy_mem [( n , m )] = ... return ... Exemples \ud83d\udc0d Console Python >>> delannoy ( 3 , 3 ) 63 >>> delannoy ( 2 , 1 ) 5 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineDELANNOY = [backslash-newline [1, 1, 1, 1, 1, 1, 1, 1, 1],backslash-newline [1, 3, 5, 7, 9, 11, 13, 15, 17],backslash-newline [1, 5, 13, 25, 41, 61, 85, 113, 145],backslash-newline [1, 7, 25, 63, 129, 231, 377, 575, 833],backslash-newline [1, 9, 41, 129, 321, 681, 1289, 2241, 3649],backslash-newline [1, 11, 61, 231, 681, 1683, 3653, 7183, 13073],backslash-newline [1, 13, 85, 377, 1289, 3653, 8989, 19825, 40081],backslash-newline [1, 15, 113, 575, 2241, 7183, 19825, 48639, 108545],backslash-newline [1, 17, 145, 833, 3649, 13073, 40081, 108545, 265729],backslash-newline]backslash-newlinebackslash-newlinefor n in range(9):backslash-newline for m in range(9):backslash-newline attendu = DELANNOY[n][m]backslash-newline assert delannoy(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}.\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 delannoypython-underscoremem = dict()backslash-newlinebackslash-newlinedef delannoy(n, m):backslash-newline if (n, m) not in delannoypython-underscoremem:backslash-newline if (n == 0) or (...):backslash-newline resultat = ...backslash-newline else:backslash-newline resultat = ...backslash-newline delannoypython-underscoremem[(n, m)] = ...backslash-newline return ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newline delannoypython-underscoremem = dict()backslash-newlinebackslash-newlinedef delannoy(n, m):backslash-newline if (n, m) not in delannoypython-underscoremem:backslash-newline if (n == 0) or (m == 0):backslash-newline resultat = 1backslash-newline else:backslash-newline resultat = (backslash-newline delannoy(n - 1, m )backslash-newline + delannoy(n, m - 1)backslash-newline + delannoy(n - 1, m - 1)backslash-newline )backslash-newline delannoypython-underscoremem[(n, m)] = resultatbackslash-newline return delannoypython-underscoremem[(n, m)]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert delannoy(3, 3) == 63backslash-newlineassert delannoy(2, 1) == 5backslash-newlinebackslash-newline A Z","title":"\u00c9num\u00e9ration des chemins de Delannoy"},{"location":"3-difficile/nb_hipparque/sujet/","tags":["maths+","r\u00e9cursivit\u00e9","m\u00e9mo"],"text":"Subdivisions de polygone \u2693\ufe0e Les nombres d'Hipparque sont nomm\u00e9s d'apr\u00e8s le math\u00e9maticien et astronome grec, qui, selon Plutarque, connaissait certainement ces nombres. Culture Hipparque a \u00e9t\u00e9 actif en Gr\u00e8ce, au moins entre 147 et 127 av. J.-C. Plutarque est un philosophe majeur de la Rome antique, qui a v\u00e9cu de 46 \u00e0 125, soit deux si\u00e8cles apr\u00e8s Hipparque. Les \\(s_4=11\\) subdivisions d'un pentagone On admettra que : Le \\(n\\) -i\u00e8me nombre \\(s_n\\) de la suite est le nombre de subdivisions d'un polygone \u00e0 \\(n + 1\\) c\u00f4t\u00e9s en polygones plus petits par l'adjonction de diagonales au polygone de d\u00e9part. \\(s_1=s_2=1\\) Une formule pour calculer \\(s_n\\) avec \\(n>1\\) est : \\[s_n = \\frac1n\\left((6n-9)s(n-1) - (n-3)s(n-2)\\right)\\] \u00c9crire une fonction telle que hipparque(n) renvoie le nombre \\(s_n\\) pour \\(0 < n <100\\) . Exemples \ud83d\udc0d Console Python >>> hipparque ( 3 ) 3 >>> hipparque ( 4 ) 11 >>> hipparque ( 5 ) 45 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineHIPPARQUE = [backslash-newline None, 1, 1, 3, 11, 45, 197, 903, 4279, 20793, 103049,backslash-newline 518859, 2646723, 13648869, 71039373, 372693519, 1968801519,backslash-newline 10463578353, 55909013009, 300159426963, 1618362158587,backslash-newline 8759309660445, 47574827600981, 259215937709463, 1416461675464871backslash-newline]backslash-newlinebackslash-newlinefor n, attendu in enumerate(HIPPARQUE):backslash-newline if n > 0:backslash-newline assert hipparque(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlineHIPPARQUEpython-underscoreMOD = [None, 1, 1, 3, 11, 45, 197, 903, 4279, 20793, 103049, 518859, 2646723, 13648869, 71039373, 372693519, 968801519, 463578353, 909013009, 159426963, 362158587, 309660445, 827600981, 937709463, 675464871, 824437545, 294485657, 935918683, 480318899, 548921813, 996567325, 807180831, 87926239, 951594977, 230450209, 624841507, 548259307, 663097869, 27088357, 621111719, 111863447, 607546137, 696929449, 144967147, 440738979, 954316741, 953278125, 47978543, 885177039, 715682513, 593205809, 310379699, 518807003, 524384509, 957814133, 730733495, 574744711, 402287369, 271801017, 461750139, 443027347, 661954997, 728242749, 396893247, 756439999, 101480897, 554808897, 545449539, 655467467, 586444269, 144461061, 343127495, 377432183, 984924409, 508708553, 605678859, 810562179, 900836773, 867845069, 558029903, 937600175, 21098161, 123414609, 345323987, 415937979, 871392477, 945036437, 41456599, 649862247, 703510249, 622510297, 114056347, 136186739, 370983317, 58539869, 902214751, 240745375, 393184673, 752888929, 370649443]backslash-newlineMOD = 10python-starpython-star9backslash-newlinefor n, attendu in enumerate(HIPPARQUEpython-underscoreMOD):backslash-newline if n > 0:backslash-newline assert hipparque(n) % MOD == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def hipparque(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline hipparquepython-underscoremem = [None, 1, 1]backslash-newlinebackslash-newlinedef hipparque(n):backslash-newline i = len(hipparquepython-underscoremem)backslash-newline while n >= i:backslash-newline difference = (backslash-newline (6python-stari - 9) python-star hipparquepython-underscoremem[i - 1]backslash-newline - (i - 3) python-star hipparquepython-underscoremem[i - 2]backslash-newline )backslash-newline suivant = difference // ibackslash-newline hipparquepython-underscoremem.append(suivant)backslash-newline i += 1backslash-newline return hipparquepython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline A Z","title":"Nombres d'Hipparque"},{"location":"3-difficile/nb_hipparque/sujet/#subdivisions-de-polygone","text":"Les nombres d'Hipparque sont nomm\u00e9s d'apr\u00e8s le math\u00e9maticien et astronome grec, qui, selon Plutarque, connaissait certainement ces nombres. Culture Hipparque a \u00e9t\u00e9 actif en Gr\u00e8ce, au moins entre 147 et 127 av. J.-C. Plutarque est un philosophe majeur de la Rome antique, qui a v\u00e9cu de 46 \u00e0 125, soit deux si\u00e8cles apr\u00e8s Hipparque. Les \\(s_4=11\\) subdivisions d'un pentagone On admettra que : Le \\(n\\) -i\u00e8me nombre \\(s_n\\) de la suite est le nombre de subdivisions d'un polygone \u00e0 \\(n + 1\\) c\u00f4t\u00e9s en polygones plus petits par l'adjonction de diagonales au polygone de d\u00e9part. \\(s_1=s_2=1\\) Une formule pour calculer \\(s_n\\) avec \\(n>1\\) est : \\[s_n = \\frac1n\\left((6n-9)s(n-1) - (n-3)s(n-2)\\right)\\] \u00c9crire une fonction telle que hipparque(n) renvoie le nombre \\(s_n\\) pour \\(0 < n <100\\) . Exemples \ud83d\udc0d Console Python >>> hipparque ( 3 ) 3 >>> hipparque ( 4 ) 11 >>> hipparque ( 5 ) 45 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineHIPPARQUE = [backslash-newline None, 1, 1, 3, 11, 45, 197, 903, 4279, 20793, 103049,backslash-newline 518859, 2646723, 13648869, 71039373, 372693519, 1968801519,backslash-newline 10463578353, 55909013009, 300159426963, 1618362158587,backslash-newline 8759309660445, 47574827600981, 259215937709463, 1416461675464871backslash-newline]backslash-newlinebackslash-newlinefor n, attendu in enumerate(HIPPARQUE):backslash-newline if n > 0:backslash-newline assert hipparque(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlineHIPPARQUEpython-underscoreMOD = [None, 1, 1, 3, 11, 45, 197, 903, 4279, 20793, 103049, 518859, 2646723, 13648869, 71039373, 372693519, 968801519, 463578353, 909013009, 159426963, 362158587, 309660445, 827600981, 937709463, 675464871, 824437545, 294485657, 935918683, 480318899, 548921813, 996567325, 807180831, 87926239, 951594977, 230450209, 624841507, 548259307, 663097869, 27088357, 621111719, 111863447, 607546137, 696929449, 144967147, 440738979, 954316741, 953278125, 47978543, 885177039, 715682513, 593205809, 310379699, 518807003, 524384509, 957814133, 730733495, 574744711, 402287369, 271801017, 461750139, 443027347, 661954997, 728242749, 396893247, 756439999, 101480897, 554808897, 545449539, 655467467, 586444269, 144461061, 343127495, 377432183, 984924409, 508708553, 605678859, 810562179, 900836773, 867845069, 558029903, 937600175, 21098161, 123414609, 345323987, 415937979, 871392477, 945036437, 41456599, 649862247, 703510249, 622510297, 114056347, 136186739, 370983317, 58539869, 902214751, 240745375, 393184673, 752888929, 370649443]backslash-newlineMOD = 10python-starpython-star9backslash-newlinefor n, attendu in enumerate(HIPPARQUEpython-underscoreMOD):backslash-newline if n > 0:backslash-newline assert hipparque(n) % MOD == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def hipparque(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline hipparquepython-underscoremem = [None, 1, 1]backslash-newlinebackslash-newlinedef hipparque(n):backslash-newline i = len(hipparquepython-underscoremem)backslash-newline while n >= i:backslash-newline difference = (backslash-newline (6python-stari - 9) python-star hipparquepython-underscoremem[i - 1]backslash-newline - (i - 3) python-star hipparquepython-underscoremem[i - 2]backslash-newline )backslash-newline suivant = difference // ibackslash-newline hipparquepython-underscoremem.append(suivant)backslash-newline i += 1backslash-newline return hipparquepython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert hipparque(3) == 3backslash-newlineassert hipparque(4) == 11backslash-newlineassert hipparque(5) == 45backslash-newlinebackslash-newline A Z","title":"Subdivisions de polygone"},{"location":"3-difficile/nb_motzkin/sujet/","tags":["maths","r\u00e9cursivit\u00e9","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des arbres unaires-binaires \u00e0 n+1 n\u0153uds \u2693\ufe0e Arbres binaires - inutile ici On rappelle la caract\u00e9ristique d'un arbre binaire : Soit c'est un arbre vide. Soit c'est un arbre qui a deux sous-arbres (un \u00e0 gauche, un \u00e0 droite) qui sont des arbres binaires. Il est inutile d'utiliser ici cette propri\u00e9t\u00e9, nous allons d\u00e9finir une nouvelle classe d'arbres qui est diff\u00e9rente . On d\u00e9finit un arbre unaire-binaire comme \u00e9tant : Soit un arbre vide. Soit un arbre ayant un ou deux sous-arbres qui sont alors des arbres unaires-binaires. Si le sous-arbre est unique, il n'est ni \u00e0 droite, ni \u00e0 gauche, il est au centre. Il peut \u00eatre vide. Si les sous-arbres sont deux, il y en a un \u00e0 gauche, un autre \u00e0 droite. Ils sont alors non vides. Un arbre unaire-binaire \u00e0 \\(7+1\\) n\u0153uds. Dans tout cet exercice, on parlera d'arbres \u00e0 \\(n+1\\) n\u0153uds, comme ci-dessus \u00e0 \\(7+1\\) n\u0153uds. En effet, on pourra plus facilement dire qu'il y a la racine et \\(n\\) n\u0153uds \u00e0 se r\u00e9partir soit au centre, soit \u00e0 gauche et \u00e0 droite. Objectif : \u00c9crire une fonction telle que motzkin(n) renvoie le nombre d'arbres unaires-binaires \u00e0 \\(n+1\\) n\u0153uds. Cette fonction est nomm\u00e9e ainsi d'apr\u00e8s le math\u00e9maticien Th\u00e9odore Motzkin (1908-1970). Les arbres unaires-binaires \u00e0 \\(3+1\\) n\u0153uds Il y en a 4 : \u00c9num\u00e9rer les arbres unaires-binaires \u00e0 \\(n+1\\) n\u0153uds Si \\(n = 0\\) , alors la r\u00e9ponse est \\(1\\) . Il n'y a qu'un arbre unaire-binaire \u00e0 \\(1\\) n\u0153ud. Sinon, la racine poss\u00e8de un ou deux sous-arbres. Pour un unique sous-arbre, il y a \u00e0 compl\u00e9ter par un arbre unaire-binaire \u00e0 \\(n\\) n\u0153uds. \\(n = 1 + (n-1)\\) , donc il y a motzkin(n-1) possibilit\u00e9s. Pour deux sous-arbres, pour un total de \\(n\\) n\u0153uds, la r\u00e9partition peut se faire : \\(n-1\\) \u00e0 gauche, \\(1\\) \u00e0 droite. Il y a motzkin(n-2) * motzkin(0) possibilit\u00e9s. \\(n-2\\) \u00e0 gauche, \\(2\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(n-3\\) \u00e0 gauche, \\(3\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. ... \\(3\\) \u00e0 gauche, \\(n-3\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(2\\) \u00e0 gauche, \\(n-2\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(1\\) \u00e0 gauche, \\(n-1\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. Les possibilit\u00e9s d\u00e9crites sont distinctes, leur nombre est donc la somme des cas. Les arbres unaires-binaires \u00e0 \\(4+1\\) n\u0153uds Il y en a 9 : Compl\u00e9ter le code : \ud83d\udc0d Script Python motzkin_mem = [ 1 ] def motzkin ( n ): if n >= len ( motzkin_mem ): resultat = motzkin ( ... ) for i in range ( ... ): resultat += motzkin ( ... ) ... motzkin ( ... ) # motzkin_mem est ici de longueur n motzkin_mem . append ( resultat ) # et l\u00c3 de longueur n + 1 return motzkin_mem [ n ] Exemples \ud83d\udc0d Console Python >>> motzkin ( 4 ) 9 >>> motzkin ( 5 ) 21 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineA001006 = [backslash-newline 1, 1, 2, 4, 9, 21, 51, 127, 323, 835, 2188, 5798, 15511, 41835,backslash-newline 113634, 310572, 853467, 2356779, 6536382, 18199284, 50852019,backslash-newline 142547559, 400763223, 1129760415, 3192727797, 9043402501,backslash-newline 25669818476, 73007772802, 208023278209, 593742784829backslash-newline]backslash-newlinebackslash-newlinefor n, resultat in enumerate(A001006):backslash-newline assert motzkin(n) == resultat, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 motzkinpython-underscoremem = [1]backslash-newlinebackslash-newlinedef motzkin(n):backslash-newline if n >= len(motzkinpython-underscoremem):backslash-newline resultat = motzkin(...)backslash-newline for i in range(...):backslash-newline resultat += motzkin(...) ... motzkin(...)backslash-newline # motzkinpython-underscoremem est ici de longueur nbackslash-newline motzkinpython-underscoremem.append(resultat)backslash-newline # et l\u00c3 de longueur n + 1backslash-newline return motzkinpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newline motzkinpython-underscoremem = [1]backslash-newlinebackslash-newlinedef motzkin(n):backslash-newline if n >= len(motzkinpython-underscoremem):backslash-newline resultat = motzkin(n - 1)backslash-newline for i in range(1, n):backslash-newline resultat += motzkin(i - 1) python-star motzkin(n - 1 - i)backslash-newline # motzkinpython-underscoremem est ici de longueur nbackslash-newline motzkinpython-underscoremem.append(resultat)backslash-newline # et l\u00c3 de longueur n + 1backslash-newline return motzkinpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newline A Z Les 21 arbres unaires-binaires \u00e0 \\(5+1\\) n\u0153uds Les 9 issus d'une branche au centre, puis un arbre unaire-binaire \u00e0 \\(5\\) n\u0153uds. Les 1\u00d74 issus de sous-arbre de gauche \u00e0 \\(1\\) n\u0153ud et sous-arbre de droite \u00e0 \\(4\\) n\u0153uds. Les 1\u00d72 issus de sous-arbre de gauche \u00e0 \\(2\\) n\u0153uds et sous-arbre de droite \u00e0 \\(3\\) n\u0153uds. Les 2\u00d71 issus de sous-arbre de gauche \u00e0 \\(3\\) n\u0153uds et sous-arbre de droite \u00e0 \\(2\\) n\u0153uds. Les 4\u00d71 issus de sous-arbre de gauche \u00e0 \\(4\\) n\u0153uds et sous-arbre de droite \u00e0 \\(1\\) n\u0153ud.","title":"Nombres de Motzkin"},{"location":"3-difficile/nb_motzkin/sujet/#enumeration-des-arbres-unaires-binaires-a-n1-nuds","text":"Arbres binaires - inutile ici On rappelle la caract\u00e9ristique d'un arbre binaire : Soit c'est un arbre vide. Soit c'est un arbre qui a deux sous-arbres (un \u00e0 gauche, un \u00e0 droite) qui sont des arbres binaires. Il est inutile d'utiliser ici cette propri\u00e9t\u00e9, nous allons d\u00e9finir une nouvelle classe d'arbres qui est diff\u00e9rente . On d\u00e9finit un arbre unaire-binaire comme \u00e9tant : Soit un arbre vide. Soit un arbre ayant un ou deux sous-arbres qui sont alors des arbres unaires-binaires. Si le sous-arbre est unique, il n'est ni \u00e0 droite, ni \u00e0 gauche, il est au centre. Il peut \u00eatre vide. Si les sous-arbres sont deux, il y en a un \u00e0 gauche, un autre \u00e0 droite. Ils sont alors non vides. Un arbre unaire-binaire \u00e0 \\(7+1\\) n\u0153uds. Dans tout cet exercice, on parlera d'arbres \u00e0 \\(n+1\\) n\u0153uds, comme ci-dessus \u00e0 \\(7+1\\) n\u0153uds. En effet, on pourra plus facilement dire qu'il y a la racine et \\(n\\) n\u0153uds \u00e0 se r\u00e9partir soit au centre, soit \u00e0 gauche et \u00e0 droite. Objectif : \u00c9crire une fonction telle que motzkin(n) renvoie le nombre d'arbres unaires-binaires \u00e0 \\(n+1\\) n\u0153uds. Cette fonction est nomm\u00e9e ainsi d'apr\u00e8s le math\u00e9maticien Th\u00e9odore Motzkin (1908-1970). Les arbres unaires-binaires \u00e0 \\(3+1\\) n\u0153uds Il y en a 4 : \u00c9num\u00e9rer les arbres unaires-binaires \u00e0 \\(n+1\\) n\u0153uds Si \\(n = 0\\) , alors la r\u00e9ponse est \\(1\\) . Il n'y a qu'un arbre unaire-binaire \u00e0 \\(1\\) n\u0153ud. Sinon, la racine poss\u00e8de un ou deux sous-arbres. Pour un unique sous-arbre, il y a \u00e0 compl\u00e9ter par un arbre unaire-binaire \u00e0 \\(n\\) n\u0153uds. \\(n = 1 + (n-1)\\) , donc il y a motzkin(n-1) possibilit\u00e9s. Pour deux sous-arbres, pour un total de \\(n\\) n\u0153uds, la r\u00e9partition peut se faire : \\(n-1\\) \u00e0 gauche, \\(1\\) \u00e0 droite. Il y a motzkin(n-2) * motzkin(0) possibilit\u00e9s. \\(n-2\\) \u00e0 gauche, \\(2\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(n-3\\) \u00e0 gauche, \\(3\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. ... \\(3\\) \u00e0 gauche, \\(n-3\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(2\\) \u00e0 gauche, \\(n-2\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. \\(1\\) \u00e0 gauche, \\(n-1\\) \u00e0 droite. Il y a ??? possibilit\u00e9s. Les possibilit\u00e9s d\u00e9crites sont distinctes, leur nombre est donc la somme des cas. Les arbres unaires-binaires \u00e0 \\(4+1\\) n\u0153uds Il y en a 9 : Compl\u00e9ter le code : \ud83d\udc0d Script Python motzkin_mem = [ 1 ] def motzkin ( n ): if n >= len ( motzkin_mem ): resultat = motzkin ( ... ) for i in range ( ... ): resultat += motzkin ( ... ) ... motzkin ( ... ) # motzkin_mem est ici de longueur n motzkin_mem . append ( resultat ) # et l\u00c3 de longueur n + 1 return motzkin_mem [ n ] Exemples \ud83d\udc0d Console Python >>> motzkin ( 4 ) 9 >>> motzkin ( 5 ) 21 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineA001006 = [backslash-newline 1, 1, 2, 4, 9, 21, 51, 127, 323, 835, 2188, 5798, 15511, 41835,backslash-newline 113634, 310572, 853467, 2356779, 6536382, 18199284, 50852019,backslash-newline 142547559, 400763223, 1129760415, 3192727797, 9043402501,backslash-newline 25669818476, 73007772802, 208023278209, 593742784829backslash-newline]backslash-newlinebackslash-newlinefor n, resultat in enumerate(A001006):backslash-newline assert motzkin(n) == resultat, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 motzkinpython-underscoremem = [1]backslash-newlinebackslash-newlinedef motzkin(n):backslash-newline if n >= len(motzkinpython-underscoremem):backslash-newline resultat = motzkin(...)backslash-newline for i in range(...):backslash-newline resultat += motzkin(...) ... motzkin(...)backslash-newline # motzkinpython-underscoremem est ici de longueur nbackslash-newline motzkinpython-underscoremem.append(resultat)backslash-newline # et l\u00c3 de longueur n + 1backslash-newline return motzkinpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newline motzkinpython-underscoremem = [1]backslash-newlinebackslash-newlinedef motzkin(n):backslash-newline if n >= len(motzkinpython-underscoremem):backslash-newline resultat = motzkin(n - 1)backslash-newline for i in range(1, n):backslash-newline resultat += motzkin(i - 1) python-star motzkin(n - 1 - i)backslash-newline # motzkinpython-underscoremem est ici de longueur nbackslash-newline motzkinpython-underscoremem.append(resultat)backslash-newline # et l\u00c3 de longueur n + 1backslash-newline return motzkinpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert motzkin(4) == 9backslash-newlineassert motzkin(5) == 21backslash-newlinebackslash-newline A Z Les 21 arbres unaires-binaires \u00e0 \\(5+1\\) n\u0153uds Les 9 issus d'une branche au centre, puis un arbre unaire-binaire \u00e0 \\(5\\) n\u0153uds. Les 1\u00d74 issus de sous-arbre de gauche \u00e0 \\(1\\) n\u0153ud et sous-arbre de droite \u00e0 \\(4\\) n\u0153uds. Les 1\u00d72 issus de sous-arbre de gauche \u00e0 \\(2\\) n\u0153uds et sous-arbre de droite \u00e0 \\(3\\) n\u0153uds. Les 2\u00d71 issus de sous-arbre de gauche \u00e0 \\(3\\) n\u0153uds et sous-arbre de droite \u00e0 \\(2\\) n\u0153uds. Les 4\u00d71 issus de sous-arbre de gauche \u00e0 \\(4\\) n\u0153uds et sous-arbre de droite \u00e0 \\(1\\) n\u0153ud.","title":"\u00c9num\u00e9ration des arbres unaires-binaires \u00e0 n+1 n\u0153uds"},{"location":"3-difficile/nb_schroder/sujet/","tags":["maths","r\u00e9cursivit\u00e9","m\u00e9mo","a_trou"],"text":"\u00c9num\u00e9ration des chemins de Schr\u00f6der \u2693\ufe0e Pour aller de \\((0, 0)\\) \u00e0 \\((2n, 0)\\) , en restant au-dessus ou sur l'axe des abscisses, avec des mouvements \u2197 Nord-Est, donc suivi plus tard d'un Sud-Est \u2198 \u2198 Sud-Est, qui est pr\u00e9c\u00e9d\u00e9 d'un \u2197 Nord-Est correspondant \u2192 Est, de deux unit\u00e9s \u00e0 la fois Chaque paire (\u2197, \u2198) est associ\u00e9e \u00e0 un d\u00e9placement de deux unit\u00e9s vers l'Est. Ainsi, un chemin de Schr\u00f6der fait globalement un d\u00e9placement horizontal d'un nombre pair d'unit\u00e9s, que l'on note \\(2n\\) . Objectif : \u00c9crire une fonction telle que schroder(n) renvoie le nombre de chemins de Schr\u00f6der allant de \\((0, 0)\\) \u00e0 \\((2n, 0)\\) . Chemins de Schr\u00f6der de longueur \\(2\u00d72\\) Il y en a 6. Chemins de Schr\u00f6der de longueur \\(2\u00d73\\) Il y en a 22. Formule On admettra qu'une formule pour calculer ces nombres \\(S_n\\) est : \\(S_0 = 1\\) , \\(S_1 = 2\\) \\((n+1)S_n = (6n-3)S_{n-1} - (n-2)S_{n-2}\\) , pour \\(n>1\\) . On compl\u00e8tera le code : \ud83d\udc0d Script Python schroder_mem = [ ... ] def schroder ( n ): if n >= len ( schroder_mem ): resultat = ... # ... schroder(n - 1) ... # ici schroder_mem est de longueur n garanti schroder_mem . append ( ... ) return schroder_mem [ ... ] Exemples \ud83d\udc0d Console Python >>> schroder ( 2 ) 6 >>> schroder ( 3 ) 22 >>> schroder ( 4 ) 90 La fonction doit renvoyer un nombre entier . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineA006318 = [backslash-newline 1, 2, 6, 22, 90, 394, 1806, 8558, 41586, 206098, 1037718, 5293446,backslash-newline 27297738, 142078746, 745387038, 3937603038, 20927156706, 111818026018,backslash-newline 600318853926, 3236724317174, 17518619320890, 95149655201962,backslash-newline 518431875418926, 2832923350929742, 15521467648875090backslash-newline]backslash-newlinebackslash-newlinefor n, attendu in enumerate(A006318):backslash-newline resultat = schroder(n)backslash-newline assert isinstance(resultat, int), \"Erreur, le r\u00c3\u00a9sultat doit \u00c3\u00aatre entier\"backslash-newline assert attendu == resultat, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 schroderpython-underscoremem = [...]backslash-newlinebackslash-newlinedef schroder(n):backslash-newline if n >= len(schroderpython-underscoremem):backslash-newline resultat = ... # ... schroder(n - 1) ...backslash-newline # ici schroderpython-underscoremem est de longueur n garantibackslash-newline schroderpython-underscoremem.append(...)backslash-newline return schroderpython-underscoremem[...]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newline schroderpython-underscoremem = [1, 2]backslash-newlinebackslash-newlinedef schroder(n):backslash-newline if n >= len(schroderpython-underscoremem):backslash-newline resultat = (backslash-newline (6python-starn - 3) python-star schroder(n - 1)backslash-newline - (n - 2) python-star schroder(n - 2)backslash-newline ) // (n + 1)backslash-newline # ici schroderpython-underscoremem est de longueur n garantibackslash-newline schroderpython-underscoremem.append(resultat)backslash-newline return schroderpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newline A Z","title":"Nombres de Schr\u00f6der"},{"location":"3-difficile/nb_schroder/sujet/#enumeration-des-chemins-de-schroder","text":"Pour aller de \\((0, 0)\\) \u00e0 \\((2n, 0)\\) , en restant au-dessus ou sur l'axe des abscisses, avec des mouvements \u2197 Nord-Est, donc suivi plus tard d'un Sud-Est \u2198 \u2198 Sud-Est, qui est pr\u00e9c\u00e9d\u00e9 d'un \u2197 Nord-Est correspondant \u2192 Est, de deux unit\u00e9s \u00e0 la fois Chaque paire (\u2197, \u2198) est associ\u00e9e \u00e0 un d\u00e9placement de deux unit\u00e9s vers l'Est. Ainsi, un chemin de Schr\u00f6der fait globalement un d\u00e9placement horizontal d'un nombre pair d'unit\u00e9s, que l'on note \\(2n\\) . Objectif : \u00c9crire une fonction telle que schroder(n) renvoie le nombre de chemins de Schr\u00f6der allant de \\((0, 0)\\) \u00e0 \\((2n, 0)\\) . Chemins de Schr\u00f6der de longueur \\(2\u00d72\\) Il y en a 6. Chemins de Schr\u00f6der de longueur \\(2\u00d73\\) Il y en a 22. Formule On admettra qu'une formule pour calculer ces nombres \\(S_n\\) est : \\(S_0 = 1\\) , \\(S_1 = 2\\) \\((n+1)S_n = (6n-3)S_{n-1} - (n-2)S_{n-2}\\) , pour \\(n>1\\) . On compl\u00e8tera le code : \ud83d\udc0d Script Python schroder_mem = [ ... ] def schroder ( n ): if n >= len ( schroder_mem ): resultat = ... # ... schroder(n - 1) ... # ici schroder_mem est de longueur n garanti schroder_mem . append ( ... ) return schroder_mem [ ... ] Exemples \ud83d\udc0d Console Python >>> schroder ( 2 ) 6 >>> schroder ( 3 ) 22 >>> schroder ( 4 ) 90 La fonction doit renvoyer un nombre entier . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineA006318 = [backslash-newline 1, 2, 6, 22, 90, 394, 1806, 8558, 41586, 206098, 1037718, 5293446,backslash-newline 27297738, 142078746, 745387038, 3937603038, 20927156706, 111818026018,backslash-newline 600318853926, 3236724317174, 17518619320890, 95149655201962,backslash-newline 518431875418926, 2832923350929742, 15521467648875090backslash-newline]backslash-newlinebackslash-newlinefor n, attendu in enumerate(A006318):backslash-newline resultat = schroder(n)backslash-newline assert isinstance(resultat, int), \"Erreur, le r\u00c3\u00a9sultat doit \u00c3\u00aatre entier\"backslash-newline assert attendu == resultat, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 schroderpython-underscoremem = [...]backslash-newlinebackslash-newlinedef schroder(n):backslash-newline if n >= len(schroderpython-underscoremem):backslash-newline resultat = ... # ... schroder(n - 1) ...backslash-newline # ici schroderpython-underscoremem est de longueur n garantibackslash-newline schroderpython-underscoremem.append(...)backslash-newline return schroderpython-underscoremem[...]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newline schroderpython-underscoremem = [1, 2]backslash-newlinebackslash-newlinedef schroder(n):backslash-newline if n >= len(schroderpython-underscoremem):backslash-newline resultat = (backslash-newline (6python-starn - 3) python-star schroder(n - 1)backslash-newline - (n - 2) python-star schroder(n - 2)backslash-newline ) // (n + 1)backslash-newline # ici schroderpython-underscoremem est de longueur n garantibackslash-newline schroderpython-underscoremem.append(resultat)backslash-newline return schroderpython-underscoremem[n]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert schroder(2) == 6backslash-newlineassert schroder(3) == 22backslash-newlineassert schroder(4) == 90backslash-newlinebackslash-newline A Z","title":"\u00c9num\u00e9ration des chemins de Schr\u00f6der"},{"location":"3-difficile/unimodal_sommet/sujet/","tags":["r\u00e9cursivit\u00e9","diviser pour r\u00e9gner","a_trou"],"text":"Sommet d'un tableau unimodal \u2693\ufe0e Un tableau unimodal est un tableau : comportant au moins trois \u00e9l\u00e9ments dont les premiers sont strictement croissants jusqu'\u00e0 un indice i , dont les \u00e9l\u00e9ments \u00e0 partir de i sont strictement d\u00e9croissants Le sommet d'un tableau unimodal est sa plus grande valeur . Ainsi : [1, 2, 3, 2, 1, 0] est un tableau unimodal, son sommet est 3. [1, 2, 3, 5, 10, 9] aussi, son sommet est 10 . [1, 2, 3] n'est pas un tableau unimodal, il n'y a pas de descente \u00e0 la fin, [1, 2] non plus, il n'y a pas assez d'\u00e9l\u00e9ments (au moins trois), [5, 3, 0] non plus, il n'y a pas de mont\u00e9e au d\u00e9but. Remarquons bien que le sommet n'est jamais la premi\u00e8re valeur ni la derni\u00e8re valeur. Objectif \u2693\ufe0e \u00c9crire une fonction utilisant le principe diviser pour r\u00e9gner afin de d\u00e9terminer le sommet du tableau unimodal. La fonction re\u00e7oit en param\u00e8tre un tableau intitul\u00e9 valeurs , qu'on supposera unimodal, sous la forme d'une liste Python et renvoie son sommet. Ci-dessous une animation de la recherche du sommet avec les valeurs : \ud83d\udc0d Script Python valeurs = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 , - 1 , - 2 , - 3 ] Principe de l'algorithme : On cherche \u00e0 d\u00e9terminer l'indice de la valeur maximale. C'est l'indice i tel que valeurs[i] > valeurs[i - 1] et valeurs[i] > valeurs[i + 1] . Pour cela on d\u00e9bute avec des indices gauche et droite couvrant tout le tableau. On examine, pour un indice milieu , central entre gauche et droite l'ordre dans lequel sont rang\u00e9s les \u00e9l\u00e9ments autour de milieu . S'ils sont croissants, cela signifie que le sommet est situ\u00e9 \u00e0 droite de milieu . S'ils sont d\u00e9croissants, cela signifie que le sommet est situ\u00e9 \u00e0 gauche de milieu . S'ils changent de sens de variation... on a trouv\u00e9 le sommet ! Algorithme na\u00eff Il est tr\u00e8s simple de d\u00e9terminer le sommet en parcourant de gauche \u00e0 droite le tableau. Notre objectif est de le faire avec un bien meilleur co\u00fbt. On compl\u00e8tera le code : \ud83d\udc0d Script Python def sommet ( tableau : list ): gauche = 0 droite = len ( tableau ) - 1 while droite - gauche > 1 : milieu = ( ... ) // 2 if tableau [ milieu - 1 ] < tableau [ milieu ] < tableau [ milieu + 1 ]: gauche = ... elif tableau [ milieu - 1 ] > ... > ... : droite = milieu else : return tableau [ ... ] Exemples \ud83d\udc0d Console Python >>> sommet ([ 1 , 2 , 0 ]) 2 >>> sommet ([ 1 , 9 , 8 , 7 ]) 9 >>> sommet ([ 1 , 3 , 5 , 2 ]) 5 >>> sommet ([ 1 , 2 , 3 , 4 , 5 , 4 , 3 , 2 , 1 ]) 5 >>> sommet ([ 1 , 2 , 3 , 4 , 3 , 2 , 1 , 0 , - 1 , - 2 ]) 4 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef max(python-starargs, python-starpython-starkwargs):backslash-newline assert False, \"Interdit d'utiliser max.\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineassert sommet([4, 5, 7, 5, 3]) == 7backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([10, 100, 10, 9, 8, 7, 6]) == 100backslash-newlineassert sommet([1, 2, 4, 8, 4]) == 8backslash-newlineassert sommet([3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newlinebackslash-newlinefor i in range(1, 10):backslash-newline for j in range(1, 10):backslash-newline l = list(range(i)) + list(range(i + j, i - 1, -1))backslash-newline assert sommet(l) == i + jbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineclass IntSurcharge():backslash-newline python-underscorepython-underscorecompteurpython-underscorecomparaison = 0backslash-newlinebackslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, x):backslash-newline self.python-underscorepython-underscorevaleur = xbackslash-newlinebackslash-newline def python-underscorepython-underscoreltpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur < autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoregtpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur > autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscorenepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur != autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoreeqpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur == autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscorelepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur < = autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoregepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur >= autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline @propertybackslash-newline def compteur(self):backslash-newline return IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaisonbackslash-newlinebackslash-newline @propertybackslash-newline def valeur(self):backslash-newline return self.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newlineunimodal = [IntSurcharge(i) for i in range(10000)]backslash-newlineunimodal.extend([IntSurcharge(i) for i in range(10000, 543, -1)])backslash-newlinebackslash-newlineresultat = sommet(unimodal)backslash-newlinebackslash-newlinevaleur = resultat.valeurbackslash-newlinecompteur = resultat.compteurbackslash-newlineassert valeur == 10000backslash-newlineassert compteur < 200, \"Vous avez utilis\u00c3\u00a9 une m\u00c3\u00a9thode interdite\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def sommet(tableau: list):backslash-newline gauche = 0backslash-newline droite = len(tableau) - 1backslash-newline while droite - gauche > 1:backslash-newline milieu = ( ... ) // 2backslash-newline if tableau[milieu - 1] < tableau[milieu] < tableau[milieu + 1]:backslash-newline gauche = ...backslash-newline elif tableau[milieu - 1] > ... > ...:backslash-newline droite = milieubackslash-newline else:backslash-newline return tableau[ ... ]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert sommet([1, 9, 8, 7]) == 9backslash-newlineassert sommet([1, 3, 5, 2]) == 5backslash-newlineassert sommet([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5backslash-newlineassert sommet([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newline def sommet(tableau: list):backslash-newline gauche = 0backslash-newline droite = len(tableau) - 1backslash-newline while droite - gauche > 1:backslash-newline milieu = (gauche + droite) // 2backslash-newline if tableau[milieu - 1] < tableau[milieu] < tableau[milieu + 1]:backslash-newline gauche = milieubackslash-newline elif tableau[milieu - 1] > tableau[milieu] > tableau[milieu + 1]:backslash-newline droite = milieubackslash-newline else:backslash-newline return tableau[milieu]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert sommet([1, 2, 1]) == 2backslash-newlineassert sommet([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([1, 9, 8, 7]) == 9backslash-newlineassert sommet([1, 2, 3, 4, 5, 6, 7, 0]) == 7backslash-newlineassert sommet([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlineassert sommet([4, 5, 7, 5, 3]) == 7backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([10, 100, 10, 9, 8, 7, 6]) == 100backslash-newlineassert sommet([1, 2, 4, 8, 4]) == 8backslash-newlineassert sommet([3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Sommet d'un tableau unimodal"},{"location":"3-difficile/unimodal_sommet/sujet/#sommet-dun-tableau-unimodal","text":"Un tableau unimodal est un tableau : comportant au moins trois \u00e9l\u00e9ments dont les premiers sont strictement croissants jusqu'\u00e0 un indice i , dont les \u00e9l\u00e9ments \u00e0 partir de i sont strictement d\u00e9croissants Le sommet d'un tableau unimodal est sa plus grande valeur . Ainsi : [1, 2, 3, 2, 1, 0] est un tableau unimodal, son sommet est 3. [1, 2, 3, 5, 10, 9] aussi, son sommet est 10 . [1, 2, 3] n'est pas un tableau unimodal, il n'y a pas de descente \u00e0 la fin, [1, 2] non plus, il n'y a pas assez d'\u00e9l\u00e9ments (au moins trois), [5, 3, 0] non plus, il n'y a pas de mont\u00e9e au d\u00e9but. Remarquons bien que le sommet n'est jamais la premi\u00e8re valeur ni la derni\u00e8re valeur.","title":"Sommet d'un tableau unimodal"},{"location":"3-difficile/unimodal_sommet/sujet/#objectif","text":"\u00c9crire une fonction utilisant le principe diviser pour r\u00e9gner afin de d\u00e9terminer le sommet du tableau unimodal. La fonction re\u00e7oit en param\u00e8tre un tableau intitul\u00e9 valeurs , qu'on supposera unimodal, sous la forme d'une liste Python et renvoie son sommet. Ci-dessous une animation de la recherche du sommet avec les valeurs : \ud83d\udc0d Script Python valeurs = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 , - 1 , - 2 , - 3 ] Principe de l'algorithme : On cherche \u00e0 d\u00e9terminer l'indice de la valeur maximale. C'est l'indice i tel que valeurs[i] > valeurs[i - 1] et valeurs[i] > valeurs[i + 1] . Pour cela on d\u00e9bute avec des indices gauche et droite couvrant tout le tableau. On examine, pour un indice milieu , central entre gauche et droite l'ordre dans lequel sont rang\u00e9s les \u00e9l\u00e9ments autour de milieu . S'ils sont croissants, cela signifie que le sommet est situ\u00e9 \u00e0 droite de milieu . S'ils sont d\u00e9croissants, cela signifie que le sommet est situ\u00e9 \u00e0 gauche de milieu . S'ils changent de sens de variation... on a trouv\u00e9 le sommet ! Algorithme na\u00eff Il est tr\u00e8s simple de d\u00e9terminer le sommet en parcourant de gauche \u00e0 droite le tableau. Notre objectif est de le faire avec un bien meilleur co\u00fbt. On compl\u00e8tera le code : \ud83d\udc0d Script Python def sommet ( tableau : list ): gauche = 0 droite = len ( tableau ) - 1 while droite - gauche > 1 : milieu = ( ... ) // 2 if tableau [ milieu - 1 ] < tableau [ milieu ] < tableau [ milieu + 1 ]: gauche = ... elif tableau [ milieu - 1 ] > ... > ... : droite = milieu else : return tableau [ ... ] Exemples \ud83d\udc0d Console Python >>> sommet ([ 1 , 2 , 0 ]) 2 >>> sommet ([ 1 , 9 , 8 , 7 ]) 9 >>> sommet ([ 1 , 3 , 5 , 2 ]) 5 >>> sommet ([ 1 , 2 , 3 , 4 , 5 , 4 , 3 , 2 , 1 ]) 5 >>> sommet ([ 1 , 2 , 3 , 4 , 3 , 2 , 1 , 0 , - 1 , - 2 ]) 4 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlinedef max(python-starargs, python-starpython-starkwargs):backslash-newline assert False, \"Interdit d'utiliser max.\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineassert sommet([4, 5, 7, 5, 3]) == 7backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([10, 100, 10, 9, 8, 7, 6]) == 100backslash-newlineassert sommet([1, 2, 4, 8, 4]) == 8backslash-newlineassert sommet([3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newlinebackslash-newlinefor i in range(1, 10):backslash-newline for j in range(1, 10):backslash-newline l = list(range(i)) + list(range(i + j, i - 1, -1))backslash-newline assert sommet(l) == i + jbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlineclass IntSurcharge():backslash-newline python-underscorepython-underscorecompteurpython-underscorecomparaison = 0backslash-newlinebackslash-newlinebackslash-newline def python-underscorepython-underscoreinitpython-underscorepython-underscore(self, x):backslash-newline self.python-underscorepython-underscorevaleur = xbackslash-newlinebackslash-newline def python-underscorepython-underscoreltpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur < autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoregtpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur > autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscorenepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur != autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoreeqpython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur == autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscorelepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur < = autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline def python-underscorepython-underscoregepython-underscorepython-underscore(self, autre):backslash-newline IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaison += 1backslash-newline return self.python-underscorepython-underscorevaleur >= autre.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newline @propertybackslash-newline def compteur(self):backslash-newline return IntSurcharge.python-underscorepython-underscorecompteurpython-underscorecomparaisonbackslash-newlinebackslash-newline @propertybackslash-newline def valeur(self):backslash-newline return self.python-underscorepython-underscorevaleurbackslash-newlinebackslash-newlineunimodal = [IntSurcharge(i) for i in range(10000)]backslash-newlineunimodal.extend([IntSurcharge(i) for i in range(10000, 543, -1)])backslash-newlinebackslash-newlineresultat = sommet(unimodal)backslash-newlinebackslash-newlinevaleur = resultat.valeurbackslash-newlinecompteur = resultat.compteurbackslash-newlineassert valeur == 10000backslash-newlineassert compteur < 200, \"Vous avez utilis\u00c3\u00a9 une m\u00c3\u00a9thode interdite\"backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def sommet(tableau: list):backslash-newline gauche = 0backslash-newline droite = len(tableau) - 1backslash-newline while droite - gauche > 1:backslash-newline milieu = ( ... ) // 2backslash-newline if tableau[milieu - 1] < tableau[milieu] < tableau[milieu + 1]:backslash-newline gauche = ...backslash-newline elif tableau[milieu - 1] > ... > ...:backslash-newline droite = milieubackslash-newline else:backslash-newline return tableau[ ... ]backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert sommet([1, 9, 8, 7]) == 9backslash-newlineassert sommet([1, 3, 5, 2]) == 5backslash-newlineassert sommet([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5backslash-newlineassert sommet([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newline def sommet(tableau: list):backslash-newline gauche = 0backslash-newline droite = len(tableau) - 1backslash-newline while droite - gauche > 1:backslash-newline milieu = (gauche + droite) // 2backslash-newline if tableau[milieu - 1] < tableau[milieu] < tableau[milieu + 1]:backslash-newline gauche = milieubackslash-newline elif tableau[milieu - 1] > tableau[milieu] > tableau[milieu + 1]:backslash-newline droite = milieubackslash-newline else:backslash-newline return tableau[milieu]backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlineassert sommet([1, 2, 1]) == 2backslash-newlineassert sommet([1, 2, 3, 4, 5, 4, 3, 2, 1]) == 5backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([1, 9, 8, 7]) == 9backslash-newlineassert sommet([1, 2, 3, 4, 5, 6, 7, 0]) == 7backslash-newlineassert sommet([1, 2, 3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlineassert sommet([4, 5, 7, 5, 3]) == 7backslash-newlineassert sommet([1, 10, 9, 8, 7, 6, 5, 4]) == 10backslash-newlineassert sommet([10, 100, 10, 9, 8, 7, 6]) == 100backslash-newlineassert sommet([1, 2, 4, 8, 4]) == 8backslash-newlineassert sommet([3, 4, 3, 2, 1, 0, -1, -2]) == 4backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Objectif"},{"location":"4-Tdifficile/correspondance_Lukasiewicz/exo_REM/","text":"Commentaires \u2693\ufe0e \u0141ukasiewicz a [...] jet\u00e9 les bases de l'informatique moderne en cr\u00e9ant la notation polonaise et en d\u00e9veloppent avec Alfred Tarski et Stefan Banach les fondations de la notation inverse, une mani\u00e8re d'\u00e9crire des expressions arithm\u00e9tiques largement utilis\u00e9es \u00e0 ce jour en informatique.","title":"Commentaires"},{"location":"4-Tdifficile/correspondance_Lukasiewicz/exo_REM/#commentaires","text":"\u0141ukasiewicz a [...] jet\u00e9 les bases de l'informatique moderne en cr\u00e9ant la notation polonaise et en d\u00e9veloppent avec Alfred Tarski et Stefan Banach les fondations de la notation inverse, une mani\u00e8re d'\u00e9crire des expressions arithm\u00e9tiques largement utilis\u00e9es \u00e0 ce jour en informatique.","title":"Commentaires"},{"location":"4-Tdifficile/correspondance_Lukasiewicz/sujet/","tags":["arbre","chemin","r\u00e9cursivit\u00e9"],"text":"Correspondance de \u0141ukasiewicz \u2693\ufe0e Dans cet exercice, arbre d\u00e9signera un arbre enracin\u00e9 ordonn\u00e9 sans \u00e9tiquette. Chaque arbre sera mod\u00e9lis\u00e9 avec une liste Python. Une feuille (un n\u0153ud externe) sera repr\u00e9sent\u00e9e par une liste vide [] ; la liste de ses sous-arbres est vide. Un n\u0153ud interne sera repr\u00e9sent\u00e9 par la liste de ses sous-arbres donn\u00e9s dans l'ordre. Un arbre sera donn\u00e9 par la repr\u00e9sentation de sa racine. Exemples repr\u00e9sent\u00e9 en interne avec [[[], []], [[]], []] repr\u00e9sent\u00e9 en interne avec [[[]], [[], []], []] Les deux arbres ci-dessus sont diff\u00e9rents. repr\u00e9sent\u00e9 en interne avec [[], [[], [[], []], [], [], []], []] Correspondance de \u0141ukasiewicz Pour chaque arbre, on note \\(n\\) le nombre de n\u0153uds. On rappelle qu'ici \u00ab arbre \u00bb d\u00e9signa arbre enracin\u00e9, ainsi \\(n>0\\) . 1] On construit d'abord une liste nb_sous_arbres : qui commence avec le nombre de sous-arbres de la racine, que l'on compl\u00e8te r\u00e9cursivement avec le contenu des listes nb_sous_arbres de chaque sous arbre. Pour un feuille, cette liste est [0] ; il y a \\(0\\) sous-arbre, et donc rien \u00e0 ajouter. Exemple : , la racine poss\u00e8de \\(3\\) sous arbres, ainsi la liste sera de la forme [3, ...a..., ...b..., ...c...] Le sous-arbre a est une feuille, on remplace donc ...a... par 0 , il y a \\(0\\) n\u0153ud et on n'a pas de sous arbres \u00e0 \u00e9voquer. Le sous-arbre b poss\u00e8de \\(5\\) n\u0153uds, on remplace donc ...b... par 5, 0, ..., 0, 0, 0 ; il y avait 4 feuilles, on a d\u00e9j\u00e0 plac\u00e9 les 0 , reste \u00e0 compl\u00e9ter par le dernier morceau qui poss\u00e8de 2 feuilles, donc 2, 0, 0 Le sous-arbre c est une feuille, on remplace ...c... par 0 On obtient la liste [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] Propri\u00e9t\u00e9s : Cette liste est de longueur \\(n\\) et de somme \u00e9gale \u00e0 \\(n-1\\) . Cette liste se termine toujours par un \\(0\\) , qui repr\u00e9sente la feuille la plus \u00e0 droite de l'arbre. La somme des \\(i\\) premiers termes est toujours sup\u00e9rieure ou \u00e9gale \u00e0 \\(i\\) pour tout \\(i\\) de \\(0\\) \u00e0 \\(n\\) . 2] On construit une liste chemin \u00e0 partir de cette liste, en \u00f4tant \\(1\\) \u00e0 chaque nombre de la liste, et enlevant le dernier nombre de cette liste. Propri\u00e9t\u00e9s : Cette liste chemin est de longueur \\(n-1\\) et de somme nulle. La somme des \\(i\\) premiers termes est toujours positive pour tout \\(i\\) de \\(0\\) \u00e0 \\(n-1\\) . Exemple, \u00e0 partir de la liste [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] , on construit [2, -1, 4, -1, 1, -1, -1, -1, -1, -1, -1] On obtient donc une mod\u00e9lisation d'un chemin de \\((0, 0)\\) \u00e0 \\((n-1, 0)\\) situ\u00e9 dans le cadran sup\u00e9rieur droite (abscisses et ordonn\u00e9es positives), dont les \u00e9tapes sont de la forme \\((1, k)\\) avec \\(k=-1\\) ou \\(k\\in \\mathbb N\\) . On appelle un tel chemin un \u00ab chemin de \u0141ukasiewicz \u00bb. Avec l'exemple pr\u00e9c\u00e9dent, on obtient R\u00e9ciproquement, pour tout chemin de \u0141ukasiewicz, on pourrait reconstruire un arbre avec le proc\u00e9d\u00e9 inverse ; c'est plus d\u00e9licat \u00e0 impl\u00e9menter. Ce sera l'objet d'un autre exercice, plus difficile. \u00c9crire une fonction arbre_vers_chemin qui impl\u00e9mente une partie de la correspondance de \u0141ukasiewicz. Exemples repr\u00e9sent\u00e9 en interne avec [[], []] , donne un chemin qui correspond \u00e0 la liste [1, -1] \ud83d\udc0d Console Python >>> arbre_vers_chemin ([[], []]) [1, -1] repr\u00e9sent\u00e9 en interne avec [[], [], [[], []]] , donne un chemin qui correspond \u00e0 la liste [2, -1, -1, 1, -1] \ud83d\udc0d Console Python >>> arbre_vers_chemin ([[], [], [[], []]]) [2, -1, -1, 1, -1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([]) == []backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[]]) == [0]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[[[[]]]]]) == [0, 0, 0, 0]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], []]) == [2, -1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [], [], []]) == [4, -1, -1, -1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[[]], [[], [], [], [[]], []], []]) == [2, 0, -1, 4, -1, -1, -1, 0, -1, -1]backslash-newlinebackslash-newline Valider 5/5 def arbrepython-underscoreverspython-underscorechemin(arbre):backslash-newline ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newline def arbrepython-underscoreverspython-underscorechemin(arbre):backslash-newline def etape(arbre):backslash-newline \"Fonction r\u00c3\u00a9cursive interne\"backslash-newline resultat = [len(arbre)]backslash-newline for souspython-underscorearbre in arbre:backslash-newline resultat.extend(etape(souspython-underscorearbre))backslash-newline return resultatbackslash-newlinebackslash-newline chemin = [y - 1 for y in etape(arbre)]backslash-newline chemin.pop()backslash-newline return cheminbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e \u0141ukasiewicz a [...] jet\u00e9 les bases de l'informatique moderne en cr\u00e9ant la notation polonaise et en d\u00e9veloppent avec Alfred Tarski et Stefan Banach les fondations de la notation inverse, une mani\u00e8re d'\u00e9crire des expressions arithm\u00e9tiques largement utilis\u00e9es \u00e0 ce jour en informatique. Z","title":"Correspondance de \u0141ukasiewicz"},{"location":"4-Tdifficile/correspondance_Lukasiewicz/sujet/#correspondance-de-ukasiewicz","text":"Dans cet exercice, arbre d\u00e9signera un arbre enracin\u00e9 ordonn\u00e9 sans \u00e9tiquette. Chaque arbre sera mod\u00e9lis\u00e9 avec une liste Python. Une feuille (un n\u0153ud externe) sera repr\u00e9sent\u00e9e par une liste vide [] ; la liste de ses sous-arbres est vide. Un n\u0153ud interne sera repr\u00e9sent\u00e9 par la liste de ses sous-arbres donn\u00e9s dans l'ordre. Un arbre sera donn\u00e9 par la repr\u00e9sentation de sa racine. Exemples repr\u00e9sent\u00e9 en interne avec [[[], []], [[]], []] repr\u00e9sent\u00e9 en interne avec [[[]], [[], []], []] Les deux arbres ci-dessus sont diff\u00e9rents. repr\u00e9sent\u00e9 en interne avec [[], [[], [[], []], [], [], []], []] Correspondance de \u0141ukasiewicz Pour chaque arbre, on note \\(n\\) le nombre de n\u0153uds. On rappelle qu'ici \u00ab arbre \u00bb d\u00e9signa arbre enracin\u00e9, ainsi \\(n>0\\) . 1] On construit d'abord une liste nb_sous_arbres : qui commence avec le nombre de sous-arbres de la racine, que l'on compl\u00e8te r\u00e9cursivement avec le contenu des listes nb_sous_arbres de chaque sous arbre. Pour un feuille, cette liste est [0] ; il y a \\(0\\) sous-arbre, et donc rien \u00e0 ajouter. Exemple : , la racine poss\u00e8de \\(3\\) sous arbres, ainsi la liste sera de la forme [3, ...a..., ...b..., ...c...] Le sous-arbre a est une feuille, on remplace donc ...a... par 0 , il y a \\(0\\) n\u0153ud et on n'a pas de sous arbres \u00e0 \u00e9voquer. Le sous-arbre b poss\u00e8de \\(5\\) n\u0153uds, on remplace donc ...b... par 5, 0, ..., 0, 0, 0 ; il y avait 4 feuilles, on a d\u00e9j\u00e0 plac\u00e9 les 0 , reste \u00e0 compl\u00e9ter par le dernier morceau qui poss\u00e8de 2 feuilles, donc 2, 0, 0 Le sous-arbre c est une feuille, on remplace ...c... par 0 On obtient la liste [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] Propri\u00e9t\u00e9s : Cette liste est de longueur \\(n\\) et de somme \u00e9gale \u00e0 \\(n-1\\) . Cette liste se termine toujours par un \\(0\\) , qui repr\u00e9sente la feuille la plus \u00e0 droite de l'arbre. La somme des \\(i\\) premiers termes est toujours sup\u00e9rieure ou \u00e9gale \u00e0 \\(i\\) pour tout \\(i\\) de \\(0\\) \u00e0 \\(n\\) . 2] On construit une liste chemin \u00e0 partir de cette liste, en \u00f4tant \\(1\\) \u00e0 chaque nombre de la liste, et enlevant le dernier nombre de cette liste. Propri\u00e9t\u00e9s : Cette liste chemin est de longueur \\(n-1\\) et de somme nulle. La somme des \\(i\\) premiers termes est toujours positive pour tout \\(i\\) de \\(0\\) \u00e0 \\(n-1\\) . Exemple, \u00e0 partir de la liste [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] , on construit [2, -1, 4, -1, 1, -1, -1, -1, -1, -1, -1] On obtient donc une mod\u00e9lisation d'un chemin de \\((0, 0)\\) \u00e0 \\((n-1, 0)\\) situ\u00e9 dans le cadran sup\u00e9rieur droite (abscisses et ordonn\u00e9es positives), dont les \u00e9tapes sont de la forme \\((1, k)\\) avec \\(k=-1\\) ou \\(k\\in \\mathbb N\\) . On appelle un tel chemin un \u00ab chemin de \u0141ukasiewicz \u00bb. Avec l'exemple pr\u00e9c\u00e9dent, on obtient R\u00e9ciproquement, pour tout chemin de \u0141ukasiewicz, on pourrait reconstruire un arbre avec le proc\u00e9d\u00e9 inverse ; c'est plus d\u00e9licat \u00e0 impl\u00e9menter. Ce sera l'objet d'un autre exercice, plus difficile. \u00c9crire une fonction arbre_vers_chemin qui impl\u00e9mente une partie de la correspondance de \u0141ukasiewicz. Exemples repr\u00e9sent\u00e9 en interne avec [[], []] , donne un chemin qui correspond \u00e0 la liste [1, -1] \ud83d\udc0d Console Python >>> arbre_vers_chemin ([[], []]) [1, -1] repr\u00e9sent\u00e9 en interne avec [[], [], [[], []]] , donne un chemin qui correspond \u00e0 la liste [2, -1, -1, 1, -1] \ud83d\udc0d Console Python >>> arbre_vers_chemin ([[], [], [[], []]]) [2, -1, -1, 1, -1] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([]) == []backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[]]) == [0]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[[[[]]]]]) == [0, 0, 0, 0]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], []]) == [2, -1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [], [], []]) == [4, -1, -1, -1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[[]], [[], [], [], [[]], []], []]) == [2, 0, -1, 4, -1, -1, -1, 0, -1, -1]backslash-newlinebackslash-newline Valider 5/5 def arbrepython-underscoreverspython-underscorechemin(arbre):backslash-newline ...backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newline def arbrepython-underscoreverspython-underscorechemin(arbre):backslash-newline def etape(arbre):backslash-newline \"Fonction r\u00c3\u00a9cursive interne\"backslash-newline resultat = [len(arbre)]backslash-newline for souspython-underscorearbre in arbre:backslash-newline resultat.extend(etape(souspython-underscorearbre))backslash-newline return resultatbackslash-newlinebackslash-newline chemin = [y - 1 for y in etape(arbre)]backslash-newline chemin.pop()backslash-newline return cheminbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], []]) == [1, -1]backslash-newlineassert arbrepython-underscoreverspython-underscorechemin([[], [], [[], []]]) == [2, -1, -1, 1, -1]backslash-newlinebackslash-newlinebackslash-newline A","title":"Correspondance de \u0141ukasiewicz"},{"location":"4-Tdifficile/correspondance_Lukasiewicz/sujet/#commentaires","text":"\u0141ukasiewicz a [...] jet\u00e9 les bases de l'informatique moderne en cr\u00e9ant la notation polonaise et en d\u00e9veloppent avec Alfred Tarski et Stefan Banach les fondations de la notation inverse, une mani\u00e8re d'\u00e9crire des expressions arithm\u00e9tiques largement utilis\u00e9es \u00e0 ce jour en informatique. Z","title":"Commentaires"},{"location":"4-Tdifficile/correspondance_Lukasiewicz_2/sujet/","tags":["arbre","chemin","r\u00e9cursivit\u00e9"],"text":"Correspondance de \u0141ukasiewicz (2) \u2693\ufe0e Dans cet exercice, arbre d\u00e9signera un arbre enracin\u00e9 ordonn\u00e9 sans \u00e9tiquette. Chaque arbre sera mod\u00e9lis\u00e9 avec une liste Python. Une feuille (un n\u0153ud externe) sera repr\u00e9sent\u00e9e par une liste vide [] ; la liste de ses sous-arbres est vide. Un n\u0153ud interne sera repr\u00e9sent\u00e9 par la liste de ses sous-arbres donn\u00e9s dans l'ordre. Un arbre sera donn\u00e9 par la repr\u00e9sentation de sa racine. Exemples repr\u00e9sent\u00e9 en interne avec [[[], []], [[]], []] repr\u00e9sent\u00e9 en interne avec [[[]], [[], []], []] Les deux arbres ci-dessus sont diff\u00e9rents. repr\u00e9sent\u00e9 en interne avec [[], [[], [[], []], [], [], []], []] Correspondance de \u0141ukasiewicz Pour un arbre, on note \\(n\\) le nombre de n\u0153uds. On rappelle qu'ici \u00ab arbre \u00bb d\u00e9signa arbre enracin\u00e9, ainsi \\(n>0\\) . On appelle \u00ab chemin de \u0141ukasiewicz \u00bb un chemin de \\((0, 0)\\) \u00e0 \\((n-1, 0)\\) situ\u00e9 dans le cadran sup\u00e9rieur droite (abscisses et ordonn\u00e9es positives), dont les \u00e9tapes sont de la forme \\((1, k)\\) avec \\(k=-1\\) ou \\(k\\in \\mathbb N\\) . Un exercice pr\u00e9c\u00e9dent consistait \u00e0 donner le chemin de \u0141ukasiewicz associ\u00e9 \u00e0 un arbre via une correspondance. L'objectif de cet exercice est de donner l'arbre associ\u00e9 \u00e0 un chemin de \u0141ukasiewicz. Comment faire sur cet exemple ? Le chemin est bien dans la cadrant sup\u00e9rieur. Le chemin est associ\u00e9 \u00e0 une liste de valeurs [2, -1, 4, -1, 1, -1, -1, -1, -1, -1] On ajoute \\(1\\) \u00e0 chaque \u00e9l\u00e9ment, et on ajoute \\(0\\) \u00e0 la fin de la liste. On obtient [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] La difficult\u00e9 est ici ; le d\u00e9coupage . Il y a 3 sous arbres \u00e0 la racine. Le d\u00e9coupage est 3, [0], [5, 0, 2, 0, 0, 0, 0, 0], [0] . Le d\u00e9coupage de [5, 0, 2, 0, 0, 0, 0, 0] est 5, [0], [2, 0, 0], [0], [0], [0] . Enfin, le d\u00e9coupage de [2, 0, 0] est 2, [0], [0] Les [0] obtenus sont les feuilles de l'arbre. Programmer le d\u00e9coupage est d\u00e9licat. \u00c9crire une fonction chemin_vers_arbre qui impl\u00e9mente l'autre partie de la correspondance de \u0141ukasiewicz. Exemples qui correspond \u00e0 la liste [1, -1] , donne un arbre repr\u00e9sent\u00e9 en interne avec [[], []] . \ud83d\udc0d Console Python >>> chemin_vers_arbre ([ 1 , - 1 ]) [[], []] qui correspond \u00e0 la liste [2, -1, -1, 1, -1] , donne un arbre repr\u00e9sent\u00e9 en interne avec [[], [], [[], []]] . \ud83d\udc0d Console Python >>> chemin_vers_arbre ([ 2 , - 1 , - 1 , 1 , - 1 ]) [[], [], [[], []]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([1, -1]) == [[], []]backslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, -1, -1, 1, -1]) == [[], [], [[], []]]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([]) == []backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([0]) == [[]]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([0, 0, 0, 0]) == [[[[[]]]]]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, -1, -1]) == [[], [], []]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([4, -1, -1, -1, -1]) == [[], [], [], [], []]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, 0, -1, 4, -1, -1, -1, 0, -1, -1]) == [[[]], [[], [], [], [[]], []], []]backslash-newlinebackslash-newline Valider 5/5 A Z Indice 1 Il sera utile de cr\u00e9er une fonction r\u00e9cursive qui prend une liste en param\u00e8tre, ainsi qu'une position de d\u00e9part et renvoie la repr\u00e9sentation de l'arbre indiqu\u00e9 \u00e0 cette position, ainsi que la longueur utilis\u00e9e dans la liste. Par exemple \ud83d\udc0d Console Python >>> etape_rec ([ 3 , 0 , 5 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ], 1 ) ([], 1) >>> etape_rec ([ 3 , 0 , 5 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ], 3 ) ([[], []], 3) >>> etape_rec ([ 3 , 0 , 0 , 2 , 0 , 0 ], 0 ) ([[], [], [[], []]], 6) Indice 2 Cette fonction r\u00e9cursive pourra avoir le squelette \ud83d\udc0d Script Python def etape_rec ( temp , i ): \"Fonction r\u00e9cursive interne\" if temp [ i ] == 0 : return [], 1 else : resultat = [] taille_totale = 1 for _ in range ( temp [ i ]): sous_arbre , taille = etape_rec ( ... , ... ) taille_totale = ... resultat . append ( ... ) return resultat , taille_totale","title":"Correspondance de \u0141ukasiewicz (2)"},{"location":"4-Tdifficile/correspondance_Lukasiewicz_2/sujet/#correspondance-de-ukasiewicz-2","text":"Dans cet exercice, arbre d\u00e9signera un arbre enracin\u00e9 ordonn\u00e9 sans \u00e9tiquette. Chaque arbre sera mod\u00e9lis\u00e9 avec une liste Python. Une feuille (un n\u0153ud externe) sera repr\u00e9sent\u00e9e par une liste vide [] ; la liste de ses sous-arbres est vide. Un n\u0153ud interne sera repr\u00e9sent\u00e9 par la liste de ses sous-arbres donn\u00e9s dans l'ordre. Un arbre sera donn\u00e9 par la repr\u00e9sentation de sa racine. Exemples repr\u00e9sent\u00e9 en interne avec [[[], []], [[]], []] repr\u00e9sent\u00e9 en interne avec [[[]], [[], []], []] Les deux arbres ci-dessus sont diff\u00e9rents. repr\u00e9sent\u00e9 en interne avec [[], [[], [[], []], [], [], []], []] Correspondance de \u0141ukasiewicz Pour un arbre, on note \\(n\\) le nombre de n\u0153uds. On rappelle qu'ici \u00ab arbre \u00bb d\u00e9signa arbre enracin\u00e9, ainsi \\(n>0\\) . On appelle \u00ab chemin de \u0141ukasiewicz \u00bb un chemin de \\((0, 0)\\) \u00e0 \\((n-1, 0)\\) situ\u00e9 dans le cadran sup\u00e9rieur droite (abscisses et ordonn\u00e9es positives), dont les \u00e9tapes sont de la forme \\((1, k)\\) avec \\(k=-1\\) ou \\(k\\in \\mathbb N\\) . Un exercice pr\u00e9c\u00e9dent consistait \u00e0 donner le chemin de \u0141ukasiewicz associ\u00e9 \u00e0 un arbre via une correspondance. L'objectif de cet exercice est de donner l'arbre associ\u00e9 \u00e0 un chemin de \u0141ukasiewicz. Comment faire sur cet exemple ? Le chemin est bien dans la cadrant sup\u00e9rieur. Le chemin est associ\u00e9 \u00e0 une liste de valeurs [2, -1, 4, -1, 1, -1, -1, -1, -1, -1] On ajoute \\(1\\) \u00e0 chaque \u00e9l\u00e9ment, et on ajoute \\(0\\) \u00e0 la fin de la liste. On obtient [3, 0, 5, 0, 2, 0, 0, 0, 0, 0, 0] La difficult\u00e9 est ici ; le d\u00e9coupage . Il y a 3 sous arbres \u00e0 la racine. Le d\u00e9coupage est 3, [0], [5, 0, 2, 0, 0, 0, 0, 0], [0] . Le d\u00e9coupage de [5, 0, 2, 0, 0, 0, 0, 0] est 5, [0], [2, 0, 0], [0], [0], [0] . Enfin, le d\u00e9coupage de [2, 0, 0] est 2, [0], [0] Les [0] obtenus sont les feuilles de l'arbre. Programmer le d\u00e9coupage est d\u00e9licat. \u00c9crire une fonction chemin_vers_arbre qui impl\u00e9mente l'autre partie de la correspondance de \u0141ukasiewicz. Exemples qui correspond \u00e0 la liste [1, -1] , donne un arbre repr\u00e9sent\u00e9 en interne avec [[], []] . \ud83d\udc0d Console Python >>> chemin_vers_arbre ([ 1 , - 1 ]) [[], []] qui correspond \u00e0 la liste [2, -1, -1, 1, -1] , donne un arbre repr\u00e9sent\u00e9 en interne avec [[], [], [[], []]] . \ud83d\udc0d Console Python >>> chemin_vers_arbre ([ 2 , - 1 , - 1 , 1 , - 1 ]) [[], [], [[], []]] Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([1, -1]) == [[], []]backslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, -1, -1, 1, -1]) == [[], [], [[], []]]backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert cheminpython-underscoreverspython-underscorearbre([]) == []backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([0]) == [[]]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([0, 0, 0, 0]) == [[[[[]]]]]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, -1, -1]) == [[], [], []]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([4, -1, -1, -1, -1]) == [[], [], [], [], []]backslash-newlineassert cheminpython-underscoreverspython-underscorearbre([2, 0, -1, 4, -1, -1, -1, 0, -1, -1]) == [[[]], [[], [], [], [[]], []], []]backslash-newlinebackslash-newline Valider 5/5 A Z Indice 1 Il sera utile de cr\u00e9er une fonction r\u00e9cursive qui prend une liste en param\u00e8tre, ainsi qu'une position de d\u00e9part et renvoie la repr\u00e9sentation de l'arbre indiqu\u00e9 \u00e0 cette position, ainsi que la longueur utilis\u00e9e dans la liste. Par exemple \ud83d\udc0d Console Python >>> etape_rec ([ 3 , 0 , 5 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ], 1 ) ([], 1) >>> etape_rec ([ 3 , 0 , 5 , 0 , 2 , 0 , 0 , 0 , 0 , 0 , 0 ], 3 ) ([[], []], 3) >>> etape_rec ([ 3 , 0 , 0 , 2 , 0 , 0 ], 0 ) ([[], [], [[], []]], 6) Indice 2 Cette fonction r\u00e9cursive pourra avoir le squelette \ud83d\udc0d Script Python def etape_rec ( temp , i ): \"Fonction r\u00e9cursive interne\" if temp [ i ] == 0 : return [], 1 else : resultat = [] taille_totale = 1 for _ in range ( temp [ i ]): sous_arbre , taille = etape_rec ( ... , ... ) taille_totale = ... resultat . append ( ... ) return resultat , taille_totale","title":"Correspondance de \u0141ukasiewicz (2)"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/","text":"Commentaires \u2693\ufe0e Force brute \u2693\ufe0e \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante. Premi\u00e8re version du crible \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible Deuxi\u00e8me version \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) . Troisi\u00e8me version \u2693\ufe0e Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice...","title":"Commentaires"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/#force-brute","text":"\ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante.","title":"Force brute"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/#premiere-version-du-crible","text":"\ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible","title":"Premi\u00e8re version du crible"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/#deuxieme-version","text":"\ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) .","title":"Deuxi\u00e8me version"},{"location":"4-Tdifficile/eratosthene_2/exo_REM/#troisieme-version","text":"Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice...","title":"Troisi\u00e8me version"},{"location":"4-Tdifficile/eratosthene_2/sujet/","text":"Crible d'\u00c9ratosth\u00e8ne \u2693\ufe0e Objectif : obtenir la primalit\u00e9 des nombres de \\(2\\) jusqu'\u00e0 \\(n\\) . Nombres premiers D\u00e9finition : Un nombre \\(p\\) est premier si c'est un entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(2\\) qui n'a que deux diviseurs : \\(1\\) et lui-m\u00eame. D'apr\u00e8s la d\u00e9finition, on peut \u00e9crire directement \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True On peut d\u00e9duire la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(20\\) . \ud83d\udc0d Console Python >>> [ n for n in range ( 20 ) if est_premier ( n )] [2, 3, 5, 7, 11, 13, 17, 19] Cette m\u00e9thode est lente. Am\u00e9liorations du crible classique \u2693\ufe0e On peut rassembler la primalit\u00e9 des nombres inf\u00e9rieurs \u00e0 \\(20\\) dans un tableau de bool\u00e9ens : \ud83d\udc0d Console Python >>> # indice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 >>> primalite = [ False , False , True , True , False , True , False , True , False , False , False , True , False , True , False , False , False , True , False , True ] >>> primalite [ 5 ] True >>> primalite [ 6 ] False Objectif : Construire rapidement un tel tableau. M\u00e9thode : On peut utiliser le crible d'\u00c9ratosth\u00e8ne. Il existe plusieurs variantes, voici une version interm\u00e9diaire. Vous avez d\u00e9j\u00e0 rencontr\u00e9 une premi\u00e8re version qui ressemble \u00e0 : \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible On peut v\u00e9rifier ceci avec les tests \ud83d\udc0d Console Python >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> primalite_brute = [ est_premier ( i ) for i in range ( limite )] >>> primalite == primalite_brute True L'objectif de l'exercice est d'am\u00e9liorer la fonction eratosthene en suivant les conseils suivants : Remplacer la ligne for p in range ( 2 , n ): par une structure avec une boucle while . Remplacer la ligne for kp in range ( 2 * p , n , p ): par for kp in range ( p * p , n , p ): , en effet les multiples de \\(2p\\) inclus \u00e0 \\(p^2\\) exclu ont d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. En d\u00e9duire que quand \\(p\u00d7p >= n\\) il n'y plus de nouveaux multiples \u00e0 cocher. Ils ont tous d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. C'est une propri\u00e9t\u00e9 math\u00e9matique : \u00ab Si un entier \\(n\\) est compos\u00e9, alors il poss\u00e8de un diviseur premier inf\u00e9rieur ou \u00e9gal \u00e0 \\(\\sqrt{n}\\) \u00bb. Modifier la boucle while en cons\u00e9quence. Tester votre fonction eratosthene_V2 en la confrontant \u00e0 eratosthene et \u00e0 une m\u00e9thode par force brute. G\u00e9n\u00e9ration des nombres premiers \u2693\ufe0e Quand vous aurez termin\u00e9, vous pourrez tester une astuce avec Python pour g\u00e9n\u00e9rer la liste des nombres premiers \u00e0 partir du tableau de bool\u00e9ens primalite . Lire la documentation au sujet de itertools.compress \ud83d\udc0d Console Python >>> from itertools import compress >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> list ( compress ( range ( limite ), primalite )) [2, 3, 5, 7, 11, 13, 17 ,19] Pour tester cela, construire une fonction telle que somme_premiers(n) renvoie la somme des nombres premiers strictement inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> somme_premiers ( 5 ) 5 >>> somme_premiers ( 20 ) 77 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef SOMMEpython-underscorepremiers(n):backslash-newline return sum(p for p in range(n) if ESTpython-underscorepremier(p))backslash-newlinebackslash-newlinebackslash-newlinefor n in range(100):backslash-newline attendu = SOMMEpython-underscorepremiers(n)backslash-newline assert sommepython-underscorepremiers(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def sommepython-underscorepremiers(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newline def estpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline for p in range(2, n):backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV2(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(ppython-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV3(n):backslash-newline crible = bytearray([True]) python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline crible[ppython-starp:n:p] = bytearray([False]) python-star len(crible[ppython-starp:n:p])backslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinefrom itertools import compressbackslash-newlinebackslash-newlinedef sommepython-underscorepremiers(n):backslash-newline if n < 2:backslash-newline return 0backslash-newline primalite = eratosthenepython-underscoreV2(n)backslash-newline return sum(compress(range(n), primalite))backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newline# tests \u00c3 cr\u00c3\u00a9erbackslash-newlinebackslash-newlinefor limite in range(20):backslash-newline primalite = eratosthene(limite)backslash-newline primalitepython-underscoreV3 = eratosthenepython-underscoreV3(limite)backslash-newline primalitepython-underscorebrute = [estpython-underscorepremier(i) for i in range(limite)]backslash-newline assert list(primalitepython-underscoreV3) == primalite == primalitepython-underscorebrute, f\"{limite}, {list(primalitepython-underscoreV3)} {primalite}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Force brute \u2693\ufe0e \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante. Premi\u00e8re version du crible \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible Deuxi\u00e8me version \u2693\ufe0e \ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) . Troisi\u00e8me version \u2693\ufe0e Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice... Z Vous ajouterez tous les tests utiles aux diff\u00e9rentes \u00e9tapes.","title":"Crible d'\u00c9ratosth\u00e8ne V2"},{"location":"4-Tdifficile/eratosthene_2/sujet/#crible-deratosthene","text":"Objectif : obtenir la primalit\u00e9 des nombres de \\(2\\) jusqu'\u00e0 \\(n\\) . Nombres premiers D\u00e9finition : Un nombre \\(p\\) est premier si c'est un entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(2\\) qui n'a que deux diviseurs : \\(1\\) et lui-m\u00eame. D'apr\u00e8s la d\u00e9finition, on peut \u00e9crire directement \ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True On peut d\u00e9duire la liste des nombres premiers inf\u00e9rieurs \u00e0 \\(20\\) . \ud83d\udc0d Console Python >>> [ n for n in range ( 20 ) if est_premier ( n )] [2, 3, 5, 7, 11, 13, 17, 19] Cette m\u00e9thode est lente.","title":"Crible d'\u00c9ratosth\u00e8ne"},{"location":"4-Tdifficile/eratosthene_2/sujet/#ameliorations-du-crible-classique","text":"On peut rassembler la primalit\u00e9 des nombres inf\u00e9rieurs \u00e0 \\(20\\) dans un tableau de bool\u00e9ens : \ud83d\udc0d Console Python >>> # indice 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 >>> primalite = [ False , False , True , True , False , True , False , True , False , False , False , True , False , True , False , False , False , True , False , True ] >>> primalite [ 5 ] True >>> primalite [ 6 ] False Objectif : Construire rapidement un tel tableau. M\u00e9thode : On peut utiliser le crible d'\u00c9ratosth\u00e8ne. Il existe plusieurs variantes, voici une version interm\u00e9diaire. Vous avez d\u00e9j\u00e0 rencontr\u00e9 une premi\u00e8re version qui ressemble \u00e0 : \ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible On peut v\u00e9rifier ceci avec les tests \ud83d\udc0d Console Python >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> primalite_brute = [ est_premier ( i ) for i in range ( limite )] >>> primalite == primalite_brute True L'objectif de l'exercice est d'am\u00e9liorer la fonction eratosthene en suivant les conseils suivants : Remplacer la ligne for p in range ( 2 , n ): par une structure avec une boucle while . Remplacer la ligne for kp in range ( 2 * p , n , p ): par for kp in range ( p * p , n , p ): , en effet les multiples de \\(2p\\) inclus \u00e0 \\(p^2\\) exclu ont d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. En d\u00e9duire que quand \\(p\u00d7p >= n\\) il n'y plus de nouveaux multiples \u00e0 cocher. Ils ont tous d\u00e9j\u00e0 \u00e9t\u00e9 coch\u00e9s. C'est une propri\u00e9t\u00e9 math\u00e9matique : \u00ab Si un entier \\(n\\) est compos\u00e9, alors il poss\u00e8de un diviseur premier inf\u00e9rieur ou \u00e9gal \u00e0 \\(\\sqrt{n}\\) \u00bb. Modifier la boucle while en cons\u00e9quence. Tester votre fonction eratosthene_V2 en la confrontant \u00e0 eratosthene et \u00e0 une m\u00e9thode par force brute.","title":"Am\u00e9liorations du crible classique"},{"location":"4-Tdifficile/eratosthene_2/sujet/#generation-des-nombres-premiers","text":"Quand vous aurez termin\u00e9, vous pourrez tester une astuce avec Python pour g\u00e9n\u00e9rer la liste des nombres premiers \u00e0 partir du tableau de bool\u00e9ens primalite . Lire la documentation au sujet de itertools.compress \ud83d\udc0d Console Python >>> from itertools import compress >>> limite = 20 >>> primalite = eratosthene ( limite ) >>> list ( compress ( range ( limite ), primalite )) [2, 3, 5, 7, 11, 13, 17 ,19] Pour tester cela, construire une fonction telle que somme_premiers(n) renvoie la somme des nombres premiers strictement inf\u00e9rieurs \u00e0 \\(n\\) . Exemples \ud83d\udc0d Console Python >>> somme_premiers ( 5 ) 5 >>> somme_premiers ( 20 ) 77 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef ESTpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef SOMMEpython-underscorepremiers(n):backslash-newline return sum(p for p in range(n) if ESTpython-underscorepremier(p))backslash-newlinebackslash-newlinebackslash-newlinefor n in range(100):backslash-newline attendu = SOMMEpython-underscorepremiers(n)backslash-newline assert sommepython-underscorepremiers(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def sommepython-underscorepremiers(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newline def estpython-underscorepremier(n):backslash-newline if n < 2:backslash-newline return Falsebackslash-newline for d in range(2, n):backslash-newline # 1 < d < nbackslash-newline if n % d == 0:backslash-newline # d est un diviseur de n, autre que 1 et nbackslash-newline return Falsebackslash-newline return Truebackslash-newlinebackslash-newlinedef eratosthene(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline for p in range(2, n):backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(2python-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV2(n):backslash-newline crible = [True] python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline # p est premierbackslash-newline for kp in range(ppython-starp, n, p):backslash-newline # kp est un multiple de p, donc non premierbackslash-newline crible[kp] = Falsebackslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinedef eratosthenepython-underscoreV3(n):backslash-newline crible = bytearray([True]) python-star nbackslash-newline if n > 0:backslash-newline crible[0] = False # 0 n'est pas premierbackslash-newline if n > 1:backslash-newline crible[1] = False # 1 n'est pas premierbackslash-newline p = 2backslash-newline while p python-star p < n:backslash-newline if crible[p]:backslash-newline crible[ppython-starp:n:p] = bytearray([False]) python-star len(crible[ppython-starp:n:p])backslash-newline p += 1backslash-newline return criblebackslash-newlinebackslash-newlinefrom itertools import compressbackslash-newlinebackslash-newlinedef sommepython-underscorepremiers(n):backslash-newline if n < 2:backslash-newline return 0backslash-newline primalite = eratosthenepython-underscoreV2(n)backslash-newline return sum(compress(range(n), primalite))backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert sommepython-underscorepremiers(5) == 5backslash-newlineassert sommepython-underscorepremiers(20) == 77backslash-newlinebackslash-newlinebackslash-newline# tests \u00c3 cr\u00c3\u00a9erbackslash-newlinebackslash-newlinefor limite in range(20):backslash-newline primalite = eratosthene(limite)backslash-newline primalitepython-underscoreV3 = eratosthenepython-underscoreV3(limite)backslash-newline primalitepython-underscorebrute = [estpython-underscorepremier(i) for i in range(limite)]backslash-newline assert list(primalitepython-underscoreV3) == primalite == primalitepython-underscorebrute, f\"{limite}, {list(primalitepython-underscoreV3)} {primalite}\"backslash-newlinebackslash-newlinebackslash-newlinebackslash-newline A","title":"G\u00e9n\u00e9ration des nombres premiers"},{"location":"4-Tdifficile/eratosthene_2/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/eratosthene_2/sujet/#force-brute","text":"\ud83d\udc0d Script Python def est_premier ( n ): if n < 2 : return False for d in range ( 2 , n ): # 1 < d < n if n % d == 0 : # d est un diviseur de n, autre que 1 et n return False return True def crible_brute ( limite ): return [ est_premier ( i ) for i in range ( limite )] Il s'agit d'une traduction directe de la d\u00e9finition. Cette version est lente, en effet le cout du calcul pour est_premier(n) est dans le pire des cas de n tours de boucles. La somme des couts pour i allant de z\u00e9ro jusqu'\u00e0 la limite est importante.","title":"Force brute"},{"location":"4-Tdifficile/eratosthene_2/sujet/#premiere-version-du-crible","text":"\ud83d\udc0d Script Python def eratosthene ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier for p in range ( 2 , n ): if crible [ p ]: # p est premier for kp in range ( 2 * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False return crible","title":"Premi\u00e8re version du crible"},{"location":"4-Tdifficile/eratosthene_2/sujet/#deuxieme-version","text":"\ud83d\udc0d Script Python def eratosthene_V2 ( n ): crible = [ True ] * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: # p est premier for kp in range ( p * p , n , p ): # kp est un multiple de p, donc non premier crible [ kp ] = False p += 1 return crible La principale diff\u00e9rence est que la boucle interne commence \u00e0 \\(p^2\\) , en effet les multiples pr\u00e9c\u00e9dents de \\(p\\) ont d\u00e9j\u00e0 \u00e9t\u00e9 marqu\u00e9s comme compos\u00e9s. On a alors remplac\u00e9 la boucle externe par une boucle while qui s'arr\u00eate quand \\(p^2\\) atteint la limite \\(n\\) .","title":"Deuxi\u00e8me version"},{"location":"4-Tdifficile/eratosthene_2/sujet/#troisieme-version","text":"Voici quelques astuces pour am\u00e9liorer le crible. \ud83d\udc0d Script Python def eratosthene_V3 ( n ): crible = bytearray ([ True ]) * n if n > 0 : crible [ 0 ] = False # 0 n'est pas premier if n > 1 : crible [ 1 ] = False # 1 n'est pas premier p = 2 while p * p < n : if crible [ p ]: crible [ p * p : n : p ] = bytearray ([ False ]) * len ( crible [ p * p : n : p ]) p += 1 return crible Un bool\u00e9en prend beaucoup de place en Python pour la quantit\u00e9 d'information qu'il porte. Une liste de bool\u00e9en accentue fortement cet effet. On utilise alors byterray qui fonctionne exactement comme une liste, mais ses \u00e9l\u00e9ments sont des entiers sur un octet seulement, au lieu de plusieurs pour les listes. Il y a un gain important en m\u00e9moire, donc en temps ! On remplace la boucle interne par une affectation d'une tranche par une autre tranche. Il reste une autre bonne am\u00e9lioration \u00e0 mettre en place. On peut calculer len ( crible [ p * p : n : p ]) en fonction de n et de p ; ce qui \u00e9vite un parcours de cette tranche. C'est \u00e0 vous de trouver la formule ! Pour rechercher encore l'optimisation, mais au prix d'un code plus lourd, on pourra cr\u00e9er une liste ne mod\u00e9lisant que les nombres impairs. On fera le crible directement sur cette liste qui prend deux fois moins de place. On pensera lors de la g\u00e9n\u00e9ration des nombres premiers \u00e0 ajouter 2 au d\u00e9but. Cette optimisation fera l'objet d'un exercice... Z Vous ajouterez tous les tests utiles aux diff\u00e9rentes \u00e9tapes.","title":"Troisi\u00e8me version"},{"location":"4-Tdifficile/fact2_nb_zeros_2/exo_REM/","text":"Commentaires \u2693\ufe0e Solution \u2693\ufe0e \ud83d\udc0d Script Python def nb_zeros_factorielle ( n ): resultat = 0 puiss_5 = 5 while puiss_5 <= n : resultat += n // puiss_5 puiss_5 *= 5 return resultat Compl\u00e9ment \u2693\ufe0e Cette m\u00e9thode se g\u00e9n\u00e9ralise pour d\u00e9terminer la valuation \\(p\\) -adique d'un entier \\(n\\) . Si \\(n\\) est un entier naturel, et \\(p\\) un nombre premier, la formule de Legendre donne l'exposant de \\(p\\) dans la d\u00e9composition en facteur premier de \\(n!\\) . \\[v_p(n!) = \\sum_{k=1}^{\\infty} \\lfloor \\frac{n}{p^k} \\rfloor = \\lfloor \\frac{n}{p} \\rfloor + \\lfloor \\frac{n}{p^2} \\rfloor + \\lfloor \\frac{n}{p^3} \\rfloor + \\cdots\\] La somme s'arr\u00eate ; tous les termes sont nuls \u00e0 partir d'un certain rang. \\(\\lfloor \\frac{a}{b} \\rfloor\\) est la partie enti\u00e8re de \\(a\\) divis\u00e9 par \\(b\\) . Avec Python, on peut simplement faire a // b . Cela donne une fonction Python \ud83d\udc0d Script Python def valuation ( n , p ): \"\"\"Renvoie la valuation p-adique de n! - n est un entier naturel - p est un nombre premier \"\"\" resultat = 0 puiss_p = p while puiss_p <= n : resultat += n // puiss_p puiss_p *= p return resultat On peut se servir de cette fonction pour obtenir la d\u00e9composition compl\u00e8te en facteurs premiers de \\(n!\\) , mais aussi de coefficients binomiaux qui se calculent avec des factorielles. Il faudra juste avoir une liste de nombres premiers... C'est toujours tr\u00e8s utile.","title":"Commentaires"},{"location":"4-Tdifficile/fact2_nb_zeros_2/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/fact2_nb_zeros_2/exo_REM/#solution","text":"\ud83d\udc0d Script Python def nb_zeros_factorielle ( n ): resultat = 0 puiss_5 = 5 while puiss_5 <= n : resultat += n // puiss_5 puiss_5 *= 5 return resultat","title":"Solution"},{"location":"4-Tdifficile/fact2_nb_zeros_2/exo_REM/#complement","text":"Cette m\u00e9thode se g\u00e9n\u00e9ralise pour d\u00e9terminer la valuation \\(p\\) -adique d'un entier \\(n\\) . Si \\(n\\) est un entier naturel, et \\(p\\) un nombre premier, la formule de Legendre donne l'exposant de \\(p\\) dans la d\u00e9composition en facteur premier de \\(n!\\) . \\[v_p(n!) = \\sum_{k=1}^{\\infty} \\lfloor \\frac{n}{p^k} \\rfloor = \\lfloor \\frac{n}{p} \\rfloor + \\lfloor \\frac{n}{p^2} \\rfloor + \\lfloor \\frac{n}{p^3} \\rfloor + \\cdots\\] La somme s'arr\u00eate ; tous les termes sont nuls \u00e0 partir d'un certain rang. \\(\\lfloor \\frac{a}{b} \\rfloor\\) est la partie enti\u00e8re de \\(a\\) divis\u00e9 par \\(b\\) . Avec Python, on peut simplement faire a // b . Cela donne une fonction Python \ud83d\udc0d Script Python def valuation ( n , p ): \"\"\"Renvoie la valuation p-adique de n! - n est un entier naturel - p est un nombre premier \"\"\" resultat = 0 puiss_p = p while puiss_p <= n : resultat += n // puiss_p puiss_p *= p return resultat On peut se servir de cette fonction pour obtenir la d\u00e9composition compl\u00e8te en facteurs premiers de \\(n!\\) , mais aussi de coefficients binomiaux qui se calculent avec des factorielles. Il faudra juste avoir une liste de nombres premiers... C'est toujours tr\u00e8s utile.","title":"Compl\u00e9ment"},{"location":"4-Tdifficile/fact2_nb_zeros_2/sujet/","tags":["maths+","boucle"],"text":"Nombre de z\u00e9ros de n factoriel ; n grand \u2693\ufe0e On rappelle que, pour \\(n\\) un entier naturel, la factorielle de \\(n\\) se note \\(n!\\) et se d\u00e9finit comme le produit des entiers de \\(1\\) \u00e0 \\(n\\) . \\(0! = 1\\) , comme un produit vide. \\(1! = 1\\) \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(11! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\u00d78\u00d79\u00d710\u00d711 = 39916800\\) \\(42! = 1405006117752879898543142606244511569936384000000000\\) On constate que \\(3!\\) se termine par aucun z\u00e9ro. \\(11!\\) se termine par 2 z\u00e9ros. \\(42!\\) se termine par 9 z\u00e9ros. Construire une fonction , tel que nb_zeros_factorielle(n) renvoie le nombre de z\u00e9ros dans l'\u00e9criture d\u00e9cimale de \\(n!\\) , pour \\(n\\) entier inf\u00e9rieur \u00e0 \\(10^{18}\\) . Exemples \ud83d\udc0d Console Python >>> nb_zeros_factorielle ( 3 ) 0 >>> nb_zeros_factorielle ( 11 ) 2 >>> nb_zeros_factorielle ( 42 ) 9 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline# autre testsbackslash-newlinebackslash-newline\"\"\"backslash-newlinefor n in range(100):backslash-newline print(nbpython-underscorezerospython-underscorefactorielle(n), end=\", \")backslash-newlinebackslash-newlinefrom random import python-starbackslash-newlinefor i in range(17):backslash-newline for python-underscore in range(10):backslash-newline n = randrange(10python-starpython-stari, 10python-starpython-star(i+1))backslash-newline print((n, nbpython-underscorezerospython-underscorefactorielle(n)), end=\", \")backslash-newline\"\"\"backslash-newlinebackslash-newlinePETITS = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22,]backslash-newlinefor n, attendu in enumerate(PETITS):backslash-newline assert nbpython-underscorezerospython-underscorefactorielle(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinebackslash-newlineCOUPLES = [(7, 1), (2, 0), (9, 1), (9, 1), (2, 0), (4, 0), (6, 1), (3, 0), (5, 1), (8, 1), (16, 3), (97, 22), (78, 18), (98, 22), (58, 13), (45, 10), (93, 21), (68, 15), (41, 9), (68, 15), (685, 170), (659, 163), (530, 131), (493, 120), (683, 169), (845, 209), (770, 191), (982, 243), (365, 89), (289, 70), (1050, 261), (9455, 2362), (7537, 1882), (7536, 1882), (9362, 2336), (8394, 2095), (3254, 812), (6188, 1543), (7051, 1761), (7006, 1750), (22793, 5695), (91583, 22892), (28019, 7000), (25766, 6439), (66010, 16500), (85762, 21438), (98464, 24612), (27779, 6941), (92939, 23230), (17577, 4392), (664955, 166234), (392167, 98039), (219530, 54880), (596024, 149001), (852393, 213093), (757725, 189427), (537003, 134247), (569746, 142432), (720321, 180076), (760423, 190100), (9864166, 2466038), (3936351, 984084), (2554139, 638530), (5600487, 1400116), (6148810, 1537198), (4758791, 1189693), (8249433, 2062353), (3571734, 892927), (1840833, 460203), (6806599, 1701644), (58037629, 14509402), (27880791, 6970192), (31921612, 7980396), (41858181, 10464540), (71827981, 17956988), (42356047, 10589005), (39048190, 9762041), (45274424, 11318599), (39599801, 9899945), (97036229, 24259050), (800398176, 200099539), (140720239, 35180054), (278646632, 69661652), (597677495, 149419368), (981777051, 245444257), (975014653, 243753656), (432577103, 108144268), (530968050, 132742006), (879778198, 219944544), (628192898, 157048217), (1399829940, 349957478), (5074896726, 1268724173), (9860267700, 2465066919), (9692888733, 2423222173), (2704381881, 676095466), (5774520969, 1443630233), (2240891591, 560222891), (6811274839, 1702818701), (5961817060, 1490454259), (7826628749, 1956657180), (41136662363, 10284165581), (52565037117, 13141259271), (63607552056, 15901888008), (23188519592, 5797129889), (89748095845, 22437023954), (15650281184, 3912570286), (50090331406, 12522582847), (20967136984, 5241784238), (14344138004, 3586034492), (53772868694, 13443217164), (975871201654, 243967800405), (482703545289, 120675886314), (331273451253, 82818362807), (395076944881, 98769236211), (189815352140, 47453838029), (788906837428, 197226709349), (928843071399, 232210767841), (553488566695, 138372141666), (254134881665, 63533720409), (758622380618, 189655595143), (6488379282292, 1622094820565), (4356794834447, 1089198708602), (9656612303548, 2414153075878), (7644224478447, 1911056119603), (8610531572702, 2152632893167), (2009995664733, 502498916172), (7034946412203, 1758736603042), (8848382740005, 2212095684991), (4383738122351, 1095934530577), (2781408666826, 695352166698), (87286132334981, 21821533083732), (42589487541999, 10647371885489), (54696969378075, 13674242344508), (57765126008076, 14441281502008), (58176286397091, 14544071599265), (75050064429567, 18762516107381), (89192156333243, 22298039083301), (12989438872457, 3247359718104), (41916706897524, 10479176724370), (87531669966937, 21882917491724), (510580878072362, 127645219518079), (786049640068306, 196512410017067), (111801193096217, 27950298274043), (668069621008732, 167017405252172), (571615903728973, 142903975932230), (670800572001129, 167700143000272), (132999948308075, 33249987077007), (521818723804123, 130454680951017), (545190359796199, 136297589949035), (670360049737213, 167590012434292), (3495053667342183, 873763416835534), (3253069295544998, 813267323886235), (8404818041669655, 2101204510417403), (2862987795683907, 715746948920967), (7536249205455639, 1884062301363898), (6126641325199803, 1531660331299938), (5937109965109064, 1484277491277255), (5401717470040138, 1350429367510023), (5398925943459609, 1349731485864894), (5148530753646852, 1287132688411700), (67589630016912814, 16897407504228190), (79506573195211867, 19876643298802952), (43711590897574851, 10927897724393699), (35862471175212753, 8965617793803179), (99369028741191436, 24842257185297846), (77557972579435142, 19389493144858774), (55649795884135111, 13912448971033764), (59000293312803830, 14750073328200946), (14954805986036612, 3738701496509142), (31017683057609138, 7754420764402274),]backslash-newlinefor n, attendu in COUPLES:backslash-newline assert nbpython-underscorezerospython-underscorefactorielle(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorezerospython-underscorefactorielle(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline def nbpython-underscorezerospython-underscorefactorielle(n):backslash-newline resultat = 0backslash-newline puisspython-underscore5 = 5backslash-newline while puisspython-underscore5 <= n:backslash-newline resultat += n // puisspython-underscore5backslash-newline puisspython-underscore5 python-star= 5backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Solution \u2693\ufe0e {{ py('exo_corr') }} Compl\u00e9ment \u2693\ufe0e Cette m\u00e9thode se g\u00e9n\u00e9ralise pour d\u00e9terminer la valuation \\(p\\) -adique d'un entier \\(n\\) . Si \\(n\\) est un entier naturel, et \\(p\\) un nombre premier, la formule de Legendre donne l'exposant de \\(p\\) dans la d\u00e9composition en facteur premier de \\(n!\\) . \\[v_p(n!) = \\sum_{k=1}^{\\infty} \\lfloor \\frac{n}{p^k} \\rfloor = \\lfloor \\frac{n}{p} \\rfloor + \\lfloor \\frac{n}{p^2} \\rfloor + \\lfloor \\frac{n}{p^3} \\rfloor + \\cdots\\] La somme s'arr\u00eate ; tous les termes sont nuls \u00e0 partir d'un certain rang. \\(\\lfloor \\frac{a}{b} \\rfloor\\) est la partie enti\u00e8re de \\(a\\) divis\u00e9 par \\(b\\) . Avec Python, on peut simplement faire a // b . Cela donne une fonction Python \ud83d\udc0d Script Python def valuation ( n , p ): \"\"\"Renvoie la valuation p-adique de n! - n est un entier naturel - p est un nombre premier \"\"\" resultat = 0 puiss_p = p while puiss_p <= n : resultat += n // puiss_p puiss_p *= p return resultat On peut se servir de cette fonction pour obtenir la d\u00e9composition compl\u00e8te en facteurs premiers de \\(n!\\) , mais aussi de coefficients binomiaux qui se calculent avec des factorielles. Il faudra juste avoir une liste de nombres premiers... C'est toujours tr\u00e8s utile. Z Indice 1 Il n'est pas possible de construire un tableau de tous les r\u00e9sultats. Il faut penser d\u00e9composition en facteurs premiers de \\(n!\\) . Une divisibilit\u00e9 par \\(10\\) signifie la pr\u00e9sence de \\(2\\) et \\(5\\) dans la d\u00e9composition. Le nombre de z\u00e9ros d'un nombre est le minimum de l'exposant de 2 et de celui de 5 dans la d\u00e9composition en facteurs premiers du nombre. Pour \\(n!\\) , le nombre de z\u00e9ros est l'exposant de 5 qui est plus petit que l'exposant de 2. Indice 2 Combien y a-t-il de multiples de 5 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro. Combien y a-t-il de multiples de 25 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro suppl\u00e9mentaire. Combien y a-t-il de multiples de 125 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro suppl\u00e9mentaire. Quand faut-il arr\u00eater cette liste ? Et comment la g\u00e9n\u00e9rer ? Indice 3 On utilisera une variable puiss_5 qui sera une puissance de 5. La puissance suivante s'obtient avec puiss_5 *= 5 . Il y a n // k multiples de \\(k\\) de \\(1\\) \u00e0 \\(n\\) , par exemple : Il y a 42 // 5 = 8 multiples de 5 de \\(1\\) \u00e0 \\(42\\) : \\(5\\) , \\(10\\) , \\(15\\) , \\(20\\) , \\(25\\) , \\(30\\) , \\(35\\) et \\(40\\) . Il y a 42 // 25 = 1 multiple de 25 de \\(1\\) \u00e0 \\(42\\) : \\(25\\) . Il y a 42 // 125 = 0 multiple de 125 de \\(1\\) \u00e0 \\(42\\) . Il y a \\(8+1+0=9\\) z\u00e9ros \u00e0 la fin de \\(42!\\)","title":"Nombre de z\u00e9ros de n! (2)"},{"location":"4-Tdifficile/fact2_nb_zeros_2/sujet/#nombre-de-zeros-de-n-factoriel-n-grand","text":"On rappelle que, pour \\(n\\) un entier naturel, la factorielle de \\(n\\) se note \\(n!\\) et se d\u00e9finit comme le produit des entiers de \\(1\\) \u00e0 \\(n\\) . \\(0! = 1\\) , comme un produit vide. \\(1! = 1\\) \\(2! = 1\u00d72 = 2\\) \\(3! = 1\u00d72\u00d73 = 6\\) \\(11! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\u00d78\u00d79\u00d710\u00d711 = 39916800\\) \\(42! = 1405006117752879898543142606244511569936384000000000\\) On constate que \\(3!\\) se termine par aucun z\u00e9ro. \\(11!\\) se termine par 2 z\u00e9ros. \\(42!\\) se termine par 9 z\u00e9ros. Construire une fonction , tel que nb_zeros_factorielle(n) renvoie le nombre de z\u00e9ros dans l'\u00e9criture d\u00e9cimale de \\(n!\\) , pour \\(n\\) entier inf\u00e9rieur \u00e0 \\(10^{18}\\) . Exemples \ud83d\udc0d Console Python >>> nb_zeros_factorielle ( 3 ) 0 >>> nb_zeros_factorielle ( 11 ) 2 >>> nb_zeros_factorielle ( 42 ) 9 Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline# autre testsbackslash-newlinebackslash-newline\"\"\"backslash-newlinefor n in range(100):backslash-newline print(nbpython-underscorezerospython-underscorefactorielle(n), end=\", \")backslash-newlinebackslash-newlinefrom random import python-starbackslash-newlinefor i in range(17):backslash-newline for python-underscore in range(10):backslash-newline n = randrange(10python-starpython-stari, 10python-starpython-star(i+1))backslash-newline print((n, nbpython-underscorezerospython-underscorefactorielle(n)), end=\", \")backslash-newline\"\"\"backslash-newlinebackslash-newlinePETITS = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 16, 16, 16, 16, 16, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22,]backslash-newlinefor n, attendu in enumerate(PETITS):backslash-newline assert nbpython-underscorezerospython-underscorefactorielle(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newlinebackslash-newlineCOUPLES = [(7, 1), (2, 0), (9, 1), (9, 1), (2, 0), (4, 0), (6, 1), (3, 0), (5, 1), (8, 1), (16, 3), (97, 22), (78, 18), (98, 22), (58, 13), (45, 10), (93, 21), (68, 15), (41, 9), (68, 15), (685, 170), (659, 163), (530, 131), (493, 120), (683, 169), (845, 209), (770, 191), (982, 243), (365, 89), (289, 70), (1050, 261), (9455, 2362), (7537, 1882), (7536, 1882), (9362, 2336), (8394, 2095), (3254, 812), (6188, 1543), (7051, 1761), (7006, 1750), (22793, 5695), (91583, 22892), (28019, 7000), (25766, 6439), (66010, 16500), (85762, 21438), (98464, 24612), (27779, 6941), (92939, 23230), (17577, 4392), (664955, 166234), (392167, 98039), (219530, 54880), (596024, 149001), (852393, 213093), (757725, 189427), (537003, 134247), (569746, 142432), (720321, 180076), (760423, 190100), (9864166, 2466038), (3936351, 984084), (2554139, 638530), (5600487, 1400116), (6148810, 1537198), (4758791, 1189693), (8249433, 2062353), (3571734, 892927), (1840833, 460203), (6806599, 1701644), (58037629, 14509402), (27880791, 6970192), (31921612, 7980396), (41858181, 10464540), (71827981, 17956988), (42356047, 10589005), (39048190, 9762041), (45274424, 11318599), (39599801, 9899945), (97036229, 24259050), (800398176, 200099539), (140720239, 35180054), (278646632, 69661652), (597677495, 149419368), (981777051, 245444257), (975014653, 243753656), (432577103, 108144268), (530968050, 132742006), (879778198, 219944544), (628192898, 157048217), (1399829940, 349957478), (5074896726, 1268724173), (9860267700, 2465066919), (9692888733, 2423222173), (2704381881, 676095466), (5774520969, 1443630233), (2240891591, 560222891), (6811274839, 1702818701), (5961817060, 1490454259), (7826628749, 1956657180), (41136662363, 10284165581), (52565037117, 13141259271), (63607552056, 15901888008), (23188519592, 5797129889), (89748095845, 22437023954), (15650281184, 3912570286), (50090331406, 12522582847), (20967136984, 5241784238), (14344138004, 3586034492), (53772868694, 13443217164), (975871201654, 243967800405), (482703545289, 120675886314), (331273451253, 82818362807), (395076944881, 98769236211), (189815352140, 47453838029), (788906837428, 197226709349), (928843071399, 232210767841), (553488566695, 138372141666), (254134881665, 63533720409), (758622380618, 189655595143), (6488379282292, 1622094820565), (4356794834447, 1089198708602), (9656612303548, 2414153075878), (7644224478447, 1911056119603), (8610531572702, 2152632893167), (2009995664733, 502498916172), (7034946412203, 1758736603042), (8848382740005, 2212095684991), (4383738122351, 1095934530577), (2781408666826, 695352166698), (87286132334981, 21821533083732), (42589487541999, 10647371885489), (54696969378075, 13674242344508), (57765126008076, 14441281502008), (58176286397091, 14544071599265), (75050064429567, 18762516107381), (89192156333243, 22298039083301), (12989438872457, 3247359718104), (41916706897524, 10479176724370), (87531669966937, 21882917491724), (510580878072362, 127645219518079), (786049640068306, 196512410017067), (111801193096217, 27950298274043), (668069621008732, 167017405252172), (571615903728973, 142903975932230), (670800572001129, 167700143000272), (132999948308075, 33249987077007), (521818723804123, 130454680951017), (545190359796199, 136297589949035), (670360049737213, 167590012434292), (3495053667342183, 873763416835534), (3253069295544998, 813267323886235), (8404818041669655, 2101204510417403), (2862987795683907, 715746948920967), (7536249205455639, 1884062301363898), (6126641325199803, 1531660331299938), (5937109965109064, 1484277491277255), (5401717470040138, 1350429367510023), (5398925943459609, 1349731485864894), (5148530753646852, 1287132688411700), (67589630016912814, 16897407504228190), (79506573195211867, 19876643298802952), (43711590897574851, 10927897724393699), (35862471175212753, 8965617793803179), (99369028741191436, 24842257185297846), (77557972579435142, 19389493144858774), (55649795884135111, 13912448971033764), (59000293312803830, 14750073328200946), (14954805986036612, 3738701496509142), (31017683057609138, 7754420764402274),]backslash-newlinefor n, attendu in COUPLES:backslash-newline assert nbpython-underscorezerospython-underscorefactorielle(n) == attendu, f\"Erreur avec n = {n}\"backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorezerospython-underscorefactorielle(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline def nbpython-underscorezerospython-underscorefactorielle(n):backslash-newline resultat = 0backslash-newline puisspython-underscore5 = 5backslash-newline while puisspython-underscore5 <= n:backslash-newline resultat += n // puisspython-underscore5backslash-newline puisspython-underscore5 python-star= 5backslash-newline return resultatbackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(3) == 0backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(11) == 2backslash-newlinebackslash-newlineassert nbpython-underscorezerospython-underscorefactorielle(42) == 9backslash-newlinebackslash-newline A","title":"Nombre de z\u00e9ros de n factoriel ; n grand"},{"location":"4-Tdifficile/fact2_nb_zeros_2/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/fact2_nb_zeros_2/sujet/#solution","text":"{{ py('exo_corr') }}","title":"Solution"},{"location":"4-Tdifficile/fact2_nb_zeros_2/sujet/#complement","text":"Cette m\u00e9thode se g\u00e9n\u00e9ralise pour d\u00e9terminer la valuation \\(p\\) -adique d'un entier \\(n\\) . Si \\(n\\) est un entier naturel, et \\(p\\) un nombre premier, la formule de Legendre donne l'exposant de \\(p\\) dans la d\u00e9composition en facteur premier de \\(n!\\) . \\[v_p(n!) = \\sum_{k=1}^{\\infty} \\lfloor \\frac{n}{p^k} \\rfloor = \\lfloor \\frac{n}{p} \\rfloor + \\lfloor \\frac{n}{p^2} \\rfloor + \\lfloor \\frac{n}{p^3} \\rfloor + \\cdots\\] La somme s'arr\u00eate ; tous les termes sont nuls \u00e0 partir d'un certain rang. \\(\\lfloor \\frac{a}{b} \\rfloor\\) est la partie enti\u00e8re de \\(a\\) divis\u00e9 par \\(b\\) . Avec Python, on peut simplement faire a // b . Cela donne une fonction Python \ud83d\udc0d Script Python def valuation ( n , p ): \"\"\"Renvoie la valuation p-adique de n! - n est un entier naturel - p est un nombre premier \"\"\" resultat = 0 puiss_p = p while puiss_p <= n : resultat += n // puiss_p puiss_p *= p return resultat On peut se servir de cette fonction pour obtenir la d\u00e9composition compl\u00e8te en facteurs premiers de \\(n!\\) , mais aussi de coefficients binomiaux qui se calculent avec des factorielles. Il faudra juste avoir une liste de nombres premiers... C'est toujours tr\u00e8s utile. Z Indice 1 Il n'est pas possible de construire un tableau de tous les r\u00e9sultats. Il faut penser d\u00e9composition en facteurs premiers de \\(n!\\) . Une divisibilit\u00e9 par \\(10\\) signifie la pr\u00e9sence de \\(2\\) et \\(5\\) dans la d\u00e9composition. Le nombre de z\u00e9ros d'un nombre est le minimum de l'exposant de 2 et de celui de 5 dans la d\u00e9composition en facteurs premiers du nombre. Pour \\(n!\\) , le nombre de z\u00e9ros est l'exposant de 5 qui est plus petit que l'exposant de 2. Indice 2 Combien y a-t-il de multiples de 5 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro. Combien y a-t-il de multiples de 25 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro suppl\u00e9mentaire. Combien y a-t-il de multiples de 125 de \\(1\\) \u00e0 \\(n\\) ? Chacun apporte un z\u00e9ro suppl\u00e9mentaire. Quand faut-il arr\u00eater cette liste ? Et comment la g\u00e9n\u00e9rer ? Indice 3 On utilisera une variable puiss_5 qui sera une puissance de 5. La puissance suivante s'obtient avec puiss_5 *= 5 . Il y a n // k multiples de \\(k\\) de \\(1\\) \u00e0 \\(n\\) , par exemple : Il y a 42 // 5 = 8 multiples de 5 de \\(1\\) \u00e0 \\(42\\) : \\(5\\) , \\(10\\) , \\(15\\) , \\(20\\) , \\(25\\) , \\(30\\) , \\(35\\) et \\(40\\) . Il y a 42 // 25 = 1 multiple de 25 de \\(1\\) \u00e0 \\(42\\) : \\(25\\) . Il y a 42 // 125 = 0 multiple de 125 de \\(1\\) \u00e0 \\(42\\) . Il y a \\(8+1+0=9\\) z\u00e9ros \u00e0 la fin de \\(42!\\)","title":"Compl\u00e9ment"},{"location":"4-Tdifficile/nb_chemins_grille_2/exo_REM/","text":"Commentaires \u2693\ufe0e Solution \u2693\ufe0e \ud83d\udc0d Script Python def nb_chemins ( n , m ): numerateur = 1 for i in range ( n + 1 , n + m + 1 ): numerateur *= i denominateur = 1 for i in range ( 1 , m + 1 ): denominateur *= i return numerateur // denominateur Pour calculer un produit, on initialise le produit \u00e0 1, et non \u00e0 0. Une somme vide est \u00e9gale \u00e0 0. Un produit vide est \u00e9gal \u00e0 1. Pour la boucle, on peut \u00e9crire resultat *= facteur \u00e0 la place de resultat = resultat * facteur . De la m\u00eame mani\u00e8re qu'on peut \u00e9crire resultat += terme \u00e0 la place de resultat = resultat + terme Il existe aussi les raccourcis -= , pour la soustraction //= , pour la division enti\u00e8re %= , pour le modulo /= , pour la division continu\u00e9e **= , pour la puissance <<= pour le d\u00e9calage de bits \u00e0 gauche >>= pour le d\u00e9calage de bits \u00e0 droite Formule \u00e0 justifier ; maths \u2693\ufe0e Justifions la formule : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] On rappelle que pour compter le nombre de fa\u00e7ons de choisir \\(k\\) \u00e9l\u00e9ments parmi \\(n\\) , on utilise le coefficient binomial $\\binom{k}{n}`. Un chemin allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) peut \u00eatre d\u00e9crit par une suite de E et de N ; E pour aller \u00e0 l'Est, N pour aller au Nord. Il doit y avoir \\(n\\) fois la pr\u00e9sence de E , et \\(m\\) fois la pr\u00e9sence de N . Il y a autant de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) que de mots de \\(n+m\\) lettres compos\u00e9s de \\(n\\) E et \\(m\\) N . Pour compter ces mots, il suffit de compter le nombre de fa\u00e7ons de choisir \\(n\\) positions parmi les \\(n+m\\) pour placer les E . On remarquera que \\(\\binom{n}{n+m} = \\binom{m}{n+m}\\) , et choisir les N impose les E tout autant. Ce qui justifie la formule donn\u00e9e.","title":"Commentaires"},{"location":"4-Tdifficile/nb_chemins_grille_2/exo_REM/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/nb_chemins_grille_2/exo_REM/#solution","text":"\ud83d\udc0d Script Python def nb_chemins ( n , m ): numerateur = 1 for i in range ( n + 1 , n + m + 1 ): numerateur *= i denominateur = 1 for i in range ( 1 , m + 1 ): denominateur *= i return numerateur // denominateur Pour calculer un produit, on initialise le produit \u00e0 1, et non \u00e0 0. Une somme vide est \u00e9gale \u00e0 0. Un produit vide est \u00e9gal \u00e0 1. Pour la boucle, on peut \u00e9crire resultat *= facteur \u00e0 la place de resultat = resultat * facteur . De la m\u00eame mani\u00e8re qu'on peut \u00e9crire resultat += terme \u00e0 la place de resultat = resultat + terme Il existe aussi les raccourcis -= , pour la soustraction //= , pour la division enti\u00e8re %= , pour le modulo /= , pour la division continu\u00e9e **= , pour la puissance <<= pour le d\u00e9calage de bits \u00e0 gauche >>= pour le d\u00e9calage de bits \u00e0 droite","title":"Solution"},{"location":"4-Tdifficile/nb_chemins_grille_2/exo_REM/#formule-a-justifier-maths","text":"Justifions la formule : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] On rappelle que pour compter le nombre de fa\u00e7ons de choisir \\(k\\) \u00e9l\u00e9ments parmi \\(n\\) , on utilise le coefficient binomial $\\binom{k}{n}`. Un chemin allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) peut \u00eatre d\u00e9crit par une suite de E et de N ; E pour aller \u00e0 l'Est, N pour aller au Nord. Il doit y avoir \\(n\\) fois la pr\u00e9sence de E , et \\(m\\) fois la pr\u00e9sence de N . Il y a autant de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) que de mots de \\(n+m\\) lettres compos\u00e9s de \\(n\\) E et \\(m\\) N . Pour compter ces mots, il suffit de compter le nombre de fa\u00e7ons de choisir \\(n\\) positions parmi les \\(n+m\\) pour placer les E . On remarquera que \\(\\binom{n}{n+m} = \\binom{m}{n+m}\\) , et choisir les N impose les E tout autant. Ce qui justifie la formule donn\u00e9e.","title":"Formule \u00e0 justifier ; maths"},{"location":"4-Tdifficile/nb_chemins_grille_2/sujet/","tags":["maths+","boucle","a_trou"],"text":"\u00c9num\u00e9ration des chemins dans une grande grille \u2693\ufe0e Dans une grande grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Dans cet exercice, on pourra avoir \\(0\\leqslant n \\leqslant 1000\\) et \\(0\\leqslant m \\leqslant 1000\\) . Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) Il y en a 35. \u00c9crire une fonction telle que nb_chemins(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on admettra que nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Utilisation pour nb_chemins(4, 3) \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73}\\] \\[\\binom{4}{4+3} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = 35\\] Utilisation pour nb_chemins(n, m) \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m) = 1\u00d72\u00d73\u00d7\\cdots\u00d7n\u00d7(n+1)\u00d7\\cdots\u00d7(n+m)\\) \\[\\binom{n}{n+m} = \\dfrac{1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m)}{1\u00d72\u00d73\u00d7\\cdots\u00d7n~\u00d7~1\u00d72\u00d73\\cdots\u00d7m}\\] \\[\\binom{n}{n+m} = \\dfrac{\\xcancel{(1\u00d72\u00d73\u00d7\\cdots\u00d7n)}~\u00d7~(n+1)\u00d7\\cdots\u00d7(n+m)}{\\xcancel{1\u00d72\u00d73\u00d7\\cdots\u00d7n}~\u00d7~1\u00d72\u00d73\u00d7\\cdots\u00d7m}\\] En conclusion On d\u00e9duit la formule simple, \u00e0 utiliser ici : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\dfrac{(n+1)\u00d7(n+2)\u00d7(n+3)\u00d7\\cdots\u00d7(n+m)}{1\u00d72\u00d73\u00d7\\cdots\u00d7m}\\) Pour calculer nb_chemins(n, m) , on fera une boucle pour calculer le num\u00e9rateur et une autre boucle pour calculer le d\u00e9nominateur on terminera par la division enti\u00e8re. On compl\u00e8tera le code : \ud83d\udc0d Script Python def nb_chemins ( n , m ): numerateur = ... for i in range ( ... ): numerateur = ... denominateur = ... for i in range ( ... ): denominateur = ... return numerateur ... denominateur Exemples \ud83d\udc0d Console Python >>> nb_chemins ( 3 , 3 ) 20 >>> nb_chemins ( 4 , 2 ) 15 >>> nb_chemins ( 4 , 3 ) 35 Contraintes : Ici, \\(0\\leqslant n \\leqslant 1000\\) et \\(0\\leqslant m \\leqslant 1000\\) . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef FACT(n):backslash-newline ans = 1backslash-newline for i in range(1, n + 1):backslash-newline ans python-star= ibackslash-newline return ansbackslash-newlinebackslash-newlinefor (n, m) in [(13, 17), (13, 18), (14, 17), (14, 18), (200, 221)]:backslash-newline attendu = FACT(n + m) // FACT(n) // FACT(m)backslash-newline assert nbpython-underscorechemins(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}\"backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorechemins(n, m):backslash-newline numerateur = ...backslash-newline for i in range(...):backslash-newline numerateur = ...backslash-newline denominateur = ...backslash-newline for i in range(...):backslash-newline denominateur = ...backslash-newline return numerateur ... denominateurbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline def nbpython-underscorechemins(n, m):backslash-newline numerateur = 1backslash-newline for i in range(n + 1, n + m + 1):backslash-newline numerateur python-star= ibackslash-newline denominateur = 1backslash-newline for i in range(1, m + 1):backslash-newline denominateur python-star= ibackslash-newline return numerateur // denominateurbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e Solution \u2693\ufe0e {{ py('exo_corr') }} Pour calculer un produit, on initialise le produit \u00e0 1, et non \u00e0 0. Une somme vide est \u00e9gale \u00e0 0. Un produit vide est \u00e9gal \u00e0 1. Pour la boucle, on peut \u00e9crire resultat *= facteur \u00e0 la place de resultat = resultat * facteur . De la m\u00eame mani\u00e8re qu'on peut \u00e9crire resultat += terme \u00e0 la place de resultat = resultat + terme Il existe aussi les raccourcis -= , pour la soustraction //= , pour la division enti\u00e8re %= , pour le modulo /= , pour la division continu\u00e9e **= , pour la puissance <<= pour le d\u00e9calage de bits \u00e0 gauche >>= pour le d\u00e9calage de bits \u00e0 droite Formule \u00e0 justifier ; maths \u2693\ufe0e Justifions la formule : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] On rappelle que pour compter le nombre de fa\u00e7ons de choisir \\(k\\) \u00e9l\u00e9ments parmi \\(n\\) , on utilise le coefficient binomial $\\binom{k}{n}`. Un chemin allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) peut \u00eatre d\u00e9crit par une suite de E et de N ; E pour aller \u00e0 l'Est, N pour aller au Nord. Il doit y avoir \\(n\\) fois la pr\u00e9sence de E , et \\(m\\) fois la pr\u00e9sence de N . Il y a autant de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) que de mots de \\(n+m\\) lettres compos\u00e9s de \\(n\\) E et \\(m\\) N . Pour compter ces mots, il suffit de compter le nombre de fa\u00e7ons de choisir \\(n\\) positions parmi les \\(n+m\\) pour placer les E . On remarquera que \\(\\binom{n}{n+m} = \\binom{m}{n+m}\\) , et choisir les N impose les E tout autant. Ce qui justifie la formule donn\u00e9e. Z","title":"Nombres de chemins dans une grille (2)"},{"location":"4-Tdifficile/nb_chemins_grille_2/sujet/#enumeration-des-chemins-dans-une-grande-grille","text":"Dans une grande grille de taille \\(n\u00d7m\\) , on souhaite compter tous les chemins allant du coin inf\u00e9rieur gauche (au Sud-Ouest) vers le coin sup\u00e9rieur droit (au Nord-Est). Dans cet exercice, on pourra avoir \\(0\\leqslant n \\leqslant 1000\\) et \\(0\\leqslant m \\leqslant 1000\\) . Les seuls mouvements autoris\u00e9s sont : \u2191 Aller au Nord d'une unit\u00e9. \u2192 Aller \u00e0 l'Est d'une unit\u00e9. Les chemins pour aller de \\((0, 0)\\) \u00e0 \\((4, 3)\\) Il y en a 35. \u00c9crire une fonction telle que nb_chemins(n, m) renvoie le nombre de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) . Pour ce faire, on admettra que nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] O\u00f9 : \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n-1)\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(m-1)\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m-1)\u00d7(n+m)\\) Utilisation pour nb_chemins(4, 3) \\(4! = 1\u00d72\u00d73\u00d74\\) \\(3! = 1\u00d72\u00d73\\) \\((4+3)! = 1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77\\) \\[\\binom{4}{4+3} = \\dfrac{1\u00d72\u00d73\u00d74\u00d75\u00d76\u00d77}{1\u00d72\u00d73\u00d74~\u00d7~1\u00d72\u00d73}\\] \\[\\binom{4}{4+3} = \\dfrac{5\u00d76\u00d77}{1\u00d72\u00d73} = 35\\] Utilisation pour nb_chemins(n, m) \\(n! = 1\u00d72\u00d73\u00d7\\cdots\u00d7n\\) \\(m! = 1\u00d72\u00d73\u00d7\\cdots\u00d7m\\) \\((n+m)! = 1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m) = 1\u00d72\u00d73\u00d7\\cdots\u00d7n\u00d7(n+1)\u00d7\\cdots\u00d7(n+m)\\) \\[\\binom{n}{n+m} = \\dfrac{1\u00d72\u00d73\u00d7\\cdots\u00d7(n+m)}{1\u00d72\u00d73\u00d7\\cdots\u00d7n~\u00d7~1\u00d72\u00d73\\cdots\u00d7m}\\] \\[\\binom{n}{n+m} = \\dfrac{\\xcancel{(1\u00d72\u00d73\u00d7\\cdots\u00d7n)}~\u00d7~(n+1)\u00d7\\cdots\u00d7(n+m)}{\\xcancel{1\u00d72\u00d73\u00d7\\cdots\u00d7n}~\u00d7~1\u00d72\u00d73\u00d7\\cdots\u00d7m}\\] En conclusion On d\u00e9duit la formule simple, \u00e0 utiliser ici : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\dfrac{(n+1)\u00d7(n+2)\u00d7(n+3)\u00d7\\cdots\u00d7(n+m)}{1\u00d72\u00d73\u00d7\\cdots\u00d7m}\\) Pour calculer nb_chemins(n, m) , on fera une boucle pour calculer le num\u00e9rateur et une autre boucle pour calculer le d\u00e9nominateur on terminera par la division enti\u00e8re. On compl\u00e8tera le code : \ud83d\udc0d Script Python def nb_chemins ( n , m ): numerateur = ... for i in range ( ... ): numerateur = ... denominateur = ... for i in range ( ... ): denominateur = ... return numerateur ... denominateur Exemples \ud83d\udc0d Console Python >>> nb_chemins ( 3 , 3 ) 20 >>> nb_chemins ( 4 , 2 ) 15 >>> nb_chemins ( 4 , 3 ) 35 Contraintes : Ici, \\(0\\leqslant n \\leqslant 1000\\) et \\(0\\leqslant m \\leqslant 1000\\) . Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlinedef FACT(n):backslash-newline ans = 1backslash-newline for i in range(1, n + 1):backslash-newline ans python-star= ibackslash-newline return ansbackslash-newlinebackslash-newlinefor (n, m) in [(13, 17), (13, 18), (14, 17), (14, 18), (200, 221)]:backslash-newline attendu = FACT(n + m) // FACT(n) // FACT(m)backslash-newline assert nbpython-underscorechemins(n, m) == attendu, f\"Erreur avec n = {n} et m = {m}\"backslash-newlinebackslash-newline Valider 5/5 def nbpython-underscorechemins(n, m):backslash-newline numerateur = ...backslash-newline for i in range(...):backslash-newline numerateur = ...backslash-newline denominateur = ...backslash-newline for i in range(...):backslash-newline denominateur = ...backslash-newline return numerateur ... denominateurbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline def nbpython-underscorechemins(n, m):backslash-newline numerateur = 1backslash-newline for i in range(n + 1, n + m + 1):backslash-newline numerateur python-star= ibackslash-newline denominateur = 1backslash-newline for i in range(1, m + 1):backslash-newline denominateur python-star= ibackslash-newline return numerateur // denominateurbackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscorechemins(3, 3) == 20backslash-newlineassert nbpython-underscorechemins(4, 2) == 15backslash-newlineassert nbpython-underscorechemins(4, 3) == 35backslash-newlinebackslash-newline A","title":"\u00c9num\u00e9ration des chemins dans une grande grille"},{"location":"4-Tdifficile/nb_chemins_grille_2/sujet/#commentaires","text":"","title":"Commentaires"},{"location":"4-Tdifficile/nb_chemins_grille_2/sujet/#solution","text":"{{ py('exo_corr') }} Pour calculer un produit, on initialise le produit \u00e0 1, et non \u00e0 0. Une somme vide est \u00e9gale \u00e0 0. Un produit vide est \u00e9gal \u00e0 1. Pour la boucle, on peut \u00e9crire resultat *= facteur \u00e0 la place de resultat = resultat * facteur . De la m\u00eame mani\u00e8re qu'on peut \u00e9crire resultat += terme \u00e0 la place de resultat = resultat + terme Il existe aussi les raccourcis -= , pour la soustraction //= , pour la division enti\u00e8re %= , pour le modulo /= , pour la division continu\u00e9e **= , pour la puissance <<= pour le d\u00e9calage de bits \u00e0 gauche >>= pour le d\u00e9calage de bits \u00e0 droite","title":"Solution"},{"location":"4-Tdifficile/nb_chemins_grille_2/sujet/#formule-a-justifier-maths","text":"Justifions la formule : nb_chemins(n, m) est \u00e9gal \u00e0 \\(\\binom{n}{n+m}\\) . \\[\\binom{n}{n+m} = \\dfrac{(n+m)!}{n!m!}\\] On rappelle que pour compter le nombre de fa\u00e7ons de choisir \\(k\\) \u00e9l\u00e9ments parmi \\(n\\) , on utilise le coefficient binomial $\\binom{k}{n}`. Un chemin allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) peut \u00eatre d\u00e9crit par une suite de E et de N ; E pour aller \u00e0 l'Est, N pour aller au Nord. Il doit y avoir \\(n\\) fois la pr\u00e9sence de E , et \\(m\\) fois la pr\u00e9sence de N . Il y a autant de chemins allant de \\((0, 0)\\) jusqu'\u00e0 \\((n, m)\\) que de mots de \\(n+m\\) lettres compos\u00e9s de \\(n\\) E et \\(m\\) N . Pour compter ces mots, il suffit de compter le nombre de fa\u00e7ons de choisir \\(n\\) positions parmi les \\(n+m\\) pour placer les E . On remarquera que \\(\\binom{n}{n+m} = \\binom{m}{n+m}\\) , et choisir les N impose les E tout autant. Ce qui justifie la formule donn\u00e9e. Z","title":"Formule \u00e0 justifier ; maths"},{"location":"4-Tdifficile/nb_partitions/sujet/","tags":["maths+","r\u00e9cursivit\u00e9","m\u00e9mo"],"text":"Nombre de partitions d'un entier \u2693\ufe0e On dira qu'une somme doit comporter au moins un terme, et que l'ordre ne compte pas, ainsi Il y a \\(3\\) fa\u00e7ons d'\u00e9crire \\(3\\) comme une somme. \\(3 = 1 + 2\\) \\(3 = 1 + 1 + 1\\) \\(3 = 3\\) Il y a \\(7\\) fa\u00e7ons d'\u00e9crire \\(5\\) comme une somme. \\(5 = 5\\) \\(5 = 4 + 1\\) \\(5 = 3 + 2\\) \\(5 = 3 + 1 + 1\\) \\(5 = 2 + 2 + 1\\) \\(5 = 2 + 1 + 1 + 1\\) \\(5 = 1 + 1 + 1 + 1 + 1\\) \u00c9crire une fonction nb_sommes qui prend un param\u00e8tre entier n strictement positif et qui renvoie le nombre de fa\u00e7ons d'\u00e9crire n comme une somme, sans compter l'ordre. Exemples \ud83d\udc0d Console Python >>> nb_sommes ( 3 ) 3 >>> nb_sommes ( 5 ) 7 Indice 1 Toujours commencer par d\u00e9nombrer \u00e0 la main. Bien ranger les cas. Ajouter d\u00e8s que possible des tests, avant d'\u00e9crire la fonction. Indice 2 Il est recommand\u00e9 de construire une fonction auxiliaire telle que nb_k_sommes(n, k) renvoie le nombre de fa\u00e7ons d'\u00e9crire n comme une somme de k termes. Ainsi, nb_sommes(n) sera la somme pour k allant de 1 \u00e0 n de nb_k_sommes(n, k) . On remarquera que k > n ne donne aucune somme k == 1 donne une unique somme On ajoutera des tests \u00e0 cette fonction ! Indice 3 Pour d\u00e9nombrer nb_k_sommes(n, k) , on fera deux cas : Les sommes dont le plus petit terme est 1 . Combien de termes restants, et pour quelle somme ? Un calcul r\u00e9cursif est alors possible. Les sommes dont tous les termes sont sup\u00e9rieurs \u00e0 1 . On pourra enlever 1 \u00e0 chaque terme, ce qui donne une somme \u00e9gale \u00e0 ??? en ??? parties. Et r\u00e9ciproquement. Ce qui permet de d\u00e9nombrer ce cas de mani\u00e8re r\u00e9cursive \u00e9galement. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(1) == 1backslash-newlineassert nbpython-underscoresommes(2) == 2backslash-newlineassert nbpython-underscoresommes(4) == 5backslash-newlineassert nbpython-underscoresommes(10) == 42backslash-newlineassert nbpython-underscoresommes(42) == 53174backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscoresommes(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newline def nbpython-underscoresommes(n):backslash-newline def nbpython-underscorekpython-underscoresommes(n, k):backslash-newline if n < k:backslash-newline return 0backslash-newline elif k == 1:backslash-newline return 1backslash-newline else:backslash-newline return nbpython-underscorekpython-underscoresommes(n - 1, k - 1) + nbpython-underscorekpython-underscoresommes(n - k, k)backslash-newline backslash-newline return sum(nbpython-underscorekpython-underscoresommes(n, k) for k in range(1, 1 + n))backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(1) == 1backslash-newlineassert nbpython-underscoresommes(2) == 2backslash-newlineassert nbpython-underscoresommes(4) == 5backslash-newlineassert nbpython-underscoresommes(10) == 42backslash-newlineassert nbpython-underscoresommes(42) == 53174backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Nombre de partitions"},{"location":"4-Tdifficile/nb_partitions/sujet/#nombre-de-partitions-dun-entier","text":"On dira qu'une somme doit comporter au moins un terme, et que l'ordre ne compte pas, ainsi Il y a \\(3\\) fa\u00e7ons d'\u00e9crire \\(3\\) comme une somme. \\(3 = 1 + 2\\) \\(3 = 1 + 1 + 1\\) \\(3 = 3\\) Il y a \\(7\\) fa\u00e7ons d'\u00e9crire \\(5\\) comme une somme. \\(5 = 5\\) \\(5 = 4 + 1\\) \\(5 = 3 + 2\\) \\(5 = 3 + 1 + 1\\) \\(5 = 2 + 2 + 1\\) \\(5 = 2 + 1 + 1 + 1\\) \\(5 = 1 + 1 + 1 + 1 + 1\\) \u00c9crire une fonction nb_sommes qui prend un param\u00e8tre entier n strictement positif et qui renvoie le nombre de fa\u00e7ons d'\u00e9crire n comme une somme, sans compter l'ordre. Exemples \ud83d\udc0d Console Python >>> nb_sommes ( 3 ) 3 >>> nb_sommes ( 5 ) 7 Indice 1 Toujours commencer par d\u00e9nombrer \u00e0 la main. Bien ranger les cas. Ajouter d\u00e8s que possible des tests, avant d'\u00e9crire la fonction. Indice 2 Il est recommand\u00e9 de construire une fonction auxiliaire telle que nb_k_sommes(n, k) renvoie le nombre de fa\u00e7ons d'\u00e9crire n comme une somme de k termes. Ainsi, nb_sommes(n) sera la somme pour k allant de 1 \u00e0 n de nb_k_sommes(n, k) . On remarquera que k > n ne donne aucune somme k == 1 donne une unique somme On ajoutera des tests \u00e0 cette fonction ! Indice 3 Pour d\u00e9nombrer nb_k_sommes(n, k) , on fera deux cas : Les sommes dont le plus petit terme est 1 . Combien de termes restants, et pour quelle somme ? Un calcul r\u00e9cursif est alors possible. Les sommes dont tous les termes sont sup\u00e9rieurs \u00e0 1 . On pourra enlever 1 \u00e0 chaque terme, ce qui donne une somme \u00e9gale \u00e0 ??? en ??? parties. Et r\u00e9ciproquement. Ce qui permet de d\u00e9nombrer ce cas de mani\u00e8re r\u00e9cursive \u00e9galement. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(1) == 1backslash-newlineassert nbpython-underscoresommes(2) == 2backslash-newlineassert nbpython-underscoresommes(4) == 5backslash-newlineassert nbpython-underscoresommes(10) == 42backslash-newlineassert nbpython-underscoresommes(42) == 53174backslash-newlinebackslash-newlinebackslash-newline Valider 5/5 def nbpython-underscoresommes(n):backslash-newline ...backslash-newlinebackslash-newlinebackslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newline def nbpython-underscoresommes(n):backslash-newline def nbpython-underscorekpython-underscoresommes(n, k):backslash-newline if n < k:backslash-newline return 0backslash-newline elif k == 1:backslash-newline return 1backslash-newline else:backslash-newline return nbpython-underscorekpython-underscoresommes(n - 1, k - 1) + nbpython-underscorekpython-underscoresommes(n - k, k)backslash-newline backslash-newline return sum(nbpython-underscorekpython-underscoresommes(n, k) for k in range(1, 1 + n))backslash-newlinebackslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(3) == 3backslash-newlineassert nbpython-underscoresommes(5) == 7backslash-newlinebackslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineassert nbpython-underscoresommes(1) == 1backslash-newlineassert nbpython-underscoresommes(2) == 2backslash-newlineassert nbpython-underscoresommes(4) == 5backslash-newlineassert nbpython-underscoresommes(10) == 42backslash-newlineassert nbpython-underscoresommes(42) == 53174backslash-newlinebackslash-newlinebackslash-newline A Z","title":"Nombre de partitions d'un entier"},{"location":"4-Tdifficile/nb_serpent/exo_REM/","text":"Commentaires \u2693\ufe0e \ud83d\udc0d Script Python serpent = [ 0 , 10 ] serpent_croissant = [ 0 ] + [ 1 ] * 9 serpent_decroissant = [ 0 ] + [ 1 ] * 9 On peut remplacer les lignes 6 \u00e0 10 par des listes en compr\u00e9hension. \ud83d\udc0d Script Python new_croissant = [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )] new_decroissant = [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )] \u00c0 la suite de quoi, il est possible de se passer des tableaux new_* de mani\u00e8res explicites. Ils seront toutefois toujours cr\u00e9\u00e9s par Python !!! Le code de la boucle devient alors \ud83d\udc0d Script Python for _ in range ( 2 , 100 ): serpent_croissant , serpent_decroissant = ( [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )], [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )], ) serpent . append ( sum ( serpent_croissant ) + sum ( serpent_decroissant )) On a ici un style plut\u00f4t fonctionnel tr\u00e8s dense. Pour aller plus loin \u2693\ufe0e Ici, on calcule les termes de serpent de proche en proche. En utilisant du calcul matriciel, ou mieux polynomial, on pourra calculer des termes \u00e9loign\u00e9s de serpent . Il faudra maitriser l'exponentiation rapide et le calcul modulaire.","title":"Commentaires"},{"location":"4-Tdifficile/nb_serpent/exo_REM/#commentaires","text":"\ud83d\udc0d Script Python serpent = [ 0 , 10 ] serpent_croissant = [ 0 ] + [ 1 ] * 9 serpent_decroissant = [ 0 ] + [ 1 ] * 9 On peut remplacer les lignes 6 \u00e0 10 par des listes en compr\u00e9hension. \ud83d\udc0d Script Python new_croissant = [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )] new_decroissant = [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )] \u00c0 la suite de quoi, il est possible de se passer des tableaux new_* de mani\u00e8res explicites. Ils seront toutefois toujours cr\u00e9\u00e9s par Python !!! Le code de la boucle devient alors \ud83d\udc0d Script Python for _ in range ( 2 , 100 ): serpent_croissant , serpent_decroissant = ( [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )], [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )], ) serpent . append ( sum ( serpent_croissant ) + sum ( serpent_decroissant )) On a ici un style plut\u00f4t fonctionnel tr\u00e8s dense.","title":"Commentaires"},{"location":"4-Tdifficile/nb_serpent/exo_REM/#pour-aller-plus-loin","text":"Ici, on calcule les termes de serpent de proche en proche. En utilisant du calcul matriciel, ou mieux polynomial, on pourra calculer des termes \u00e9loign\u00e9s de serpent . Il faudra maitriser l'exponentiation rapide et le calcul modulaire.","title":"Pour aller plus loin"},{"location":"4-Tdifficile/nb_serpent/sujet/","tags":["prog.dynamique"],"text":"Nombres qui serpentent \u2693\ufe0e On dira d'un entier qu'il serpente si ses chiffres alternent entre croissants et d\u00e9croissants quand on les lit. Par exemple : \\(8\\) , \\(90\\) , \\(243\\,516\\) et \\(31\\,524\\) sont des nombres serpent ; \\(44\\) , \\(123\\) et \\(4235\\) ne sont pas des nombres serpent. Objectif : Compter les nombres serpent qui ont \\(n\\) chiffres, pour \\(n\\) inf\u00e9rieur \u00e0 100. Les z\u00e9ros de t\u00eate sont interdits (sauf pour z\u00e9ro lui-m\u00eame) pour les nombres, ainsi \\(08\\) ne compte pas comme un nombre serpent. Calculer un tableau d'entiers serpent de longueur au moins 100 tel que serpent[n] donne l'effectif des nombres serpent \u00e0 n chiffres. Exemples Les nombres serpent \u00e0 0 chiffre n'existent pas. Il n'y en a aucun ; 0 . Les nombres serpent \u00e0 1 chiffre sont \\(0\\) , \\(1\\) , \\(2\\) , \\(\\cdots\\) , \\(8\\) , et \\(9\\) . Il y en a 10 . Parmi les nombres serpent \u00e0 2 chiffres, il y a \\(10\\) , \\(12\\) , \\(13\\) , ..., \\(20\\) , \\(21\\) , \\(23\\) , ..., \\(98\\) . Il y en a 81 : de \\(10\\) inclus \u00e0 \\(100\\) exclu, il y en a 90, auquel on enl\u00e8ve les 9 nombres \\(11\\) , \\(22\\) , ..., \\(99\\) qui ne sont pas serpent. Parmi les nombres serpent \u00e0 3 chiffres, il y a \\(101\\) , \\(121\\) , \\(120\\) , ..., \\(205\\) , \\(218\\) , \\(230\\) , ..., \\(989\\) . Il y en a 525 . \ud83d\udc0d Console Python >>> serpent [ 0 ] 0 >>> serpent [ 1 ] 10 >>> serpent [ 2 ] 81 >>> serpent [ 3 ] 525 >>> len ( serpent ) >= 100 True Indice 1 Si on sait que : Il y a \\(A\\) nombres serpent de taille 20 qui finissent par 0 en d\u00e9croissant . Il y a \\(B\\) nombres serpent de taille 20 qui finissent par 1 en d\u00e9croissant . Il y a \\(C\\) nombres serpent de taille 20 qui finissent par 2 en d\u00e9croissant . Il y a \\(D\\) nombres serpent de taille 20 qui finissent par 3 en d\u00e9croissant . Il y a \\(a\\) nombres serpent de taille 20 qui finissent par 0 en croissant. Il y a \\(b\\) nombres serpent de taille 20 qui finissent par 1 en croissant. Il y a \\(c\\) nombres serpent de taille 20 qui finissent par 2 en croissant. Il y a \\(d\\) nombres serpent de taille 20 qui finissent par 3 en croissant. Pouvez-vous d\u00e9duire la quantit\u00e9 de nombres serpent \u00e0 21 chiffres qui finissent par 3 en croissant ? Solution Il s'agit de \\(A+B+C+D\\) . En effet, s'il finit par 3 en croissant, c'est qu'avant, c'\u00e9tait 0 , 1 , 2 ou 3 , qu'il \u00e9tait de taille 20 et qu'il finissait en d\u00e9croissant . Indice 2 G\u00e9n\u00e9raliser une formule qui donne : l'effectif des nombres serpent de taille \\(n+1\\) qui finissent par i en d\u00e9croissant ; l'effectif des nombres serpent de taille \\(n+1\\) qui finissent par i en croissant. Tout cela en fonction des effectifs pour ceux de taille \\(n\\) . Indice 3 On utilisera deux tableaux : serpent_croissant de longueur 10, qui indique pour chaque chiffre i de 0 \u00e0 9, combien de nombres serpent \u00e0 \\(n\\) chiffres se finissent par i en croissant . serpent_decroissant de longueur 10, qui indique pour chaque chiffre i de 0 \u00e0 9, combien de nombres serpent \u00e0 \\(n\\) chiffres se finissent par i en decroissant . \u00c9crire les instructions qui permettent : de construire deux nouveaux tableaux serpent_croissant_suivant et serpent_decroissant_suivant qui contiennent les effectifs suivants en fonction des pr\u00e9c\u00e9dents. de remplacer des deux anciens tableaux par les nouveaux. Indice 4 \u00c9crire l'instruction simple qui calcule et stocke la bonne valeur de serpent[n] en fonction de serpent_croissant et serpent_decroissant . Indice 5 Initialiser correctement toutes vos variables et mettre en place la boucle qui fait progresser votre probl\u00e8me ; on parle de programmation dynamique. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert serpent[0] == 0backslash-newlineassert serpent[1] == 10backslash-newlineassert serpent[2] == 81backslash-newlineassert serpent[3] == 525backslash-newlineassert len(serpent) >= 100backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineSERPENT = [0, 10, 81, 525, 3105, 18939, 114381, 693129, 4195557, 25405586, 153820395, 931359050, 5639156409, 34143908573, 206733865761, 1251728824798, 7578945799704, 45888871327435, 277847147039527, 1682304127857000, 10185986079451152, 61673933253012813, 373422269794761171, 2260990733622821388, 13689807788336374413, 82888812632681299575, 501873756436963255725, 3038736584593404112888, 18398889984004648394684, 111401282480312690455535, 674510568248786542723384, 4084014982140900066996999, 24727823639079446292398973, 149721601071325722314771768, 906531773865227322540527599, 5488852985453577921599786404, 33233812608096915187160862646, 201223516716003090938495558273, 1218364686502763138912251531858, 7376933539095247157524690209596, 44665730255556705813455277892969, 270441294975640547699726057576357, 1637463299259559727190050998356877, 9914484608068134973197170061461591, 60030050803623279460905640700537146, 363468918651916171818101177606787775, 2200725354342352358032848391711429287, 13324914006975819086503546268399064826, 80679460043917672551257824285696701631, 488496606399894533135228090580518726849, 2957740846732444497653596441045121744779, 17908478384122192100208036703515396114945, 108431946763990227509406490644619239949670, 656531885447794265344437789229847771602593, 3975157962881656804262109523464275982054206, 24068718032001765864399208734778590812059100, 145730859783006115692556683131127947572716351, 882368702182510621630923925514359365784813975, 5342550834809792396806303497681900898790602948, 32347984863840919439702872508060799643996329921, 195860022132767463457194622209195721131511619393, 1185889891791338408154534460189644031233260498090, 7180305710879381718473109708289839840279416225259, 43475191464705279658821205861906473192979193394551, 263232841190727052129577046753774486800584662952576, 1593817677320544472069315699698021405961289198127352, 9650219847374200686866980990825185077113651584259915, 58429985077851243131664519519650782811471472008138262, 353780868228289794214717741134865565936022487352042972, 2142066313342370732999494929764219945531265582381574084, 12969746254891643527206138735713153473581856857600095022, 78528996450069182818170035206950924986262776615228842359, 475476016435488792922724897174988743962786201248439181821, 2878904002664891282213725487897616787658753354127999437145, 17431138417229580981375607929954799920484191208458836849334, 105541756946171068442094408895636846737397539224743995138242, 639032413871166799425569675259991298503891964738270377571646, 3869202463497791194390022403538813795184824191022263105120261, 23427180497538227918384894216032536344822982120913486859005897, 141846489358451945872383596558786903972944914449980284295419669, 858849682975367577620868729238136646340508021279438150851189203, 5200148282012719554761322719583518251776093190150646249093143114, 31485768337525729063232789086930259474485679688747287900236134643, 190639488345634999172037991756500352751157724547714851328253128848, 1154280693648192732866441010454314021643048294494184927145989749181, 6988918881870570231769912232187671511248169744379692168541703509970, 42316385785669385595814350388619174876388240296223393673888607531882, 256216524505193716144733781060865175999482846906506651739660845744675, 1551335403784699437467403137673555159940026653854455786424502055338943, 9392998908573720332591434332116379298964835183480715231431284456457957, 56872568163674679661793660628819558901413442844685202596077017341738809, 344351047095241664581365027406377518948639259453576986455463834228076289, 2084970794607558707929544265766774574113298602455891036247922071247187506, 12624045290514652253974190059423751220374380450784779710821698749343369568, 76435852199532490537114357525478173578997382169325263461986888368804125371, 462802482644657363293397846264195190536976947251737947227949204965780224431, 2802168508345203224585165008456703166541527129222571530462213246984687687723, 16966521666631831399368304014981269907585511181598421802474676023379660074148, 102728603439442098192781482549970023263233791039643568211308707933725742061091, 621999380425342872846895049949523920352287482295049627234230430671848280308249]backslash-newlinebackslash-newlinefor n, attendu in enumerate(SERPENT):backslash-newline assert serpent[n] == attendu, f\"Erreur pour n = {n}\"backslash-newlinebackslash-newline Valider 5/5 serpent = [0, 10]backslash-newlineserpentpython-underscorecroissant = [0] + [1] python-star 9backslash-newlineserpentpython-underscoredecroissant = [0] + [1] python-star 9backslash-newlinebackslash-newlinefor python-underscore in range(2, 100):backslash-newline newpython-underscorecroissant = [0] python-star 10backslash-newline newpython-underscoredecroissant = [0] python-star 10backslash-newline for i in range(10):backslash-newline newpython-underscorecroissant[i] = sum(serpentpython-underscoredecroissant[j] for j in range(0, i))backslash-newline newpython-underscoredecroissant[i] = sum(serpentpython-underscorecroissant[j] for j in range(i+1, 10))backslash-newline serpentpython-underscorecroissant = newpython-underscorecroissantbackslash-newline serpentpython-underscoredecroissant = newpython-underscoredecroissantbackslash-newline serpent.append(sum(serpentpython-underscorecroissant) + sum(serpentpython-underscoredecroissant))backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert serpent[0] == 0backslash-newlineassert serpent[1] == 10backslash-newlineassert serpent[2] == 81backslash-newlineassert serpent[3] == 525backslash-newlineassert len(serpent) >= 100backslash-newlinebackslash-newline A Commentaires \u2693\ufe0e {{ py('exo_corr') }} On peut remplacer les lignes 6 \u00e0 10 par des listes en compr\u00e9hension. \ud83d\udc0d Script Python new_croissant = [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )] new_decroissant = [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )] \u00c0 la suite de quoi, il est possible de se passer des tableaux new_* de mani\u00e8res explicites. Ils seront toutefois toujours cr\u00e9\u00e9s par Python !!! Le code de la boucle devient alors \ud83d\udc0d Script Python for _ in range ( 2 , 100 ): serpent_croissant , serpent_decroissant = ( [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )], [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )], ) serpent . append ( sum ( serpent_croissant ) + sum ( serpent_decroissant )) On a ici un style plut\u00f4t fonctionnel tr\u00e8s dense. Pour aller plus loin \u2693\ufe0e Ici, on calcule les termes de serpent de proche en proche. En utilisant du calcul matriciel, ou mieux polynomial, on pourra calculer des termes \u00e9loign\u00e9s de serpent . Il faudra maitriser l'exponentiation rapide et le calcul modulaire. Z","title":"Nombre serpent"},{"location":"4-Tdifficile/nb_serpent/sujet/#nombres-qui-serpentent","text":"On dira d'un entier qu'il serpente si ses chiffres alternent entre croissants et d\u00e9croissants quand on les lit. Par exemple : \\(8\\) , \\(90\\) , \\(243\\,516\\) et \\(31\\,524\\) sont des nombres serpent ; \\(44\\) , \\(123\\) et \\(4235\\) ne sont pas des nombres serpent. Objectif : Compter les nombres serpent qui ont \\(n\\) chiffres, pour \\(n\\) inf\u00e9rieur \u00e0 100. Les z\u00e9ros de t\u00eate sont interdits (sauf pour z\u00e9ro lui-m\u00eame) pour les nombres, ainsi \\(08\\) ne compte pas comme un nombre serpent. Calculer un tableau d'entiers serpent de longueur au moins 100 tel que serpent[n] donne l'effectif des nombres serpent \u00e0 n chiffres. Exemples Les nombres serpent \u00e0 0 chiffre n'existent pas. Il n'y en a aucun ; 0 . Les nombres serpent \u00e0 1 chiffre sont \\(0\\) , \\(1\\) , \\(2\\) , \\(\\cdots\\) , \\(8\\) , et \\(9\\) . Il y en a 10 . Parmi les nombres serpent \u00e0 2 chiffres, il y a \\(10\\) , \\(12\\) , \\(13\\) , ..., \\(20\\) , \\(21\\) , \\(23\\) , ..., \\(98\\) . Il y en a 81 : de \\(10\\) inclus \u00e0 \\(100\\) exclu, il y en a 90, auquel on enl\u00e8ve les 9 nombres \\(11\\) , \\(22\\) , ..., \\(99\\) qui ne sont pas serpent. Parmi les nombres serpent \u00e0 3 chiffres, il y a \\(101\\) , \\(121\\) , \\(120\\) , ..., \\(205\\) , \\(218\\) , \\(230\\) , ..., \\(989\\) . Il y en a 525 . \ud83d\udc0d Console Python >>> serpent [ 0 ] 0 >>> serpent [ 1 ] 10 >>> serpent [ 2 ] 81 >>> serpent [ 3 ] 525 >>> len ( serpent ) >= 100 True Indice 1 Si on sait que : Il y a \\(A\\) nombres serpent de taille 20 qui finissent par 0 en d\u00e9croissant . Il y a \\(B\\) nombres serpent de taille 20 qui finissent par 1 en d\u00e9croissant . Il y a \\(C\\) nombres serpent de taille 20 qui finissent par 2 en d\u00e9croissant . Il y a \\(D\\) nombres serpent de taille 20 qui finissent par 3 en d\u00e9croissant . Il y a \\(a\\) nombres serpent de taille 20 qui finissent par 0 en croissant. Il y a \\(b\\) nombres serpent de taille 20 qui finissent par 1 en croissant. Il y a \\(c\\) nombres serpent de taille 20 qui finissent par 2 en croissant. Il y a \\(d\\) nombres serpent de taille 20 qui finissent par 3 en croissant. Pouvez-vous d\u00e9duire la quantit\u00e9 de nombres serpent \u00e0 21 chiffres qui finissent par 3 en croissant ? Solution Il s'agit de \\(A+B+C+D\\) . En effet, s'il finit par 3 en croissant, c'est qu'avant, c'\u00e9tait 0 , 1 , 2 ou 3 , qu'il \u00e9tait de taille 20 et qu'il finissait en d\u00e9croissant . Indice 2 G\u00e9n\u00e9raliser une formule qui donne : l'effectif des nombres serpent de taille \\(n+1\\) qui finissent par i en d\u00e9croissant ; l'effectif des nombres serpent de taille \\(n+1\\) qui finissent par i en croissant. Tout cela en fonction des effectifs pour ceux de taille \\(n\\) . Indice 3 On utilisera deux tableaux : serpent_croissant de longueur 10, qui indique pour chaque chiffre i de 0 \u00e0 9, combien de nombres serpent \u00e0 \\(n\\) chiffres se finissent par i en croissant . serpent_decroissant de longueur 10, qui indique pour chaque chiffre i de 0 \u00e0 9, combien de nombres serpent \u00e0 \\(n\\) chiffres se finissent par i en decroissant . \u00c9crire les instructions qui permettent : de construire deux nouveaux tableaux serpent_croissant_suivant et serpent_decroissant_suivant qui contiennent les effectifs suivants en fonction des pr\u00e9c\u00e9dents. de remplacer des deux anciens tableaux par les nouveaux. Indice 4 \u00c9crire l'instruction simple qui calcule et stocke la bonne valeur de serpent[n] en fonction de serpent_croissant et serpent_decroissant . Indice 5 Initialiser correctement toutes vos variables et mettre en place la boucle qui fait progresser votre probl\u00e8me ; on parle de programmation dynamique. Lancer T\u00e9l\u00e9charger T\u00e9l\u00e9verser # testsbackslash-newlinebackslash-newlineassert serpent[0] == 0backslash-newlineassert serpent[1] == 10backslash-newlineassert serpent[2] == 81backslash-newlineassert serpent[3] == 525backslash-newlineassert len(serpent) >= 100backslash-newlinebackslash-newline# autres testsbackslash-newlinebackslash-newlineSERPENT = [0, 10, 81, 525, 3105, 18939, 114381, 693129, 4195557, 25405586, 153820395, 931359050, 5639156409, 34143908573, 206733865761, 1251728824798, 7578945799704, 45888871327435, 277847147039527, 1682304127857000, 10185986079451152, 61673933253012813, 373422269794761171, 2260990733622821388, 13689807788336374413, 82888812632681299575, 501873756436963255725, 3038736584593404112888, 18398889984004648394684, 111401282480312690455535, 674510568248786542723384, 4084014982140900066996999, 24727823639079446292398973, 149721601071325722314771768, 906531773865227322540527599, 5488852985453577921599786404, 33233812608096915187160862646, 201223516716003090938495558273, 1218364686502763138912251531858, 7376933539095247157524690209596, 44665730255556705813455277892969, 270441294975640547699726057576357, 1637463299259559727190050998356877, 9914484608068134973197170061461591, 60030050803623279460905640700537146, 363468918651916171818101177606787775, 2200725354342352358032848391711429287, 13324914006975819086503546268399064826, 80679460043917672551257824285696701631, 488496606399894533135228090580518726849, 2957740846732444497653596441045121744779, 17908478384122192100208036703515396114945, 108431946763990227509406490644619239949670, 656531885447794265344437789229847771602593, 3975157962881656804262109523464275982054206, 24068718032001765864399208734778590812059100, 145730859783006115692556683131127947572716351, 882368702182510621630923925514359365784813975, 5342550834809792396806303497681900898790602948, 32347984863840919439702872508060799643996329921, 195860022132767463457194622209195721131511619393, 1185889891791338408154534460189644031233260498090, 7180305710879381718473109708289839840279416225259, 43475191464705279658821205861906473192979193394551, 263232841190727052129577046753774486800584662952576, 1593817677320544472069315699698021405961289198127352, 9650219847374200686866980990825185077113651584259915, 58429985077851243131664519519650782811471472008138262, 353780868228289794214717741134865565936022487352042972, 2142066313342370732999494929764219945531265582381574084, 12969746254891643527206138735713153473581856857600095022, 78528996450069182818170035206950924986262776615228842359, 475476016435488792922724897174988743962786201248439181821, 2878904002664891282213725487897616787658753354127999437145, 17431138417229580981375607929954799920484191208458836849334, 105541756946171068442094408895636846737397539224743995138242, 639032413871166799425569675259991298503891964738270377571646, 3869202463497791194390022403538813795184824191022263105120261, 23427180497538227918384894216032536344822982120913486859005897, 141846489358451945872383596558786903972944914449980284295419669, 858849682975367577620868729238136646340508021279438150851189203, 5200148282012719554761322719583518251776093190150646249093143114, 31485768337525729063232789086930259474485679688747287900236134643, 190639488345634999172037991756500352751157724547714851328253128848, 1154280693648192732866441010454314021643048294494184927145989749181, 6988918881870570231769912232187671511248169744379692168541703509970, 42316385785669385595814350388619174876388240296223393673888607531882, 256216524505193716144733781060865175999482846906506651739660845744675, 1551335403784699437467403137673555159940026653854455786424502055338943, 9392998908573720332591434332116379298964835183480715231431284456457957, 56872568163674679661793660628819558901413442844685202596077017341738809, 344351047095241664581365027406377518948639259453576986455463834228076289, 2084970794607558707929544265766774574113298602455891036247922071247187506, 12624045290514652253974190059423751220374380450784779710821698749343369568, 76435852199532490537114357525478173578997382169325263461986888368804125371, 462802482644657363293397846264195190536976947251737947227949204965780224431, 2802168508345203224585165008456703166541527129222571530462213246984687687723, 16966521666631831399368304014981269907585511181598421802474676023379660074148, 102728603439442098192781482549970023263233791039643568211308707933725742061091, 621999380425342872846895049949523920352287482295049627234230430671848280308249]backslash-newlinebackslash-newlinefor n, attendu in enumerate(SERPENT):backslash-newline assert serpent[n] == attendu, f\"Erreur pour n = {n}\"backslash-newlinebackslash-newline Valider 5/5 serpent = [0, 10]backslash-newlineserpentpython-underscorecroissant = [0] + [1] python-star 9backslash-newlineserpentpython-underscoredecroissant = [0] + [1] python-star 9backslash-newlinebackslash-newlinefor python-underscore in range(2, 100):backslash-newline newpython-underscorecroissant = [0] python-star 10backslash-newline newpython-underscoredecroissant = [0] python-star 10backslash-newline for i in range(10):backslash-newline newpython-underscorecroissant[i] = sum(serpentpython-underscoredecroissant[j] for j in range(0, i))backslash-newline newpython-underscoredecroissant[i] = sum(serpentpython-underscorecroissant[j] for j in range(i+1, 10))backslash-newline serpentpython-underscorecroissant = newpython-underscorecroissantbackslash-newline serpentpython-underscoredecroissant = newpython-underscoredecroissantbackslash-newline serpent.append(sum(serpentpython-underscorecroissant) + sum(serpentpython-underscoredecroissant))backslash-newlinebackslash-newline# testsbackslash-newlinebackslash-newlineassert serpent[0] == 0backslash-newlineassert serpent[1] == 10backslash-newlineassert serpent[2] == 81backslash-newlineassert serpent[3] == 525backslash-newlineassert len(serpent) >= 100backslash-newlinebackslash-newline A","title":"Nombres qui serpentent"},{"location":"4-Tdifficile/nb_serpent/sujet/#commentaires","text":"{{ py('exo_corr') }} On peut remplacer les lignes 6 \u00e0 10 par des listes en compr\u00e9hension. \ud83d\udc0d Script Python new_croissant = [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )] new_decroissant = [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )] \u00c0 la suite de quoi, il est possible de se passer des tableaux new_* de mani\u00e8res explicites. Ils seront toutefois toujours cr\u00e9\u00e9s par Python !!! Le code de la boucle devient alors \ud83d\udc0d Script Python for _ in range ( 2 , 100 ): serpent_croissant , serpent_decroissant = ( [ sum ( serpent_decroissant [ j ] for j in range ( 0 , i )) for i in range ( 10 )], [ sum ( serpent_croissant [ j ] for j in range ( i + 1 , 10 )) for i in range ( 10 )], ) serpent . append ( sum ( serpent_croissant ) + sum ( serpent_decroissant )) On a ici un style plut\u00f4t fonctionnel tr\u00e8s dense.","title":"Commentaires"},{"location":"4-Tdifficile/nb_serpent/sujet/#pour-aller-plus-loin","text":"Ici, on calcule les termes de serpent de proche en proche. En utilisant du calcul matriciel, ou mieux polynomial, on pourra calculer des termes \u00e9loign\u00e9s de serpent . Il faudra maitriser l'exponentiation rapide et le calcul modulaire. Z","title":"Pour aller plus loin"},{"location":"xtra/end/","text":"Z","title":"End"},{"location":"xtra/start/","text":"A","title":"Start"},{"location":"tags/","text":"Tags \u2693\ufe0e Pour une recherche d'exercices par tag POO \u2693\ufe0e Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e a_trou \u2693\ufe0e Collage Code de C\u00e9sar Suite de Conway texte inclus Nombre est-il palindrome Un mot est-il parfait ? Expression parenth\u00e9s\u00e9e Formes g\u00e9om\u00e9triques ASCII Fusion de listes tri\u00e9es Ins\u00e8re dans liste tri\u00e9e Sortie de labyrinthe Nombres de Catalan I Nombre Factoriel Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Tableau de 0 et 1 Transposition Tri \u00e0 bulles Triangle de Pascal Nombres de chemins dans une grille Nombres de Delannoy Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Nombres de chemins dans une grille (2) adhoc \u2693\ufe0e Soleil couchant Suite de Conway arbre \u2693\ufe0e Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e Nombres de Catalan II Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) boucle \u2693\ufe0e Maximum Compte d'occurrences Derni\u00e8re occurrence Est tri\u00e9 ? Indice premi\u00e8re occurrence Dentiste Liste des diff\u00e9rences Soleil couchant Exclamations Gel\u00e9es Multiplier sans * Recherche d'indices Remplacer une valeur Valeur et indice du max Collage Moyenne pond\u00e9r\u00e9e Nombres puis double Codage par diff\u00e9rence Moyenne simple \u00c9cr\u00eatage Palindrome D\u00e9coupe arange linspace Nombre de z\u00e9ros \u00e0 la fin d'un entier Top-Likes ! Occurrences du minimum Tous diff\u00e9rents Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents Suite de Syracuse Tri par s\u00e9lection Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Code de C\u00e9sar Suite de Conway Crible d'\u00c9ratosth\u00e8ne Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII Ins\u00e8re dans liste tri\u00e9e Nombre Factoriel Indice dans un tableau tri\u00e9 Tableau de 0 et 1 Triangle de Pascal Carr\u00e9s magiques normaux d'ordre n Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) chemin \u2693\ufe0e Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) compr\u00e9hension \u2693\ufe0e Transposition dictionnaire \u2693\ufe0e Anniversaires Top-Likes ! Couleurs Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents T\u00eate de s\u00e9rie Nombres de chemins dans une grille Nombres de Delannoy diviser pour r\u00e9gner \u2693\ufe0e Sommet d'un tableau unimodal float \u2693\ufe0e arange linspace glouton \u2693\ufe0e Rendu de monnaie graphe \u2693\ufe0e Sortie de labyrinthe grille \u2693\ufe0e Aplatir Sortie de labyrinthe Percolation Propagation sur image Redimensionner Transposition Carr\u00e9s magiques normaux d'ordre n maths \u2693\ufe0e Moyenne pond\u00e9r\u00e9e Rendu de monnaie Nombre de z\u00e9ros \u00e0 la fin d'un entier Suite de Syracuse Crible d'\u00c9ratosth\u00e8ne Un mot est-il parfait ? Nombres de Catalan I Nombre Factoriel Triangle de Pascal Nombre de z\u00e9ros de n! (1) Nombres de Catalan II Nombres de chemins dans une grille Nombres de Motzkin Nombres de Schr\u00f6der maths+ \u2693\ufe0e Carr\u00e9s magiques normaux d'ordre n Nombres de Delannoy Nombres d'Hipparque Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) Nombre de partitions m\u00e9mo \u2693\ufe0e Nombres de Catalan I Nombre Factoriel Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Nombre de partitions prog.dynamique \u2693\ufe0e communication des acacias Nombre de z\u00e9ros de n! (1) Nombre serpent r\u00e9cursivit\u00e9 \u2693\ufe0e Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Percolation Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Nombres de Catalan II Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) Nombre de partitions string \u2693\ufe0e Compte d'occurrences Dentiste Exclamations Collage Palindrome D\u00e9coupe Couleurs Dictionnaire d'occurrences Code de C\u00e9sar Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII tri \u2693\ufe0e Tri par s\u00e9lection Fusion de listes tri\u00e9es Tableau de 0 et 1 Tri \u00e0 bulles tuple \u2693\ufe0e Valeur et indice du max Moyenne pond\u00e9r\u00e9e Codage par diff\u00e9rence","title":"Tags"},{"location":"tags/#tags","text":"Pour une recherche d'exercices par tag","title":"Tags"},{"location":"tags/#poo","text":"Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e","title":"POO"},{"location":"tags/#a_trou","text":"Collage Code de C\u00e9sar Suite de Conway texte inclus Nombre est-il palindrome Un mot est-il parfait ? Expression parenth\u00e9s\u00e9e Formes g\u00e9om\u00e9triques ASCII Fusion de listes tri\u00e9es Ins\u00e8re dans liste tri\u00e9e Sortie de labyrinthe Nombres de Catalan I Nombre Factoriel Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Tableau de 0 et 1 Transposition Tri \u00e0 bulles Triangle de Pascal Nombres de chemins dans une grille Nombres de Delannoy Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Nombres de chemins dans une grille (2)","title":"a_trou"},{"location":"tags/#adhoc","text":"Soleil couchant Suite de Conway","title":"adhoc"},{"location":"tags/#arbre","text":"Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Expression parenth\u00e9s\u00e9e Nombres de Catalan II Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2)","title":"arbre"},{"location":"tags/#boucle","text":"Maximum Compte d'occurrences Derni\u00e8re occurrence Est tri\u00e9 ? Indice premi\u00e8re occurrence Dentiste Liste des diff\u00e9rences Soleil couchant Exclamations Gel\u00e9es Multiplier sans * Recherche d'indices Remplacer une valeur Valeur et indice du max Collage Moyenne pond\u00e9r\u00e9e Nombres puis double Codage par diff\u00e9rence Moyenne simple \u00c9cr\u00eatage Palindrome D\u00e9coupe arange linspace Nombre de z\u00e9ros \u00e0 la fin d'un entier Top-Likes ! Occurrences du minimum Tous diff\u00e9rents Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents Suite de Syracuse Tri par s\u00e9lection Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Code de C\u00e9sar Suite de Conway Crible d'\u00c9ratosth\u00e8ne Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII Ins\u00e8re dans liste tri\u00e9e Nombre Factoriel Indice dans un tableau tri\u00e9 Tableau de 0 et 1 Triangle de Pascal Carr\u00e9s magiques normaux d'ordre n Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2)","title":"boucle"},{"location":"tags/#chemin","text":"Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2)","title":"chemin"},{"location":"tags/#comprehension","text":"Transposition","title":"compr\u00e9hension"},{"location":"tags/#dictionnaire","text":"Anniversaires Top-Likes ! Couleurs Valeurs extr\u00eames Dictionnaire d'occurrences Dictionnaire des ant\u00e9c\u00e9dents T\u00eate de s\u00e9rie Nombres de chemins dans une grille Nombres de Delannoy","title":"dictionnaire"},{"location":"tags/#diviser-pour-regner","text":"Sommet d'un tableau unimodal","title":"diviser pour r\u00e9gner"},{"location":"tags/#float","text":"arange linspace","title":"float"},{"location":"tags/#glouton","text":"Rendu de monnaie","title":"glouton"},{"location":"tags/#graphe","text":"Sortie de labyrinthe","title":"graphe"},{"location":"tags/#grille","text":"Aplatir Sortie de labyrinthe Percolation Propagation sur image Redimensionner Transposition Carr\u00e9s magiques normaux d'ordre n","title":"grille"},{"location":"tags/#maths","text":"Moyenne pond\u00e9r\u00e9e Rendu de monnaie Nombre de z\u00e9ros \u00e0 la fin d'un entier Suite de Syracuse Crible d'\u00c9ratosth\u00e8ne Un mot est-il parfait ? Nombres de Catalan I Nombre Factoriel Triangle de Pascal Nombre de z\u00e9ros de n! (1) Nombres de Catalan II Nombres de chemins dans une grille Nombres de Motzkin Nombres de Schr\u00f6der","title":"maths"},{"location":"tags/#maths_1","text":"Carr\u00e9s magiques normaux d'ordre n Nombres de Delannoy Nombres d'Hipparque Nombre de z\u00e9ros de n! (2) Nombres de chemins dans une grille (2) Nombre de partitions","title":"maths+"},{"location":"tags/#memo","text":"Nombres de Catalan I Nombre Factoriel Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Nombre de partitions","title":"m\u00e9mo"},{"location":"tags/#progdynamique","text":"communication des acacias Nombre de z\u00e9ros de n! (1) Nombre serpent","title":"prog.dynamique"},{"location":"tags/#recursivite","text":"Hauteur et taille d'un arbre Arbre binaire de recherche Arbre binaire Percolation Propagation sur image Indice dans un tableau tri\u00e9 Rendu de monnaie Nombres de Catalan II Nombres de chemins dans une grille Nombres de Delannoy Nombres d'Hipparque Nombres de Motzkin Nombres de Schr\u00f6der Sommet d'un tableau unimodal Correspondance de \u0141ukasiewicz Correspondance de \u0141ukasiewicz (2) Nombre de partitions","title":"r\u00e9cursivit\u00e9"},{"location":"tags/#string","text":"Compte d'occurrences Dentiste Exclamations Collage Palindrome D\u00e9coupe Couleurs Dictionnaire d'occurrences Code de C\u00e9sar Nombre est-il palindrome Un mot est-il parfait ? Formes g\u00e9om\u00e9triques ASCII","title":"string"},{"location":"tags/#tri","text":"Tri par s\u00e9lection Fusion de listes tri\u00e9es Tableau de 0 et 1 Tri \u00e0 bulles","title":"tri"},{"location":"tags/#tuple","text":"Valeur et indice du max Moyenne pond\u00e9r\u00e9e Codage par diff\u00e9rence","title":"tuple"}]}